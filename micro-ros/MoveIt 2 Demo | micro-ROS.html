<!DOCTYPE html>
<html lang="en-US"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

    
        
            <script type="text/javascript" async="" src="MoveIt%202%20Demo%20|%20micro-ROS_files/analytics.js"></script><script async="" src="MoveIt%202%20Demo%20|%20micro-ROS_files/js.js"></script>


        
    

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="stylesheet" href="MoveIt%202%20Demo%20|%20micro-ROS_files/main.css">
    <link rel="stylesheet" href="MoveIt%202%20Demo%20|%20micro-ROS_files/font-awesome.css">

    <link rel="shortcut icon" href="https://micro.ros.org/favicon.ico?1">
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>MoveIt 2 Demo | micro-ROS</title>
<meta name="generator" content="Jekyll v3.9.0">
<meta property="og:title" content="MoveIt 2 Demo">
<meta property="og:locale" content="en_US">
<meta name="description" content="MoveIt 2 + micro-ROS demo This demo shows the integration between micro-ROS and MoveIt 2, a manipulation framework for robotics applications created and maintained by PickNik. By running this demo code, you can see how the MoveIt 2 manipulation and planification algorithms are fed by the position (attitude) calculated in a pose estimator that runs in micro-ROS. This pose is calculated by using data from inertial sensors. The final result is displayed with the ROS visualization tool RViz. micro-ROS runs in a a STM32L4 Development IoT kit board in combination with Zephyr. The board offers several general-purpose I/O pins and peripherals to communicate its 32-bits microcontroller with the external world. It also includes a lot of sensors. For this demo, we make use of a 6-DoF Inertial Measurement Unit (LSM6DSL), composed of an accelerometer and a gyroscope, and a 3-DoF magnetometer (LIS3MDL). The fusion of the measurements fetched by these sensors outputs the pose, or relative orientation of the board with respect to a fixed reference frame. The pose data is then forwarded to the ROS 2 world, where it is consumed by both RViz and MoveIt 2. RViz uses it directly to represent the position and orientation of the board in its graphical interface, and MoveIt 2 uses it to calculate the movement that the virtual arm has to perform to ‘touch’ it, according to its kinematic algorithms. The resulting movement is then integrated into RViz and represented by means of its virtual panda robotic arm, a standard tool used by MoveIt in tutorials and graphic interfaces. Usage micro-ROS Install and run micro-ROS attitude_estimator demo for ST Discovery board and Zephyr RTOS. For detailed info about the micro-ROS build system visit micro-ROS tutorials # Create a micro-ROS Agent ros2 run micro_ros_setup create_agent_ws.sh ros2 run micro_ros_setup build_agent.sh # Build and flash the micro-ROS app ros2 run micro_ros_setup create_firmware_ws.sh zephyr discovery_l475_iot1 # Check https://github.com/micro-ROS/zephyr_apps/tree/foxy/apps/attitude_estimator for instructions for tf2_msgs ros2 run micro_ros_setup configure_firmware.sh attitude_estimator -t serial -d 1 ros2 run micro_ros_setup build_firmware.sh # Connect the ST Discovery board with the ST-Link USB port and switch the power selector to the correct position ros2 run micro_ros_setup flash_firmware.sh # Run the micro-ROS Agent source install/local_setup.bash ros2 run micro_ros_agent micro_ros_agent serial --dev [ST Disco serial device] -v6 MoveIt2 Using a ROS 2 Foxy installation install MoveIt2 as explained in their webpage. Now in the same workspace: git clone https://github.com/micro-ROS/micro-ROS_moveit2_demo colcon build --event-handlers desktop_notification- status- --packages-select microros_moveit2_demo --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release source install/local_setup.bash ros2 launch microros_moveit2_demo microros_moveit2_demo.launch.py">
<meta property="og:description" content="MoveIt 2 + micro-ROS demo This demo shows the integration between micro-ROS and MoveIt 2, a manipulation framework for robotics applications created and maintained by PickNik. By running this demo code, you can see how the MoveIt 2 manipulation and planification algorithms are fed by the position (attitude) calculated in a pose estimator that runs in micro-ROS. This pose is calculated by using data from inertial sensors. The final result is displayed with the ROS visualization tool RViz. micro-ROS runs in a a STM32L4 Development IoT kit board in combination with Zephyr. The board offers several general-purpose I/O pins and peripherals to communicate its 32-bits microcontroller with the external world. It also includes a lot of sensors. For this demo, we make use of a 6-DoF Inertial Measurement Unit (LSM6DSL), composed of an accelerometer and a gyroscope, and a 3-DoF magnetometer (LIS3MDL). The fusion of the measurements fetched by these sensors outputs the pose, or relative orientation of the board with respect to a fixed reference frame. The pose data is then forwarded to the ROS 2 world, where it is consumed by both RViz and MoveIt 2. RViz uses it directly to represent the position and orientation of the board in its graphical interface, and MoveIt 2 uses it to calculate the movement that the virtual arm has to perform to ‘touch’ it, according to its kinematic algorithms. The resulting movement is then integrated into RViz and represented by means of its virtual panda robotic arm, a standard tool used by MoveIt in tutorials and graphic interfaces. Usage micro-ROS Install and run micro-ROS attitude_estimator demo for ST Discovery board and Zephyr RTOS. For detailed info about the micro-ROS build system visit micro-ROS tutorials # Create a micro-ROS Agent ros2 run micro_ros_setup create_agent_ws.sh ros2 run micro_ros_setup build_agent.sh # Build and flash the micro-ROS app ros2 run micro_ros_setup create_firmware_ws.sh zephyr discovery_l475_iot1 # Check https://github.com/micro-ROS/zephyr_apps/tree/foxy/apps/attitude_estimator for instructions for tf2_msgs ros2 run micro_ros_setup configure_firmware.sh attitude_estimator -t serial -d 1 ros2 run micro_ros_setup build_firmware.sh # Connect the ST Discovery board with the ST-Link USB port and switch the power selector to the correct position ros2 run micro_ros_setup flash_firmware.sh # Run the micro-ROS Agent source install/local_setup.bash ros2 run micro_ros_agent micro_ros_agent serial --dev [ST Disco serial device] -v6 MoveIt2 Using a ROS 2 Foxy installation install MoveIt2 as explained in their webpage. Now in the same workspace: git clone https://github.com/micro-ROS/micro-ROS_moveit2_demo colcon build --event-handlers desktop_notification- status- --packages-select microros_moveit2_demo --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release source install/local_setup.bash ros2 launch microros_moveit2_demo microros_moveit2_demo.launch.py">
<link rel="canonical" href="https://micro-ros.github.io//docs/tutorials/demos/moveit2_demo/">
<meta property="og:url" content="https://micro-ros.github.io//docs/tutorials/demos/moveit2_demo/">
<meta property="og:site_name" content="micro-ROS">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="MoveIt 2 Demo">
<script type="application/ld+json">
{"description":"MoveIt 2 + micro-ROS demo This demo shows the integration between micro-ROS and MoveIt 2, a manipulation framework for robotics applications created and maintained by PickNik. By running this demo code, you can see how the MoveIt 2 manipulation and planification algorithms are fed by the position (attitude) calculated in a pose estimator that runs in micro-ROS. This pose is calculated by using data from inertial sensors. The final result is displayed with the ROS visualization tool RViz. micro-ROS runs in a a STM32L4 Development IoT kit board in combination with Zephyr. The board offers several general-purpose I/O pins and peripherals to communicate its 32-bits microcontroller with the external world. It also includes a lot of sensors. For this demo, we make use of a 6-DoF Inertial Measurement Unit (LSM6DSL), composed of an accelerometer and a gyroscope, and a 3-DoF magnetometer (LIS3MDL). The fusion of the measurements fetched by these sensors outputs the pose, or relative orientation of the board with respect to a fixed reference frame. The pose data is then forwarded to the ROS 2 world, where it is consumed by both RViz and MoveIt 2. RViz uses it directly to represent the position and orientation of the board in its graphical interface, and MoveIt 2 uses it to calculate the movement that the virtual arm has to perform to ‘touch’ it, according to its kinematic algorithms. The resulting movement is then integrated into RViz and represented by means of its virtual panda robotic arm, a standard tool used by MoveIt in tutorials and graphic interfaces. Usage micro-ROS Install and run micro-ROS attitude_estimator demo for ST Discovery board and Zephyr RTOS. For detailed info about the micro-ROS build system visit micro-ROS tutorials # Create a micro-ROS Agent ros2 run micro_ros_setup create_agent_ws.sh ros2 run micro_ros_setup build_agent.sh # Build and flash the micro-ROS app ros2 run micro_ros_setup create_firmware_ws.sh zephyr discovery_l475_iot1 # Check https://github.com/micro-ROS/zephyr_apps/tree/foxy/apps/attitude_estimator for instructions for tf2_msgs ros2 run micro_ros_setup configure_firmware.sh attitude_estimator -t serial -d 1 ros2 run micro_ros_setup build_firmware.sh # Connect the ST Discovery board with the ST-Link USB port and switch the power selector to the correct position ros2 run micro_ros_setup flash_firmware.sh # Run the micro-ROS Agent source install/local_setup.bash ros2 run micro_ros_agent micro_ros_agent serial --dev [ST Disco serial device] -v6 MoveIt2 Using a ROS 2 Foxy installation install MoveIt2 as explained in their webpage. Now in the same workspace: git clone https://github.com/micro-ROS/micro-ROS_moveit2_demo colcon build --event-handlers desktop_notification- status- --packages-select microros_moveit2_demo --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release source install/local_setup.bash ros2 launch microros_moveit2_demo microros_moveit2_demo.launch.py","url":"https://micro-ros.github.io//docs/tutorials/demos/moveit2_demo/","@type":"WebPage","headline":"MoveIt 2 Demo","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="canonical" href="https://micro-ros.github.io//docs/tutorials/demos/moveit2_demo/">
    <link rel="alternate" type="application/rss+xml" title="micro-ROS" href="https://micro-ros.github.io//feed.xml">
</head>


<body>

    <nav class="navbar navbar-default navbar-fixed-top">
    <div class="container navbar-container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
            <a class="navbar-brand" href="https://micro.ros.org/">
                <span><img src="MoveIt%202%20Demo%20|%20micro-ROS_files/logonav.png" alt="Logo"></span> micro-ROS
            </a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
            <ul class="nav navbar-nav">
                <li><a href="https://micro.ros.org/docs/overview/">Overview</a></li>
                <li><a href="https://micro.ros.org/docs/concepts/">Concepts</a></li>
                <li class="active"><a href="https://micro.ros.org/docs/tutorials/">Tutorials</a></li>
                <li><a href="https://micro.ros.org/docs/api/">API</a></li>
                <li><a href="https://micro.ros.org/blog/2021/07/05/rosconfrance/">Blog</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
                <li><script src="MoveIt%202%20Demo%20|%20micro-ROS_files/lunr.js"></script>

<script>
    
    var documents = [{
        "id": 0,
        "url": "https://micro-ros.github.io//404.html",
        "title": "",
        "body": "  The page you are looking for cannot be found.   404: "
        }, {
        "id": 1,
        "url": "https://micro-ros.github.io//EDITING-INSTRUCTIONS.html",
        "title": "",
        "body": "This site uses the Jekyll-doc theme, see its [documentation](https://aksakalli. github. io/jekyll-doc-theme/docs/home/) for editing instructions. CustomizationsInstead of a “blog” section we have a “Updates” section in the folder _posts/ with posts-style. "
        }, {
        "id": 2,
        "url": "https://micro-ros.github.io//allposts.html",
        "title": "Blog",
        "body": "      All Posts {% for page in site. posts %}          {{ page. title }}      on {{ page. date | date:  %B %e, %Y  }} {% if page. author %} by {{ page. author }}{% endif %}         {% endfor %}  "
        }, {
        "id": 3,
        "url": "https://micro-ros.github.io//",
        "title": "",
        "body": "            &raquo;micro-ROS&raquo;puts ROS 2 onto microcontrollers&laquo;:                                   &nbsp;Mission:       Bridging the gap between resource-constrained microcontrollers and larger processors in robotic applications that are based on the Robot Operating Systems.                            &nbsp;Why Microcontrollers?:       Microcontrollers are used in almost every robotic product. Typical reasons are:               Hardware access        Hard, low-latency real-time        Power saving            Another important reason is safety, but note that micro-ROS is not developed according to any safety standard.               &nbsp;Key Features:               Microcontroller-optimized client API supporting all major ROS concepts        Seamless integration with ROS 2        Extremely resource-constrained but flexible middleware        Multi-RTOS support with generic build system        Permissive license        Vibrant community and ecosystem        Long-term maintainability and interoperability            &nbsp;Architecture:       The architecture of the micro-ROS stack follows the ROS&nbsp;2 architecture. Dark blue components are developed specifically for micro-ROS. Light blue components are taken from the standard ROS 2 stack.                                    &nbsp;Getting Started:       Our tutorials and demos give you a quick start with micro-ROS. The basic tutorials can even be completed without a microcontroller.                            &nbsp;Source Code:       Source code can be found at github. com/micro-ROS. It comes under the permissive license Apache 2. 0 just as the standard ROS 2 stack.       The primary repository is micro_ros_setup, which provides command line scripts for creating your first micro-ROS application.       Developed an new feature or found a bug? We answer both pull requests and tickets.                   &nbsp;News:       Read about the latest developments in our blog or attend the next ROS 2 Embedded Working Group Meeting, which take place online on a monthly basis. The meeting link can be found in the ROS 2 Events calendar.                                    &nbsp;Questions:       We are looking forward to answer your questions on concepts and development! You have the choice:               ROS Discourse (in category &ldquo;embedded&rdquo;)        ROS Answers (tag with &ldquo;embedded&rdquo;)        micro-ROS Slack Channel                                "
        }, {
        "id": 4,
        "url": "https://micro-ros.github.io//css/main.css",
        "title": "",
        "body": "@charset “utf-8”; // Import partials from sass_dir (defaults to _sass) @import {% if site. bootwatch %}  “bootswatch/{{site. bootwatch | downcase}}/variables”, {% endif %} “bootstrap”, {% if site. bootwatch %}  “bootswatch/{{site. bootwatch | downcase}}/bootswatch”, {% endif %} “syntax-highlighting”, “typeahead”; html { position: relative; min-height: 100%;}body { padding-top: $navbar-height + $navbar-margin-bottom; margin-bottom: 46px;} . navbar-brand{ img{  margin: -$navbar-padding-vertical 0;  height: $navbar-height;  padding: 10px 0; }} . header-container { background-color: black; background: url(‘. . /img/bg. jpg’) no-repeat 50% 0; color: #fff; h1 {  color: #fff; } // background-attachment: fixed; background-size: cover; background-position: center 36%; margin-top: -37px;}. navbar-container { font-size: 16px;}. page-content { padding-bottom: 20px;}. footer { position: absolute; bottom: 0; width: 100%; height: $footer-height; padding-top: 10px; background-color: $gray-lighter; color: $gray-dark;} . post-list-container { li a. active {  font-weight: bold; }}*[id]:before { display: block; content: “ “; margin-top: -75px; height: 75px; visibility: hidden;}. navbar-form . has-feedback . form-control-feedback{ top:10px} "
        }, {
        "id": 5,
        "url": "https://micro-ros.github.io//search.json",
        "title": "",
        "body": "[{% for section in site. data. docs %} {% for item in section. docs %}  {% assign item_url = item | prepend:”/docs/” | append:”/” %}  {% assign p = site. docs | where:”url”, item_url | first %}  {   “title”: “{{ p. title }}”,   “url”: “{{ p. url | prepend: site. baseurl }}” },  {% endfor %} {% endfor %}{% for post in site. posts %} { “title”: “{{ post. title | escape }}”, “url”: “{{ post. url | prepend: site. baseurl }}” }{% unless forloop. last %},{% endunless %} {% endfor %}] "
        }, {
        "id": 6,
        "url": "https://micro-ros.github.io//docs/api/",
        "title": "",
        "body": ""
        }, {
        "id": 7,
        "url": "https://micro-ros.github.io//benchmarking/",
        "title": "",
        "body": ""
        }, {
        "id": 8,
        "url": "https://micro-ros.github.io//benchmarking/concept/",
        "title": "",
        "body": ""
        }, {
        "id": 9,
        "url": "https://micro-ros.github.io//memo_prof/",
        "title": "",
        "body": ""
        }, {
        "id": 10,
        "url": "https://micro-ros.github.io//benchmarking/results/",
        "title": "",
        "body": ""
        }, {
        "id": 11,
        "url": "https://micro-ros.github.io//embedded_tf/",
        "title": "",
        "body": ""
        }, {
        "id": 12,
        "url": "https://micro-ros.github.io//real-time_executor/",
        "title": "",
        "body": ""
        }, {
        "id": 13,
        "url": "https://micro-ros.github.io//docs/concepts/client_library/real-time_executor/",
        "title": "",
        "body": ""
        }, {
        "id": 14,
        "url": "https://micro-ros.github.io//docs/concepts/",
        "title": "",
        "body": ""
        }, {
        "id": 15,
        "url": "https://micro-ros.github.io//docs/concepts/client_library/",
        "title": "",
        "body": ""
        }, {
        "id": 16,
        "url": "https://micro-ros.github.io//system_modes/",
        "title": "",
        "body": ""
        }, {
        "id": 17,
        "url": "https://micro-ros.github.io//docs/concepts/client_library/system_modes/",
        "title": "",
        "body": ""
        }, {
        "id": 18,
        "url": "https://micro-ros.github.io//docs/concepts/middleware/",
        "title": "",
        "body": ""
        }, {
        "id": 19,
        "url": "https://micro-ros.github.io//docs/concepts/middleware/",
        "title": "",
        "body": ""
        }, {
        "id": 20,
        "url": "https://micro-ros.github.io//docs/",
        "title": "",
        "body": ""
        }, {
        "id": 21,
        "url": "https://micro-ros.github.io//docs/overview/",
        "title": "",
        "body": ""
        }, {
        "id": 22,
        "url": "https://micro-ros.github.io//architecture/",
        "title": "",
        "body": ""
        }, {
        "id": 23,
        "url": "https://micro-ros.github.io//license/",
        "title": "",
        "body": ""
        }, {
        "id": 24,
        "url": "https://micro-ros.github.io//benchmarking/",
        "title": "",
        "body": ""
        }, {
        "id": 25,
        "url": "https://micro-ros.github.io//docs/tutorials/advanced/",
        "title": "",
        "body": ""
        }, {
        "id": 26,
        "url": "https://micro-ros.github.io//tracing/",
        "title": "",
        "body": ""
        }, {
        "id": 27,
        "url": "https://micro-ros.github.io//docs/tutorials/advanced/freertos/freertos_getting_started/",
        "title": "",
        "body": ""
        }, {
        "id": 28,
        "url": "https://micro-ros.github.io//docs/tutorials/advanced/nuttx/nuttx_getting_started/",
        "title": "",
        "body": ""
        }, {
        "id": 29,
        "url": "https://micro-ros.github.io//docs/tutorials/advanced/zephyr/zephyr_getting_started/",
        "title": "",
        "body": ""
        }, {
        "id": 30,
        "url": "https://micro-ros.github.io//docs/tutorials/core/",
        "title": "",
        "body": ""
        }, {
        "id": 31,
        "url": "https://micro-ros.github.io//docs/tutorials/",
        "title": "",
        "body": ""
        }, {
        "id": 32,
        "url": "https://micro-ros.github.io//crazyflie_demo/",
        "title": "",
        "body": ""
        }, {
        "id": 33,
        "url": "https://micro-ros.github.io//demobox_demo/",
        "title": "",
        "body": ""
        }, {
        "id": 34,
        "url": "https://micro-ros.github.io//kobuki_demo/",
        "title": "",
        "body": ""
        }, {
        "id": 35,
        "url": "https://micro-ros.github.io//docs/tutorials/demos/",
        "title": "",
        "body": ""
        }, {
        "id": 36,
        "url": "https://micro-ros.github.io//thumper_demo/",
        "title": "",
        "body": ""
        }, {
        "id": 37,
        "url": "https://micro-ros.github.io//redirects.json",
        "title": "",
        "body": "{“/docs/api/”:”https://micro-ros. github. io//docs/api/overview/”,”/benchmarking/”:”https://micro-ros. github. io//docs/tutorials/advanced/benchmarking/”,”/benchmarking/concept/”:”https://micro-ros. github. io//docs/concepts/benchmarking/concept/”,”/memo_prof/”:”https://micro-ros. github. io//docs/concepts/benchmarking/memo_prof/”,”/benchmarking/results/”:”https://micro-ros. github. io//docs/concepts/benchmarking/results/”,”/embedded_tf/”:”https://micro-ros. github. io//docs/concepts/client_library/embedded_tf/”,”/real-time_executor/”:”https://micro-ros. github. io//docs/concepts/client_library/execution_management/”,”/docs/concepts/client_library/real-time_executor/”:”https://micro-ros. github. io//docs/concepts/client_library/execution_management/”,”/docs/concepts/”:”https://micro-ros. github. io//docs/concepts/client_library/introduction/”,”/docs/concepts/client_library/”:”https://micro-ros. github. io//docs/concepts/client_library/introduction/”,”/system_modes/”:”https://micro-ros. github. io//docs/concepts/client_library/lifecycle_and_system_modes/”,”/docs/concepts/client_library/system_modes/”:”https://micro-ros. github. io//docs/concepts/client_library/lifecycle_and_system_modes/”,”/docs/concepts/middleware/”:”https://micro-ros. github. io//docs/concepts/middleware/memo_prof/”,”/docs/”:”https://micro-ros. github. io//docs/overview/features/”,”/docs/overview/”:”https://micro-ros. github. io//docs/overview/features/”,”/architecture/”:”https://micro-ros. github. io//docs/overview/features/”,”/license/”:”https://micro-ros. github. io//docs/overview/license/”,”/docs/tutorials/advanced/”:”https://micro-ros. github. io//docs/tutorials/advanced/overview/”,”/tracing/”:”https://micro-ros. github. io//docs/tutorials/advanced/tracing/”,”/docs/tutorials/advanced/freertos/freertos_getting_started/”:”https://micro-ros. github. io//docs/tutorials/core/first_application_rtos/freertos/”,”/docs/tutorials/advanced/nuttx/nuttx_getting_started/”:”https://micro-ros. github. io//docs/tutorials/core/first_application_rtos/nuttx/”,”/docs/tutorials/advanced/zephyr/zephyr_getting_started/”:”https://micro-ros. github. io//docs/tutorials/core/first_application_rtos/zephyr/”,”/docs/tutorials/core/”:”https://micro-ros. github. io//docs/tutorials/core/overview/”,”/docs/tutorials/”:”https://micro-ros. github. io//docs/tutorials/core/overview/”,”/crazyflie_demo/”:”https://micro-ros. github. io//docs/tutorials/demos/crazyflie_demo/”,”/demobox_demo/”:”https://micro-ros. github. io//docs/tutorials/demos/demobox_demo/”,”/kobuki_demo/”:”https://micro-ros. github. io//docs/tutorials/demos/kobuki_demo/”,”/docs/tutorials/demos/”:”https://micro-ros. github. io//docs/tutorials/demos/overview/”,”/thumper_demo/”:”https://micro-ros. github. io//docs/tutorials/demos/thumper_demo/”} "
        }, {
        "id": 38,
        "url": "https://micro-ros.github.io//robots.txt",
        "title": "",
        "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
        }, {
        "id": 39,
        "url": "https://micro-ros.github.io//blog/2021/07/05/rosconfrance/",
        "title": "micro-ROS at ROSCon France 2021",
        "body": "2021/07/05 - On June 23rd 2021, we presented micro-ROS at the ROSCOn France as invited speakers to contribute to the topic: micro-ROS: bringing ROS 2 to microcontrollers This session was presented by several partners of this project. The main objectives of this session were to introduce the micro-ROS framework, its architecture and current maturity as well as the default middleware Micro XRCE-DDS. First, Maria Merlan (eProsima) presented in detail a very clear and easy to follow introduction on how to bring ROS-2 to microcontrollers and the micro-ROS middleware architecture and the supported platforms. Secondly, Jan Staschulat (Bosch) gave us precisions on the architecture and how to code with rclc. Finally Pablo Garrido (eProsima) performed a live demonstration on “using micro-ROS with the ESP32 board”. Source: ROSCon France 2021 The presentation was very well received. For example the ROSCon organizer Olivier Strasse said: “This chat was actually extremely lively and contribute to further improving participation by French roboticists in global open source robotics activities. All the participants of ROSCon Fr 2021 benefited from their participation. ” At the end, they had a public chat with numerous questions by the French robotics community. We are happy about having been participants in the ROSCon France 2021 and therefore contribute to further dissemination of the micro-ROS framework as well as to improve participation by French roboticists in global open source robotics activities. "
        }, {
        "id": 40,
        "url": "https://micro-ros.github.io//blog/2021/04/13/ERF2021/",
        "title": "micro-ROS at European Robotics Forum 2021",
        "body": "2021/04/13 - On April 13th 2021, we presented micro-ROS at the European Robotics Forum 2021 in a dedicated workshop organized by several partners of this project. First, Francesca Finoccharo (eProsima) presented in detail the micro-ROS architecture, the supported platforms, several demonstrations and reported on new features: A versatile API for custom transports, continuous fragment mode, static memory pools in the RMW and time synchronization between client and agent: Then, Jan Staschulat (Bosch) gave an overview of the RCLC API with a code example and highlighted the deterministic behavior of the RCLC Executor: Two customers of micro-ROS presented their industrial use-cases and emphasized the benefit of micro-ROS: First, Anaëlle Sarazin (WYCA Robotics) presented “Elodie and micro-ROS”: And, secondly, Tomasz Rokosz (Hydra System) presented “micro-ROS enabled GNSS receiver”: Video of the demo by Hydra System: Finally, a panel discussion with Pablo Garrido Sanchez (eProsima), Alexandre Malki (PIAP), Jan Staschulat (Bosch), Anaëlle Sarazin (WYCA Robotics) and Tomasz Rokosz (Hydra System) stimulated a very lively participation of the audience. "
        }, {
        "id": 41,
        "url": "https://micro-ros.github.io//blog/2021/01/19/bosch-blog/",
        "title": "micro-ROS is a special guest @ BOSCH research blog!",
        "body": "2021/01/19 - Last week micro-ROS was dedicated a long and detailed post on a brand new Bosch Research Blog. Source: Bosch The post, written by Ralph Lange from Bosch and with title ‘micro-ROS – bringing the most popular robotics middleware onto tiny microcontrollers’, introduces micro-ROS to non-familiar readers and neophytes, and gathers all the relevant information regarding the latest developments and most recent achievements of the project. More specifically, it describes how the advanced execution management is handled by the rclc Executor and how the ROS 2 concepts of runtime lifecycle and system modes have been implemented in micro-ROS to fit microcontrollers. Also, it accounts for the support of FreeRTOS and Zephyr, on the RTOS side, and for ESP32 microcontrollers, on the hardware side, all achieved during last year of development. "
        }, {
        "id": 42,
        "url": "https://micro-ros.github.io//blog/2020/12/16/ROS-In/",
        "title": "micro-ROS @ ROS-Industrial Conference 2020!",
        "body": "2020/12/16 - micro-ROS was presented at the 2020 ROS-Industrial Conference in a joint talk given by Ralph Lange from Bosch, and by Francesca Finocchiaro and Pablo Garrido Sanchez from eProsima. In the first part of the talk, Ralph Lange presented the ROS 2 Executor design and discussed latest developments towards real-time support and determinism, which are important requirements for industrial applications. The talk also addressed the most recent features added in the Foxy release and for the Galactic release. Finally, he presented details on the rclc Executor for deeply embedded applications such as those addressed by micro-ROS. In the second part of the talk, Francesca Finocchiaro provided an overview of the micro-ROS project with a focus on its latest features and developments, and subsequently Pablo Garrido Sanchéz presented an entry-level hands-on demonstration intended for people willing to get started with micro-ROS. Find the presentations here and here. "
        }, {
        "id": 43,
        "url": "https://micro-ros.github.io//blog/2020/12/03/snap-uROS/",
        "title": "micro-ROS Agent on snap!",
        "body": "2020/12/03 - Like the XRCE-DDS Agent before it, now the micro-ROS Agent has been wrapped and delivered as a snap package, too! Snap is a package manager designed to bundle and handle applications and their dependencies on several Linux distros, like Ubuntu.  We prepared the Agent snap release in collaboration with Canonical. It comes with two ways of running it: as a simple executable or by means of a Linux service.  The first implies the usage of the Agent’s built-in CLI, where the user can specify the standard configuration parameters (such as transport, port…) directly, as follows: micro-ros-agent &lt;transport&gt; &lt;args&gt;The second launches the Agent as a Linux service running in the background; to do so, simply execute: snap set micro-ros-agent daemon=trueIn this case, instead of specifying the Agent’s launch parameters via the CLI, users can configure them thanks to the snap services interface, using the snap set micro-ros-agent &lt;param&gt;=&lt;value&gt; command. These parameters’ values are only valid when the daemon option is set to true, while they are ignored in snap run mode. The full list of configurable parameters can be found here. "
        }, {
        "id": 44,
        "url": "https://micro-ros.github.io//blog/2020/12/01/warehouse_duties/",
        "title": "New demo - micro-ROS enabling smart warehouse duties",
        "body": "2020/12/01 - In this brand new demo, micro-ROS showcases its capabilities in an environment that mimics a realistic industrial scenario like a smart warehouse, comprising a dynamic and distributed system of heterogeneous IoT devices. The demo was designed, orchestrated and recorded by OFERA partner PIAP. It presents a mobile platform interacting with a set of sensors and actuators based on microcontrollers running micro-ROS over 6LoWPAN and scattered in a simulated warehouse area, both indoor and outdoor, and is meant to show the seamless integration of these basic elements into a complex ROS 2 ecosystem thanks to micro-ROS. The mobile base is a scout robot designed for quick recognition of the surroundings, thanks to a localisation system providing coherent information on the platform position, and it features an on-board computer running a ROS 2 node. A regular computer is connected to the system via Wi-Fi, with which the ground station operator defines the tasks building up the overall mission, provides the required “world model” to execute it, and interchanges messages with the robot. An autonomy module is then in charge to drive the robot all the way down to the mission accomplishment. During its trajectory, the robot steps into a series of environmental devices, with which it intercommunicates when they are within the range of the wireless 6LoWPAN protocol, namely:  A humidity and temperature sensor from which it fetches measurements and sends them to the ground station operator; A door which can be opened remotely; A ToF (Time of Flight) sensor measuring distances and communicating whether the path is clear; A light that can be turned on and off. The communication is mediated by a micro-ROS Agent running on the on-board computer, which connects to the various micro-ROS Clients operating the sensors and actuators listed above as the robot moves across the simulated warehouse. In all devices, micro-ROS is running on an Olimex LTD STM32-E407 board, on top of the NuttX RTOS. "
        }, {
        "id": 45,
        "url": "https://micro-ros.github.io//blog/2020/11/30/roadmap_galactic/",
        "title": "Roadmap for ROS 2 Galactic",
        "body": "2020/11/30 - After reviewing our most recent accomplishments and dusting off our To-Do list, we drafted the roadmap for the next months of development and designed an exciting plan for the ROS 2 Galactic release. Our priorities will be:  Migrating all functionalities to the rclc, so as to convert it into the default micro-ROS user API and an independent abstraction layer on top of the rcl. Namely, the missing features to achieve this goal are:     Implement parameters in rclc, together with a dedicated parameters manager in the Agent.    Migrate actions to the rclc, as we recently did with services.    Migrate graphs to the rclc, based on their recent implementation both in the rmw and in the Agent.     Adapt micro-ROS packages and CI to the rolling release before Galactic is out.  Implement and polish a mature peer-to-peer functionality to achieve brokerless communication among Clients. Additional improvements: continue to improve the stability and extend the capability of the middleware layer, evaluating which efforts are worthy to be addressed (e. g. implement multi-threading). "
        }, {
        "id": 46,
        "url": "https://micro-ros.github.io//blog/2020/11/24/Arduino/",
        "title": "micro-ROS lands on Arduino",
        "body": "2020/11/24 - As in the last months more and more users have been manifesting an intrest in having micro-ROS on Arduino, we have been working in order to make this integration come to life. Arduino is an IDE designed to fit into extremely resource-constrained devices, offering an easy-to-use framework for programming MCUs among which, especially, a vast suite of development boards carrying the Arduino brand.  Based on this and on our recent release of a straight-to-the-point micro-ROS standalone library, which was already successfully integrated with the ESP-IDF and Zephyr build system, we were able to give support to the Arduino IDE. At present, it has already been ported it to several boards, namely: the the OpenCR 1. 0, the Teensy 3. 2 and 4. 0/4. 1, the Arduino Zero and the Arduino Due. This new integration is especially interesting in that it paves the way for a bare-metal support for micro-ROS. Find the dedicated repo at this link. "
        }, {
        "id": 47,
        "url": "https://micro-ros.github.io//blog/2020/11/20/IS/",
        "title": "New demo - ROS 2 to micro-ROS TCP tunneling via Integration Service",
        "body": "2020/11/20 - OFERA partner eProsima has been working on a demo combining several of its cutting-edge technologies. The demo shows how two separate ROS 2 dataspaces hosted by distinct subnets can be put into communication over the WAN thanks to Fast DDS TCP capabilities and to Integration Service, the tool enabling intercommunication of any protocol with Fast DDS. The setup consists of a ROS 2 node publishing velocity directives over the internet to a Turtlesim application and to a micro-ROS node operating a Kobuki Turtlebot2, both running on the remote hub. In the first dataspace we have a ROS 2 publisher sending data over a Twist type message. More in detail, a joy node is in charge of obtaining displacement commands from a gamepad, which are then converted into ROS 2-understandable Twist type messages by a second teleop_twist_joy node. The second dataspace handles two subscribers which receive the Twist topic sent by the teleop_twist_joy node. The first subscriber is a Turtlesim application, in charge of displacing the classic virtual turtle in its graphical interface according to the indications received by the remote node. The second subscriber is a micro-ROS Client, communicated with the ROS 2 dataspace via an Agent which allows it to subscribe to the Twist topic. With the data received, micro-ROS is in charge of instructing a Kobuki Turtlebot2, operated by an ESP32 MCU running FreeRTOS, to move accordingly. The remote communication is mediated by Integration Service, which is able to translate the ROS 2 messages into a language understandable by Fast DDS, and thanks to the TCP capabilities of the latter it connects via WAN the instances launched in the two subnets. Thanks to this, we can see how both the Kobuki robot and the Turtlesim are moving as they are being operated by the remote gamepad. "
        }, {
        "id": 48,
        "url": "https://micro-ros.github.io//blog/2020/11/18/luxonis/",
        "title": "micro-ROS goes AIoT!",
        "body": "2020/11/18 - We’re working with the LUXonis team on the integration of micro-ROS with an exciting AIoT (Artificial Intelligence of Things) project, involving the DepthAI BW1092 board. This small device enables interacting with LUXonis DepthAI SoM from an ESP32 microcontroller.  DepthAI is a platform built around the Myriad X which combines depth perception, neural inference and object tracking, all accessible via a Python API and a plug/play SoM with open-source hardware. It comes integrated with a variety of platforms, and in the case of the board we use for our project, it brings these capabilities to the embedded world. The DepthAI BW1092 features three cameras (a general one, plus two allowing for stereoscopic vision), making it possible to run 3D object detection out of the box. In turn, this allows retrieving the metadata coming out of a Neural Network, running inside the Myriad X processor, into the development environment of the ESP32 MCU. Thanks to the integration with micro-ROS, it will be possible to bring these data to the ROS 2 ecosystem, exposing ROS 2 topics with the results of classification networks with spatial vision coming out of an embedded device. If we get lucky with the integration we might be seeing soon our next PointCloud message coming directly from the DepthAI spatial vision calculations! "
        }, {
        "id": 49,
        "url": "https://micro-ros.github.io//blog/2020/11/12/graphs/",
        "title": "New support for graphs",
        "body": "2020/11/12 - We are getting every day closer to bringing the complete ROS 2 feature list into micro-ROS. Our last effort towards this direction is the inclusion of a dedicated graph manager into the micro-ROS Agent and Client’s RMW, marking the first big divergence point between the former and the Micro XRCE-DDS Agent, and providing micro-ROS with unprecedented introspection capabilities. To do so, we have added a DDS participant into the Agent that scans the network in search of the available ROS 2 entities (nodes, publishers, subscribers, services and so on), and publishes them onto a specific topic, which is listened to by the RMW. From this layer, the ROS 2 graph information is fetched by the upper layers and passed to the user. This is complemented by the ability of micro-ROS to also inject information about its own ROS 2 entities into the ROS 2 global dataspace, so that users executing graph-related tasks can gather information about which micro-ROS entities are present at the moment.  Examples to guide the user on how to use this new feature can be found here. "
        }, {
        "id": 50,
        "url": "https://micro-ros.github.io//blog/2020/11/12/ROS_world/",
        "title": "micro-ROS @ ROS World 2020!",
        "body": "2020/11/12 - This year’s ROSCon, due to the pandemic, has been transformed into a virtual event, full of awesome presentations and discussions, the ROS World 2020 Conference! We have been hosted by the FIWARE parallel track session, and the presentation circled around micro-ROS’ latest features and developments, after a due, though brief, introduction to the project. Among the topics that were discussed:  micro-ROS twofold build system approach Integration into Arduino, Zephyr and ESP-IDF development frameworks Client-Agent matching by discovery Graph support p2p functionality (WIP) New demo: micro-ROS &amp; MoveIt micro-ROS goes AIoT: integration with DephtAI, by LUXonisAnd that’s not it! micro-ROS will be also present as a featured guest in a bunch of other talks by collaborators and friends, among which Nuno Marques from the Dronecode Foundation and Francisco Melendez from FIWARE. Find the presentation here. "
        }, {
        "id": 51,
        "url": "https://micro-ros.github.io//blog/2020/10/05/moveit/",
        "title": "micro-ROS & MoveIt Demo!",
        "body": "2020/10/05 - We have packaged and delivered a new demo to showcase the integration between micro-ROS and MoveIt 2, a manipulation framework for robotic applications created and maintained by PickNik, especially designed to interoperate with ROS 2. The final result is displayed with the ROS visualization tool Rviz. We designed the demo in such a way that the MoveIt 2 manipulation and planification algorithms causes a virtual arm to reach out to the board as this is being moved in real space and publishes data on its position and orientation to the ROS 2 ecosystem. With this demo we bring micro-ROS to a whole different level: thanks to MoveIt’s kinematic planification talent, an app running on a microcontroller is enabled to be integrated into complex algorithms and ROS 2 workflows. This allows all robots in micro-ROS’ ecosystem to perform actual ‘stunts’ of all types. To run micro-ROS, we employ a STM32L4 Development IoT kit in combination with Zephyr. The board offers several general-purpose I/O pins and peripherals to communicate its 32-bits microcontroller with the external world. It also includes many sensors. For this demo, we make use of a 6-DoF Inertial Measurement Unit (LSM6DSL), composed of an accelerometer and a gyroscope, and a 3-DoF magnetometer (LIS3MDL). The fusion of the measurements fetched by these sensors outputs the pose, or quaternion attitude, of the board, providing its relative orientation with respect to a fixed reference frame. The pose data is then forwarded to the ROS world, where it is consumed by both Rviz and MoveIt. The former uses it directly to represent the position and orientation of the board in its graphical interface, while MoveIt uses it to calculate the movement that the virtual arm has to perform to “touch” it, according to its kinematic algorithms for motion planning. The resulting movement is then integrated into Rviz and represented by means of its virtual Panda robotic arm, a standard tool employed by MoveIt in tutorials and graphic interfaces. Find the full video of the demo below: Find the dedicated repo at this link, with instructions on how to reproduce the demo. "
        }, {
        "id": 52,
        "url": "https://micro-ros.github.io//blog/2020/10/01/zephyr_partnership/",
        "title": "micro-ROS is now Associate Member of the Zephyr Project",
        "body": "2020/10/01 - micro-ROS is now an Associate Partner of the Zephyr Project! Zephyr is a scalable open source Real-Time Operating System (RTOS) designed to fit resource constrained and embedded systems, with safety and security in mind. It forms part of the Linux Foundation, which supports a wide range of open source projects. Zephyr targets the same range of systems and applications with deterministic and time-critical constraints as micro-ROS, such as connected sensors and actuators, microcontrollers and small IoT devices of all kinds. micro-ROS and Zephyr complement each other by allowing to easily create heterogeneous distributed robotic systems and also integrate these devices seamlessly into the ROS 2 ecosystem. For additional information and the official press release by the Zephyr Project, follow this link. Disclaimer: All logos and product names are property of their respective owners. All company names, logos and product names used in this website are for identification purposes only. Their use does not imply endorsement. "
        }, {
        "id": 53,
        "url": "https://micro-ros.github.io//blog/2020/09/30/discovery/",
        "title": "A brand new discovery mechanism in micro-ROS",
        "body": "2020/09/30 - micro-ROS is now implementing client/server handshaking by discovery! The discovery mechanism allows micro-ROS Clients to discover Agents in the network by UDP. If a Client doesn’t know of any Agent beforehand, it sends a discovery call by multicast and the reachable Agents respond by sending information about them, such as their IP and port. The Client matches automatically with the first Agent that provides information, and the communication between the matched entities proceeds in the usual way.  micro-ROS inherits its discovery mechanism from the Micro XRCE-DDS library, which is then implemented in the RMW layer. Discovery is accessible by default at the Client level when using UDP transport, and can be activated in the Agent by using the -d flag when running it from terminal with the snap command: micro-xrce-dds-agent udp4 &lt;args&gt; -dIf you’re running instead the daemonized version of the Agent via the provided snap service, you can turn on the discovery mechanism like this: snap set micro-xrce-dds-agent discovery= true Find here an example showing how to use this new feature! "
        }, {
        "id": 54,
        "url": "https://micro-ros.github.io//blog/2020/09/24/microROS_and_FIWARE/",
        "title": "micro-ROS and FIWARE - Enabling Robotics Systems on Microcontrollers",
        "body": "2020/09/24 - On September 23rd, the FIWARE Foundation held a webinar titled “Enabling Robotics Systems on Microcontrollers”, as a part of its series of free webinars about open source platform components for Smart Solutions. The webinar focused on the interoperability between micro-ROS and FIWARE, made possible by eProsima Integration-Service and its core SOSS. SOSS is a platform that acts as a centralizing bridge to communicate incompatible protocols that speak different languages. Its working principle rests on System-Handles, plugins that put the core into communication with each of the protocols that are meant to be integrated into the platform. Once a system is integrated by means of a dedicated System-Handle, it can speak with any other system that is already integrated into the SOSS world. The SOSS-ROS2 and the SOSS-FIWARE System-Handles serve as key enablers to integrate micro-ROS into the FIWARE ecosystem, a framework of open source platform components which can be assembled together and with other third-party platform components to accelerate the development of Smart Robotics Solutions. Key contributions of Powered by FIWARE architectures to micro-ROS applications are:  Interfacing with the Internet of Things (IoT), Robots and third-party systems, for capturing updates on context information and translating required actuations.  Context Data/API management, publication, and monetization, bringing support to usage control and the opportunity to publish and monetize part of managed context data.  Processing, analysis, and visualization of context information implementing the expected smart behavior of applications and/or assisting end users in making smart decisionsFind the full presentation below: "
        }, {
        "id": 55,
        "url": "https://micro-ros.github.io//blog/2020/09/23/snap-XRCEDDS/",
        "title": "Micro XRCE-DDS Agent now on snap!",
        "body": "2020/09/23 - In collaboration with Canonical, we took the liberty to wrap the Micro XRCE-DDS Agent as a snap package, which sets an important milestone for easing the use of Micro XRCE-DDS.  Snap is a package manager designed to bundle and handle applications and their dependencies on several Linux distros, among which Ubuntu.  The snap packaging of the Agent comes with two ways of running it: as a simple executable or by means of a Linux service. The first implies the usage of the Agent’s built-in CLI, where you can specify the standard configuration parameters (such as transport, port…) directly, as follows: micro-xrce-dds-agent &lt;transport&gt; &lt;args&gt;The second launches the Agent as a Linux service running in the background; to do so, simply execute: snap set micro-xrce-dds-agent daemon=trueIn this case, instead of specifying the Agent’s launch parameters via the CLI, users can configure them thanks to the snap services interface, using the snap set micro-xrce-dds-agent &lt;param&gt;=&lt;value&gt; command. These parameters’ values are only valid when the daemon option is set to true, while they are ignored in snap run mode. To have a look at the full list of configurable parameters, click here. Given the closeness of the two Agents libraries, a snap release of the micro-ROS Agent is just one step away! Disclaimer: All logos and product names are property of their respective owners. All company names, logos and product names used in this website are for identification purposes only. Their use does not imply endorsement. "
        }, {
        "id": 56,
        "url": "https://micro-ros.github.io//blog/2020/09/18/FreeRTOS_blog/",
        "title": "micro-ROS is now on the FreeRTOS blog!",
        "body": "2020/09/18 - FreeRTOS is a market-leading and widely used Real Time Operating System (RTOS) for microcontrollers and embedded systems, built with an emphasis on reliability and ease of use. It was one of the first RTOSes to be integrated into micro-ROS’ modular software stack through the build system, which enables reuse of virtually all the tools and features provided by the FreeRTOS community and partners. In a recent post published on the FreeRTOS blog, we offer a technical and detailed recount on why FreeRTOS makes a lightweight and ideal RTOS over which running micro-ROS.  Two successful cases of integration of FreeRTOS with hardware relevant for micro-ROS’ typical target applications are the Crazyflie 2. 1 drone and the ESP32 MCU. The Crazyflie software makes profitable use of several FreeRTOS’ tools and functions, and a demo example of a micro-ROS application working with FreeRTOS on the Crazyflie can be found here. As for the second hardware, natively integrated with FreeRTOS and offering a ready-to-use Wi-Fi antenna and Bluetooth function, a very recent port of micro-ROS has been carried out and practical demos are in line. Good news is that, as the users base of both micro-ROS and FreeRTOS is rapidly expanding and compelling use-cases pop up, further integration of micro-ROS with the libraries offered by FreeRTOS and FreeRTOS+ is foreseen in the very near future. Stay tuned! "
        }, {
        "id": 57,
        "url": "https://micro-ros.github.io//blog/2020/09/09/2nd_EWG/",
        "title": "2nd ROS 2 Embedded Working Group",
        "body": "2020/09/09 - The ROS 2 Embedded WGs are back after the summer holidays! We will be hosting the next meeting on the 16th of September, at 5 pm CEST. Among the hot topics that will be discussed:  Benchmarking of the Client library A WIP peer-to-peer solution for micro-ROS A soon-to-come snap release of the micro-ROS and Micro XRCE-DDS Agents A new tutorial for creating entities by reference in the RMW A new tutorial for creating a new micro-ROS type The possibility to register Zephyr apps in a folder external to the micro-ROS/zephyr_apps repoand more! Check the complete agenda of the ROS 2 EWGs here.  "
        }, {
        "id": 58,
        "url": "https://micro-ros.github.io//blog/2020/09/03/memo-prof-xrcedds/",
        "title": "Memory Profiling of Micro XRCE-DDS",
        "body": "2020/09/03 - In response to the growing interest of the community in micro-ROS, a thorough benchmarking of the most relevant figures that are key to the product adoption is in demand. As a first step towards this direction, we recently performed a memory footprint analysis of the Micro XRCE-DDS library, the middleware underlying the micro-ROS architecture. The Micro XRCE-DDS Client library profiling has been performed for two simple applications, one publishing and the other subscribing to topics of known size, running on FreeRTOS, chosen by virtue of its memory management capabilities, and on an Olimex STM32-E407 board, which is the reference board of the micro-ROS project. The board is connected by serial transport (UART) at 115200 baud to a Micro XRCE-DDS agent running on a Linux machine. Notice that the XRCE-DDS Client is completely dynamic memory free, so all memory figures refer to the stack and static memory usage. The results for this analysis are summarized in the graphs below for publisher and subscriber applications, respectively.    Publisher Applications:       Subscriber Applications:    On the server side, we have investigated the memory consumption of an Agent communicating with a mock Client application on Linux that is publishing and subscribing to topics of known size, by measuring the binary size of the compiled agent (which resulted to be of 385 KB) and analysing heap and stack usages. The results for the latter are summarized in the plot below.  For more information regarding the methodology employed for performing these profilings, refer to the full report published on eProsima’s webpage. "
        }, {
        "id": 59,
        "url": "https://micro-ros.github.io//blog/2020/08/27/esp32/",
        "title": "micro-ROS porting to ESP32",
        "body": "2020/08/27 - The micro-ROS team is glad to announce that the pool of boards officially supported by the project has widened! The ESP32 MCU is now part of the family. ESP32 is a series of low-cost, low-power microcontrollers with integrated Wi-Fi and dual-mode Bluetooth, widely used for both commercial and industrial purposes.  micro-ROS targets mid-range and medium-to-high performance 32-bits microcontrollers families. Up to now, the boards officially supported by the project were solely based on the STM32 series from ST, MCUs featuring ARM Cortex-M processors. On the other hand, the ESP32 is an ultra-low power consumption dual-core system with two Xtensa LX6 CPUs, exposing a large collection of peripherals. Specifically, the port has been carried out for an Espressif ESP32-DevKitC-32E, an entry-level development board featuring an ESP32-WROOM-32E module integrating Wi-Fi and Bluetooth functions. The port makes use of FreeRTOS, one of the three RTOSes officially supported by the micro-ROS project, which is natively used by this family of boards, and supports the latest Foxy release of ROS 2. It works both with serial and Wi-Fi transports, the latter being particularly appealing as it marks the first hardware support of the micro-ROS project that exploits a natively integrated Wi-Fi antenna. Therefore, thanks to the combination of this highly capable Espressif board with micro-ROS, users will be able to develop wireless ROS2 applications that take advantage of the huge set of peripherals that ESP32 offers: I²C, SPI, I²S, LED drivers, PWM, etc. Furthermore, the ESP32-DevKitC-32E development board perfectly fits the typical requirements of the IoT systems targeted by micro-ROS, as it features a Flash memory of 4 MB, 448 KB ROM for booting and core functions, 520 KB SRAM for data and instructions and 16 KB SRAM in RTC. The recent port of micro-ROS to ESP32 thus sets a milestone towards expanding the family of MCUs supported by micro-ROS and paves the way for further ports, ensuring this project an ever wider base of hardware support. In order to try the new port, follow one of the core tutorials to install the micro-ROS build system, and then follow the instructions below: ros2 run micro_ros_setup create_firmware_ws. sh freertos esp32ros2 run micro_ros_setup configure_firmware. sh int32_publisher -t udp -i [your local machine IP] -p 8888ros2 run micro_ros_setup build_firmware. sh menuconfig# Now go to the micro-ROS Transport Settings → WiFi Configuration menu and fill your WiFi SSID and password. Save your changes, exit the interactive menu, and run:ros2 run micro_ros_setup build_firmware. sh# Connect your ESP32 to the computer with a micro-USB cable, and run:ros2 run micro_ros_setup flash_firmware. shIn order to open an agent you can find instructions here but we recommend using the docker image: docker run -it --rm --net=host microros/micro-ros-agent:foxy udp4 --port 8888 -v6"
        }, {
        "id": 60,
        "url": "https://micro-ros.github.io//blog/2020/07/24/foxy_release/",
        "title": "micro-ROS Foxy Release",
        "body": "2020/07/24 - We are glad to announce the release of micro-ROS Foxy and its compatibility with ROS 2 Foxy and Fast DDS 2. x. micro-ROS Foxy supports new hardware platforms in addition to the reference Olimex STM32-E407 evaluation board, namely the Crazyflie 2. 1 Drone and ST Discovery IoT kit (B-L475E-IOT01A),and new Real-Time Operating Systems (RTOSes) in addition to the already supported NuttX, specifically FreeRTOS and Zephyr v2. 3. 0. It uses the eProsima middleware Micro XRCE-DDS 1. 3. 0, fully compatible with the latest version of eProsima Fast DDS 2. 0 for ROS 2 Foxy. micro-ROS Foxy also features the implementation of the RCLC, an additional API that complements the ROS Client Support Library (RCL). The RCLC library is written in the C language and implements functionalities of the standard ROS 2 RCLCPP layer, adapting them to the capabilities and needsof the low-resource devices targeted by micro-ROS. Among them, the LET Executor and the Lifecycle. The RCLC Executor provides a C API to manage the execution of subscription and timer callbacks, similar to the RCLCPP Executor. It is optimized for resource-constrained devices and provides additional features that allow the manual implementationof deterministic schedules with bounded end-to-end latencies. The RCLC Lifecycle package provides convenience functions in C to bundle an RCL node with the ROS 2 Node Lifecycle state machine, similar to theRCLCPP Lifecycle Node. Finally, new demos and examples, combining the different hardware platforms and RTOSes supported and written in the new RCLC API,have been added to the already very complete pool of out-of-the-box and easy to use micro-ROS examples. Additionally, bug fixes and improvements have been implemented in the RMW and Micro XRCE-DDS Client library. For a complete list of improvements and bug fixes please read the release notes. "
        }, {
        "id": 61,
        "url": "https://micro-ros.github.io//blog/2020/07/17/EWG/",
        "title": "The ROS 2 Embedded Working Group is back",
        "body": "2020/07/17 - We are glad to announce that the ROS 2 Embedded Working Group meetings are back! Starting the next 22nd of July, at 5 pm CEST (8 am PDT) they’ll be retaken with a 4-weekly periodicity and with aspecial focus on micro-ROS and its middleware, Micro XRCE-DDS. The community is kindly invited to participate and to bring any micro-ROS related issues, doubts and projects to thisplatform. The proper way to be regularly updated and informed regarding the WG activities is to register to the dedicated Slackchat. To do so, go to the micro-ROS main page and get an invitation by subscribingwith your email address on the right bottom of the main page. Please find here the link to the Google meet andhere the agenda forthe first meeting. Everyone is welcome to add items that they consider relevant in the form of comments.  "
        }, {
        "id": 62,
        "url": "https://micro-ros.github.io//blog/2020/07/07/pX4_dev_summit/",
        "title": "micro-ROS at PX4 Developers Summit",
        "body": "2020/07/07 - micro-ROS and its middleware, Micro XRCE-DDS, were presented in a webinar held within the framework of the the 2020 PX4 Developer Summit. The PX4 Developer Summit is a 2-day event in which professionals from all over the world exchange technological insights of the drone sector. With around 50 speakers from companies like NXP, Microsoft, Open Robotics, Auterion, Dronecode and of course PX4, the topics vary from software development to hardware components. The webinar, with title “Bringing micro-ROS to PX4-based flying systems”, was presented by Jaime Martin, the CEO of eProsima and coordinator of the micro-ROS project, in conjunction with Nuno Marques, founder and lead software engineer of Drone Solutions. It covered the basic concepts around the micro-RTPS bridge used to integrate PX4 into the DDS world, and the proposal of migrating toa more mature, flexible and secure interface with DDS and ROS 2 based on micro-ROS and its middleware Micro XRCE-DDS. Find the full presentation below: "
        }, {
        "id": 63,
        "url": "https://micro-ros.github.io//blog/2020/06/27/ROS_dev_day/",
        "title": "micro-ROS at ROS Developers Day",
        "body": "2020/06/27 - eProsima has sponsored this year’s ROS Developers Day 2020 on June 27th, a yearly appointment that gathers the ROS community around topics of broadinterest for ROS developers of all levels. The third edition of this virtual event, hosted by The Construct, offers hands-on presentations about the ROS development with coding examples and various simulations. Speakers from Open Robotics, Wind River, Pal Robotics, the university lecturer Francisco Martin Rico and also eProsima Software Engineers, among others, shared their knowledge of the ROS/ROS 2 world. This year’s agenda included two lectures from eProsima, one regarding Server-Client Discovery in Fast DDS as an alternative node discovery mechanism for ROS 2, and the other about micro-ROS. The latter was given by the eProsima software engineer Pablo Garrido Sánchez, who shown with a very practical hands-on tutorial how to run micro-ROS on the Zephyr Real-Time Operating System (RTOS). Please find the video regarding the micro-ROS part below: "
        }, {
        "id": 64,
        "url": "https://micro-ros.github.io//blog/2020/06/17/fiware_webinar/",
        "title": "micro-ROS and Micro XRCE-DDS as Fiware enablers",
        "body": "2020/06/17 - On June 17th, eProsima held a webinar hosted by the Fiware Foundation, within the framework of a series of free webinars offered by Fiware about open source platform components for Smart Solutions. Both, eProsima and the Fiware Foundation, are members of the EU project OFERA, which gave birth and actually maintains the micro-ROS project. Jaime Martin, CEO at eProsima, presented “The Use of DDS Middleware in Robotics”, by giving an introduction about Fast DDS - the most complete open source DDS Middleware for ROS 2. Francesca Finocchiaro, Project Manager at eProsima, presented Micro XRCE-DDS - the lightweight DDS middleware for microcontrollers that is at the basis of micro-ROS, in addition to an introduction to the micro-ROS architecture and its usage in the context of robotics applications for resource-constrained environments. Find the recording of the presentation below: "
        }, {
        "id": 65,
        "url": "https://micro-ros.github.io//blog/2020/06/03/fiware_video/",
        "title": "micro-ROS Dissemination Video by FIWARE",
        "body": "2020/06/03 - The FIWARE Foundation, member of the EU project OFERA, has worked on a dissemination video for micro-ROS, to bring it to an ever broader audience. Ralph Lange, project manager in robotics systems &amp; software engineering at Bosch Corporate Research,one of the parties leading the micro-ROS project, has been interviewed at the IoT Solutions World Congress in Barcelona in October 2019. Ralph gives its voice to detail what the micro-ROS project is about and explain its main features very clearly andstraightforwardly. Find the video below: "
        }, {
        "id": 66,
        "url": "https://micro-ros.github.io//blog/2020/05/22/xrce-dds_130_release/",
        "title": "Release of eProsima Micro XRCE-DDS 1.3.0",
        "body": "2020/05/22 - eProsima, one of the founding members and coordinator of the EU project OFERA, announces the general availability of Micro XRCE-DDS 1. 3. 0. With this release Micro XRCE-DDS is fully compatible with the latest version of eProsima Fast DDS 2. 0 for ROS 2 Foxy. Micro XRCE-DDS is an open source wire protocol that implements the OMG DDS standard for eXtremly Resource Constrained Environments, and is the default Middleware implementing the RMW abstraction layer for the micro-ROS project. This release introduces the following new features:  Agent 1. 4. 0:     Added FastDDS middleware (compatible with ROS 2 Foxy).    Fixed TermiosAgent’s baudrate setting.     Client 1. 2. 3:     Modified examples installation.    Fixed minor Windows visibility function fixes.    For a complete list of improvements and bug fixes please read the release notes. "
        }, {
        "id": 67,
        "url": "https://micro-ros.github.io//blog/2020/05/12/xrce-dds_120_release/",
        "title": "Release of eProsima Micro XRCE-DDS 1.2.0",
        "body": "2020/05/12 - eProsima, one of the founding members and coordinator of the EU project OFERA, announces the general availability of Micro XRCE-DDS 1. 2. 0. Micro XRCE-DDS is an open source wire protocol that implements the OMG DDS standard for eXtremly Resource Constrained Environments, and is the default Middleware implementing the RMW abstraction layer for the micro-ROS project. This release introduces the following new features:  IPv6 support.  Requester/Replier support.  Packaging compatibility with colcon.  Isolated installation option.  Changed the serial transport. For a complete list of improvements and bug fixes please read the release notes. "
        }, {
        "id": 68,
        "url": "https://micro-ros.github.io//blog/2020/04/28/robotic-arm/",
        "title": "Warehouses automation with micro-ROS",
        "body": "2020/04/28 - Automation is the key to development within the supply chain and logistics sectors, as it has the potential to improve productivity while reducing costs and protecting workers’ health. At its most basic, an automated warehouse attempts to cut down on manual tasks that slow down the movement of goods, and to minimize the exposure of human workers to potential hazards. As robotics evolves, ever more warehouses plan to increase their investment in technology, with a focus on automation and scheduling tools. Below, we present a demo that exemplifies the potential entailed by micro-ROS to act as a first-line player in the next generation of robotics applications in the logistics sector. It showcases a ROS 2 enabled robotic arm (Robotis OpenMANIPULATOR-X) connected to a ST VL53l1X ToF sensor able to measure the distance between a target object and the base of the arm. The sensor is operated by an Olimex STM32-E407 development board, which features a STM32F407 microcontroller running Zephyr, a Real-Time Operating System that is especially convenient thanks to the large collection of sensor drivers available. On top, runs a micro-ROS app that is in charge of passing the distance measurements to the software controlling the arm kinematics. This communication is mediated by a Raspberry Pi 4 bridge, through which the arm is instructed to grab the object with millimetric precision and relocate it in a different position. Tasks of this kind can be integrated into a bigger and more complex operations chain, as building blocks of a fully automated protocol, relevant to sectors such as that of warehouses discussed above. Find the documentation for reproducing this demo here. "
        }, {
        "id": 69,
        "url": "https://micro-ros.github.io//blog/2020/03/03/micro-ROS-at-ERF2020/",
        "title": "micro-ROS at European Robotics Forum 2020",
        "body": "2020/03/03 - The 11th edition of the European Robotics Forum (ERF) was held in Malaga, Spain from 3rd to 5th March 2020. The ERF is one of the most important events in the European robotics community and especially the place where almost all EU-funded robotics projects present their works. All partners of the EU project behind micro-ROS together organized a booth to display our latest developments. Most important, we showed a demo with a Kobuki platform, a Crazyflie quadcopter, and an IoT sensor running three different RTOS (NuttX, FreeRTOS, and Zephyr) supported by micro-ROS. In the front right of the following photo, you can also see our demo box to illustrate the different boot times and power consumptions of microprocessors versus microcontrollers running ROS 2 and micro-ROS, respectively.  Our booth attracted a lot of interest: Many attendees visited us not only to talk about the demos and the status of micro-ROS, but also to discuss on the latest ROS 2 developments. In the ERF workshop on “Overcoming the boundaries of today’s Robotics Software Engineering”, Ralph Lange from Bosch Corporate Research also had the possibility to provide a short update on micro-ROS. "
        }, {
        "id": 70,
        "url": "https://micro-ros.github.io//blog/2019/11/01/micro-ROS-at-ROSCon2019/",
        "title": "micro-ROS at ROSCon 2019 Macau",
        "body": "2019/11/01 - ROSCon (https://roscon. ros. org) is the most important event of the ROS community. The 2019 edition was held in Macau, China. This edition has been the biggest to date with about 700 attendants. During this year’s event, micro-ROS was present in two different ways: a talk and booths on the exhibition floor. Talk: During the second day, Ingo and Borja presented micro-ROS to the ROS community. They presented the current status of the framework and supplement with some rationale on why to use it and why we need microcontrollers in robots. Exhibition: Within the exhibition floor, there were two booths with material directly related to micro-ROS, Bosch Corporate Research booth, and eProsima’s. In the Bosch booth, they had the next evolution of the micro-ROS community demo based on a Kobuki platform with different hardware setup and some premier of the upcoming updates to come. The eProsima booth was divided into two different spaces, one dedicated to Fast RTPS, their well known DDS implementation powering ROS 2 communications. The other space was dedicated to microcontrollers development with Micro XRCE-DDS and micro-ROS as main attractions. In this “micro” area, there was a TV showing a reel presentation of micro-ROS, the video prepared by FIWARE marketing team, and PIAP’s video on benchmarking. Also, in this area, and grabbing almost all the attraction of the public, there were two different micro-ROS demonstrations:  A first demonstration using a Crazyflie 2. 1 and sending data to the RVIz, which was visualized on the TV screen.  A second Crazyflie 2. 1 issuing commands to a Kobuki platform to move it.   Slides: Raising interest: During the whole duration of the conference, micro-ROS attracted much attention, and the demonstration was continuously being shown and explained. Most of the visitors were already working on microcontrollers. They also had an interest in communicating with ROS 2 but struggling their way to through, that is one of the reasons why micro-ROS attracted their attention. As final remark. Aside from members of the EU project OFERA, Renesas was showcasing the use of Micro XRCE-DDS in their RX65N MCU based platform, GR-ROSE. "
        }, {
        "id": 71,
        "url": "https://micro-ros.github.io//blog/2019/10/31/micro-ROS-at-IOTSWC/",
        "title": "micro-ROS at IoT Solutions World Congress",
        "body": "2019/10/31 - The IoT Solutions World Congress (IOTSWC) is an annual fair and congress on IoT in Barcelona and has been established in 2015. With more than 300 exhibitors and more than 15000 visitors, IOTSWC calls itself the “largest IoT event in the world to get inspired with new ideas, solutions and people. ” This year, we – the OFERA EU project consortium behind micro-ROS – got the opportunity to present micro-ROS at the IOTSWC on a booth organized by our project partner FIWARE FIWARE’s marketing team designed a six-page brochure (PDF) and a 4-minute explainer video (see above) on micro-ROS. In addition, FIWARE organized the whole booth design and construction. Yet, most important, they attracted thousands of visitors by the most beautiful exhibit on the fair: a 12m² LEGO city illustrating different IoT use-cases with tiny sensors, displays, and actuators.  The micro-ROS display was next to this LEGO city. Juan Flores and Ralph Lange, who did the booth service for micro-ROS during the three-day event, had their hands full. From the micro-ROS team, Bosch and eProsima had prepared a demo on micro-ROS with a Kobuki platform and a drone. One the first day, this demo was shown more than a hundred times. About half of the visitors had never heard of ROS before. The fact that ROS and micro-ROS come under very permissive open-source licenses was appreciated explicitly by most of them. A number of visitors had already worked with ROS 1 and were eager to learn more about ROS 2 and micro-ROS. Yet, there were even visitors with hands-on experience with the micro-ROS stack.  "
        }, {
        "id": 72,
        "url": "https://micro-ros.github.io//blog/2019/07/10/paper-and-industrial-pitch-at-ECRTS/",
        "title": "Paper and Industrial Pitch at ECRTS '19",
        "body": "2019/07/10 - ECRTS (Euromicro Conference on Real-Time Systems) is one of the most important scientific conferences of the real-time community. This year’s edition was held from 9 to 12 July in Stuttgart, Germany. Paper on a Response-Time Analysis of ROS 2: Tobias Blass, PhD student at Bosch Research and supervised by Björn B. Brandenburg of the Real-Time Systems Group of the Max Planck Institute for Software Systems, presented the paper Daniel Casini, Tobias Blass, Ingo Lütkebohle, and Björn B. Brandenburg: “Response-Time Analysis of ROS 2 Processing Chains Under Reservation-Based Scheduling”. Proc. of ECRTS ‘19. Stuttgart, Germany. July 2019. which is available at http://drops. dagstuhl. de/opus/volltexte/2019/10743/. One of the major contribution is a formal scheduling model of the ROS 2 rclcpp Executor. The results of this research have been also discussed in the new ROS 2 Real-Time Working Group and they are an important input for the work on an rcl-level Executor in micro-ROS. Industrial Pitch on Real-Time Execution Mechanisms: Ralph Lange from Bosch Research motivated the need for practical and easy-to-use real-time execution mechanisms for ROS in the industrial pitch session and the subsequent poster session. As a matter of course, on the poster, he also present the micro-ROS project and the plans for an rcl-level Executor with LET semantics. "
        }, {
        "id": 73,
        "url": "https://micro-ros.github.io//blog/2019/06/03/micro-ROS_temperature_publisher_demo/",
        "title": "micro-ROS temperature publisher demo release",
        "body": "2019/06/03 - This demo shows a use case in which one micro-ROS client publishes temperature value from a sensor using a micro-ROS bridge as a gateway to ROS 2. To run this demo, we will use an Olimex-STM32-E407 board with an HIH6130 temperature/humidity sensor and Raspberry Pi which works as a bridge. The Olimex board runs a micro-ROS client, in this client, we will bring-up a node and a topic, and it will publish the measured value of the sensor. At the same time, the Olimex board is connected by serial to a Raspberry Pi, which is running a micro-ROS agent. This micro-ROS agent will act as a gateway to the ROS 2 world, publishing this topic and making it visible from any device which runs ROS 2 in the same network. The next video shows this demo running.   (This video doesn’t work on Chrome) "
        }, {
        "id": 74,
        "url": "https://micro-ros.github.io//blog/2019/06/03/NuttX_micro-ROS-v0.0.2_relase/",
        "title": "micro-ROS NuttX v0.0.2-alpha and Apps v0.0.3 release.",
        "body": "2019/06/03 - We have launched a new version of NuttX and Apps for micro-ROS project which is base on NuttX 7. 29. This new version include the next improvements:  Improvement of the 6lowpan stack and interoperability with Linux 6lowpan stack.  ADC support.  DAC support.  And all the NuttX 7. 29 improvements which you can see here: NuttX 7. 29 versionYou can find the repositories here:  NuttX NuttX Apps"
        }, {
        "id": 75,
        "url": "https://micro-ros.github.io//blog/2019/05/06/partners-at-ROS-I_EU_spring_19_workshop/",
        "title": "Consortium partners at ROS-Industrial EU Tech Workshop",
        "body": "2019/05/06 - ROS-Industrial Consortium Europe (RIC-EU) hosted a Spring 2019 edition of their RIC-EU Tech Workshop. This edition took place on the 6th and 7th of May at Fraunhofer IPA in Stuttgart, Germany. This workshop was focused on DDS and ROS 2 developments for which members of the EU project OFERA were invited as Speakers. The OFERA members who assisted were Ralph Lange and Ingo Lütkebohle from BOSCH research and Jaime Martin and Borja Outerelo from eProsima. The workshop was split in two days, the first one was focused on DDS and an introduction to ROS 2, presented by Jaime Martin and Borja Outerelo respectively. The first half of the second day was filled with ROS 2 and micro-ROS presentations, from BOSCH partners, Ralph and Ingo. The second day was closed by Fraunhofer IPA representatives, Ludovic Delval and Harsh Deshpande presenting the migration of packages from ROS 1 to ROS 2. On day 1 and after the workshop presentation done by RIC-EU manager Thilo Zimmermann, Borja provided some rationale on the usage of DDS in the ROS 2 implementation and a hands-on with ros2 tools. Following this presentation, Jaime in-depth explained DDS concepts and eProsima DDS implementation. During this presentation, the assistants got the chance to use eProsima FastRTPS during a hands-on with their ShapesDemo and played around with some of the DDS QoS on top of a traditional “hello world” example. Staring Day 2, Ralph Lange gave an in-depth presentation of the current status of ROS 2 and some of the changes for the upcoming release, Dashing Diademata. Assistants had the chance to practice with ROS 2 with several hands-on parts proposed during the presentation. Following, Ingo Lütkebohle introduced the micro-ROS project. He presented all the work the EU project OFERA is doing to bring microcontrollers into the ROS 2 ecosystem. During his presentation, Ingo showcased the work done using micro-ROS demo on top of Kobuki. "
        }, {
        "id": 76,
        "url": "https://micro-ros.github.io//blog/2019/03/29/micro-ROS-at-ASD-workshop/",
        "title": "micro-ROS at ASD Workshop",
        "body": "2019/03/29 - The international workshop on Autonomous Systems Design (ASD) brought together about 50 researchers working on embedded and cyber-physical systems platform technologies as well as on methodologies for the design of autonomous and dependable systems. It was co-located with the DATE conference, which is one of the most important conferences and exhibition on electronic systems design and test. On invitation, Ralph Lange from Bosch provided an overview of the micro-ROS project and recent developments in ROS 2. He also pointed to the new micro-ROS community demo, which had been unveiled at the European Robotics Forum in Bucharest the week before. Slides: Bringing the Next Generation Robot Operating System on Deeply Embedded Autonomous Platforms (PDF) "
        }, {
        "id": 77,
        "url": "https://micro-ros.github.io//blog/2019/03/20/micro-ROS_at_ERF2019/",
        "title": "micro-ROS at European Robotics Forum 2019",
        "body": "2019/03/20 - The European Robotics Forum, the most influential meeting of the robotics community in Europe, was held in Bucharest, Romania, in March 2019. Over 900 European robotics top experts attended the 10th edition of the conference. OFERA consortium, taking advantage of the opportunity, arranged one of their face-to-face meetings the days before the ERF as some of the members will also be attending to the forum. In the forum and as part of the TG Software &amp; System Engineering Meeting, Ingo Luetkebohle from Bosch and Borja Outerelo from eProsima presented an overview of the micro-ROS project, exposing the challenges it faces and the involvement of the community via a demo and the ROS 2 Embedded SIG. The micro-ROS community demo was presented, making use of a Kobuki, one of the project reference platforms, Olimex STM32 E407 and micro-ROS stack. This community use case was also present in the exibitions area, as part of the Bosch booth. Slides: Videos: "
        }, {
        "id": 78,
        "url": "https://micro-ros.github.io//blog/2019/03/19/system-modes-released/",
        "title": "ROS 2 System Modes package released",
        "body": "2019/03/19 - We just released the ROS 2 system modes package that implements our attempt to allow behavioral system composition for ROS 2. System modes assume that the system is built from components with a lifecycle (see ROS 2 managed nodes). It adds a notion of (sub-)systems, hierarchically grouping these nodes, as well as a notion of modes that determine the configuration of these nodes and (sub-)systems in terms of their parameter values. Check the system_modes example package for a small step-by-step example. For more information, check the ROS wiki and the system_modes package on github. "
        }, {
        "id": 79,
        "url": "https://micro-ros.github.io//blog/2019/02/26/site-revamped/",
        "title": "micro-ROS site re-organized, tutorials added",
        "body": "2019/02/26 - Previously we had documentation in three different repos, which was a bit confusing. So, now, we’ve brought everything together and you can just browse the docs section! "
        }, {
        "id": 80,
        "url": "https://micro-ros.github.io//blog/2018/12/14/ric-eu/",
        "title": "micro-ROS@ROS Industrial 2018",
        "body": "2018/12/14 - The ROS Industrial Conference is one of the biggest gatherings of ROS users in Europe, focusing largely on automation, but also covering many related topics. Several people from the micro-ROS team were there and both Víctor Mayoral Vilches and Ingo Lütkebohle gave talks. Talk Links:  System Integration and Modularity in Robotics using ROS - Víctor Mayoral Vilches, Acutronic Robotics (slides/video) ROS on Embedded Devices - Recent Developments - Ingo Lütkebohle, Bosch Corporate Research (slides/video)Videos: Thanks to the ROS Industrial Team for inviting us and making the nice videos available! It’s been fun and informative. Summary Video: There’s also a nice summary video available "
        }, {
        "id": 81,
        "url": "https://micro-ros.github.io//blog/2018/11/13/ros-dev-podcast-ralph-lange/",
        "title": "ROS Developers Podcast with Ralph Lange",
        "body": "2018/11/13 - The ROS Developers Podcast (www. theconstructsim. com/category/ros_developers_podcast/) was launched by The Construct’s CEO Ricardo Téllez. On a weekly to biweekly basis, he publishes a half-hour interview with developers from the ROS community. In episode 29, from November 2018, Ralph Lange from Bosch was interviewed. He presented several works related to micro-ROS, including the Callback-group-level Executor and the system modes concept. Ralph particularly emphasized the need for real-time execution mechanisms in ROS 2 and micro-ROS. Link: http://www. theconstructsim. com/rdp-029-bosch-ros-projects-ralph-lange "
        }, {
        "id": 82,
        "url": "https://micro-ros.github.io//blog/2018/10/15/ros-dev-podcast-victor-mayoral/",
        "title": "ROS Developers Podcast with Víctor Mayoral",
        "body": "2018/10/15 - The ROS Developers Podcast (www. theconstructsim. com/category/ros_developers_podcast/) was launched by The Construct’s CEO Ricardo Téllez. On a weekly to biweekly basis, he publishes a half-hour interview with developers from the ROS community. In episode 25, from October 2018, Ricardo Téllez talked with Víctor Mayoral from Acutronic Robotics on ROS 2 and the Hardware Robot Operating System (or H-ROS), amongst others. Víctor introduced the importance of modularity and presented their current work with robot part manufacturers that aims to break the current lock-in in the robotics industry. Additionally, Víctor presented MARA, the first modular and collaborative industrial manipulator powered by ROS 2. Link: http://www. theconstructsim. com/rdp-025-hardware-robot-operating-system-h-ros-victor-mayoral/ "
        }, {
        "id": 83,
        "url": "https://micro-ros.github.io//blog/2018/09/30/roscon/",
        "title": "micro-ROS@ROSCon2018",
        "body": "2018/09/30 - ROSCon (https://roscon. ros. org) is the most important event of the ROS community. ROSCon has grown remarkably in the last years. In 2018, the conference was sold out already during the early registration phase. 500 developers and researchs from all over the globe attended ROSCon 2018 in Madrid. More than 1000 watched the live stream. Several people from the micro-ROS team attended the conference and delivered talks and demonstrations. In sum, three talks related to micro-ROS were provided: Iñigo Muguruza Goenaga (Erle Robotics), Juan Flores Muñoz (Erle Robotics), Víctor Mayoral Vilches (Erle Robotics), Loïc Dauphin (INRIA), Emmanuel Baccelli (INRIA), Cedric Adjih (INRIA): Towards ROS 2 microcontroller meta cross-compilation Slides: roscon. ros. org/2018/presentations/ROSCon2018_Towards_ROS2_uC_meta_crosscompilation. pdf Ralph Lange (Bosch): Mixed Real-Time Criticality with ROS 2 - the Callback-group-level Executor (lightning talk) Slides: roscon. ros. org/2018/presentations/ROSCon2018_Lightning1_4. pdf Irati Zamalloa (Erle Robotics): HRIM - The Hardware Robot Information Model (lightning talk) Slides: roscon. ros. org/2018/presentations/ROSCon2018_Lightning1_13. pdf "
        }, {
        "id": 84,
        "url": "https://micro-ros.github.io//docs/api/overview/",
        "title": "Overview",
        "body": " -  RMW Micro XRCE-DDS micro-ROS Utils RCLC"
        }, {
        "id": 85,
        "url": "https://micro-ros.github.io//docs/api/rclc/",
        "title": "RCLC",
        "body": " - TODO "
        }, {
        "id": 86,
        "url": "https://micro-ros.github.io//docs/api/rmw/",
        "title": "RMW",
        "body": " - micro-ROS RMW APIFunctions:           Name         void   rmw_uros_set_continous_serialization_callbacks(rmw_publisher_t * publisher, rmw_uros_continous_serialization_size size_cb, rmw_uros_continous_serialization serialization_cb)Sets the callback functions for continous serialization for a publisher.        rmw_ret_t   rmw_uros_set_custom_transport(bool framing, void * args, open_custom_func open_cb, close_custom_func close_cb, write_custom_func write_cb, read_custom_func read_cb)Check if micro-ROS Agent answers to micro-ROS client.        rmw_ret_t   rmw_uros_discover_agent(rmw_init_options_t * rmw_options)Fills rmw implementation-specific options with the autodicovered address of an micro-ROS Agent.        rmw_ret_t   rmw_uros_init_options(int argc, const char *const argv[], rmw_init_options_t * rmw_options)Parses command line args and fills rmw implementation-specific options.        rmw_ret_t   rmw_uros_options_set_serial_device(const char * dev, rmw_init_options_t * rmw_options)Fills rmw implementation-specific options with the given parameters.        rmw_ret_t   rmw_uros_options_set_udp_address(const char * ip, const char * port, rmw_init_options_t * rmw_options)Fills rmw implementation-specific options with the given parameters.        rmw_ret_t   rmw_uros_options_set_client_key(uint32_t client_key, rmw_init_options_t * rmw_options)Fills rmw implementation-specific options with the given parameters.        rmw_ret_t   rmw_uros_ping_agent(const int timeout_ms, const uint8_t attempts)Check if micro-ROS Agent is up and running.        bool   rmw_uros_epoch_synchronized()Returns the time synchronization state of the epoch time.        int64_t   rmw_uros_epoch_millis()Returns the epoch time in milliseconds taking into account the offset computed during the time synchronization.        int64_t   rmw_uros_epoch_nanos()Returns the epoch time in nanoseconds taking into account the offset computed during the time synchronization.        rmw_ret_t   rmw_uros_sync_session(const int timeout_ms)Synchronizes the session time using the NTP protocol.    Functions Documentation: function rmw_uros_set_continous_serialization_callbacks: void rmw_uros_set_continous_serialization_callbacks(  rmw_publisher_t * publisher,  rmw_uros_continous_serialization_size size_cb,  rmw_uros_continous_serialization serialization_cb)Sets the callback functions for continous serialization for a publisher. Parameters:  publisher publisher where continous serialization is being configured size_cb callback that should modify the total serialization size serialization_cb callback that should serialize the user part of the messagefunction rmw_uros_set_custom_transport: rmw_ret_t rmw_uros_set_custom_transport(  bool framing,  void * args,  open_custom_func open_cb,  close_custom_func close_cb,  write_custom_func write_cb,  read_custom_func read_cb)Check if micro-ROS Agent answers to micro-ROS client. Parameters:  framing Enable XRCE framing.  args Arguments for open function.  open_cb Open transport callback.  close_cb Close transport callback.  write_cb Write transport callback.  read_cb Read transport callback. Return:  RMW_RET_OK If correct.  RMW_RET_ERROR If invalid. function rmw_uros_discover_agent: rmw_ret_t rmw_uros_discover_agent(  rmw_init_options_t * rmw_options)Fills rmw implementation-specific options with the autodicovered address of an micro-ROS Agent. Parameters:  rmw_options Updated options with rmw specifics. Return:  RMW_RET_OK If arguments were valid and set in rmw_init_options.  RMW_RET_TIMEOUT If micro-ROS agent autodiscovery is timeout.  RMW_RET_INVALID_ARGUMENT If rmw_init_options is not valid or unexpected arguments. function rmw_uros_init_options: rmw_ret_t rmw_uros_init_options(  int argc,  const char *const argv[],  rmw_init_options_t * rmw_options)Parses command line args and fills rmw implementation-specific options. Parameters:  argc Number of arguments.  argv Arguments.  rmw_options Updated options with rmw specifics. Return:  RMW_RET_OK If arguments were valid and set in rmw_init_options.  RMW_RET_INVALID_ARGUMENT If rmw_init_options is not valid or unexpected arguments. rmw_init_options allocator is used to allocate the specific rmw options. function rmw_uros_options_set_serial_device: rmw_ret_t rmw_uros_options_set_serial_device(  const char * dev,  rmw_init_options_t * rmw_options)Fills rmw implementation-specific options with the given parameters. Parameters:  dev Serial device.  rmw_options Updated options with rmw specifics. Return:  RMW_RET_OK If arguments were valid and set in rmw_init_options.  RMW_RET_INVALID_ARGUMENT If rmw_init_options is not valid or unexpected arguments. function rmw_uros_options_set_udp_address: rmw_ret_t rmw_uros_options_set_udp_address(  const char * ip,  const char * port,  rmw_init_options_t * rmw_options)Fills rmw implementation-specific options with the given parameters. Parameters:  ip Agent IP address.  port Agent UDP port.  rmw_options Updated options with rmw specifics. Return:  RMW_RET_OK If arguments were valid and set in rmw_init_options.  RMW_RET_INVALID_ARGUMENT If rmw_init_options is not valid or unexpected arguments. function rmw_uros_options_set_client_key: rmw_ret_t rmw_uros_options_set_client_key(  uint32_t client_key,  rmw_init_options_t * rmw_options)Fills rmw implementation-specific options with the given parameters. Parameters:  client_key MicroXRCE-DDS client key.  rmw_options Updated options with rmw specifics. Return:  RMW_RET_OK If arguments were valid and set in rmw_init_options.  RMW_RET_INVALID_ARGUMENT If rmw_init_options is not valid or unexpected arguments. function rmw_uros_ping_agent: rmw_ret_t rmw_uros_ping_agent(  const int timeout_ms,  const uint8_t attempts)Check if micro-ROS Agent is up and running. Parameters:  timeout_ms Timeout in ms (per attempt).  attempts Number of tries before considering the ping as failed. Return:  RMW_RET_OK If micro-ROS Agent is available.  RMW_RET_ERROR If micro-ROS Agent is not available. This function can be called even when the micro-ROS context has not yet been initialized by the application logics. function rmw_uros_epoch_synchronized: bool rmw_uros_epoch_synchronized()Returns the time synchronization state of the epoch time. Return: true if last time synchronization succeded and false otherwise function rmw_uros_epoch_millis: int64_t rmw_uros_epoch_millis()Returns the epoch time in milliseconds taking into account the offset computed during the time synchronization. Return:  epoch time in milliseconds.  0 if session is not initialized. function rmw_uros_epoch_nanos: int64_t rmw_uros_epoch_nanos()Returns the epoch time in nanoseconds taking into account the offset computed during the time synchronization. Return:  epoch time in nanoseconds.  0 if session is not initialized. function rmw_uros_sync_session: rmw_ret_t rmw_uros_sync_session(  const int timeout_ms)Synchronizes the session time using the NTP protocol. Parameters:  timeout_ms The waiting time in milliseconds. Return:  RMW_RET_OK when success.  RMW_RET_ERROR If no session is running or the synchronization fails. "
        }, {
        "id": 87,
        "url": "https://micro-ros.github.io//docs/api/utils/",
        "title": "micro-ROS Utils",
        "body": " - micro-ROS Types UtilitiesFunctions:           Name         MICRO_ROS_UTILITIES_PUBLIC rosidl_runtime_c__String   micro_ros_utilities_type_info(const rosidl_message_type_support_t * type_support)Returns a string with the type instronspection data.        MICRO_ROS_UTILITIES_PUBLIC size_t   micro_ros_utilities_get_dynamic_size(const rosidl_message_type_support_t * type_support, const micro_ros_utilities_memory_conf_t conf)Returns the dynamic memory size that will be used for a type.        MICRO_ROS_UTILITIES_PUBLIC size_t   micro_ros_utilities_get_static_size(const rosidl_message_type_support_t * type_support, const micro_ros_utilities_memory_conf_t conf)Returns the static memory size that will be used for a type.        MICRO_ROS_UTILITIES_PUBLIC bool   micro_ros_utilities_create_message_memory(const rosidl_message_type_support_t * type_support, void * ros_msg, const micro_ros_utilities_memory_conf_t conf)Allocates the dynamic memory required for a message.        MICRO_ROS_UTILITIES_PUBLIC bool   micro_ros_utilities_create_static_message_memory(const rosidl_message_type_support_t * type_support, void * ros_msg, const micro_ros_utilities_memory_conf_t conf, uint8_t * buffer, size_t buffer_len)Allocates the memory required for a message in a user-provided buffer.        MICRO_ROS_UTILITIES_PUBLIC bool   micro_ros_utilities_destroy_message_memory(const rosidl_message_type_support_t * type_support, void * ros_msg, const micro_ros_utilities_memory_conf_t conf)Deallocates the dynamic memory of a message.    Functions Documentation: function micro_ros_utilities_type_info: MICRO_ROS_UTILITIES_PUBLIC rosidl_runtime_c__String micro_ros_utilities_type_info(  const rosidl_message_type_support_t * type_support)Returns a string with the type instronspection data. Parameters:  type_support ROS 2 typesupportReturn: rosidl_runtime_c__String string containing data       Attribute   Adherence         Allocates Memory   Yes       Thread-Safe   No       Uses Atomics   No       Lock-Free   Yes   function micro_ros_utilities_get_dynamic_size: MICRO_ROS_UTILITIES_PUBLIC size_t micro_ros_utilities_get_dynamic_size(  const rosidl_message_type_support_t * type_support,  const micro_ros_utilities_memory_conf_t conf)Returns the dynamic memory size that will be used for a type. Parameters:  type_support ROS 2 typesupport conf Utils configuratorReturn: size_t Size in Bytes that will be used       Attribute   Adherence         Allocates Memory   Yes       Thread-Safe   No       Uses Atomics   No       Lock-Free   Yes   function micro_ros_utilities_get_static_size: MICRO_ROS_UTILITIES_PUBLIC size_t micro_ros_utilities_get_static_size(  const rosidl_message_type_support_t * type_support,  const micro_ros_utilities_memory_conf_t conf)Returns the static memory size that will be used for a type. Parameters:  type_support ROS 2 typesupport conf Utils configuratorReturn: size_t Size in Bytes that will be used       Attribute   Adherence         Allocates Memory   Yes       Thread-Safe   No       Uses Atomics   No       Lock-Free   Yes   function micro_ros_utilities_create_message_memory: MICRO_ROS_UTILITIES_PUBLIC bool micro_ros_utilities_create_message_memory(  const rosidl_message_type_support_t * type_support,  void * ros_msg,  const micro_ros_utilities_memory_conf_t conf)Allocates the dynamic memory required for a message. Parameters:  type_support ROS 2 typesupport ros_msg ROS 2 msg with no type conf Utils configuratorReturn: bool true if success       Attribute   Adherence         Allocates Memory   Yes       Thread-Safe   No       Uses Atomics   No       Lock-Free   Yes   function micro_ros_utilities_create_static_message_memory: MICRO_ROS_UTILITIES_PUBLIC bool micro_ros_utilities_create_static_message_memory(  const rosidl_message_type_support_t * type_support,  void * ros_msg,  const micro_ros_utilities_memory_conf_t conf,  uint8_t * buffer,  size_t buffer_len)Allocates the memory required for a message in a user-provided buffer. Parameters:  type_support ROS 2 typesupport ros_msg ROS 2 msg with no type conf Utils configurator buffer User buffer buffer_len User buffer lengthReturn: bool true if success       Attribute   Adherence         Allocates Memory   Yes       Thread-Safe   No       Uses Atomics   No       Lock-Free   Yes   function micro_ros_utilities_destroy_message_memory: MICRO_ROS_UTILITIES_PUBLIC bool micro_ros_utilities_destroy_message_memory(  const rosidl_message_type_support_t * type_support,  void * ros_msg,  const micro_ros_utilities_memory_conf_t conf)Deallocates the dynamic memory of a message. Parameters:  type_support ROS 2 typesupport ros_msg ROS 2 msg with no type conf Utils configuratorReturn: bool true if success       Attribute   Adherence         Allocates Memory   Yes       Thread-Safe   No       Uses Atomics   No       Lock-Free   Yes   micro-ROS String UtilitiesFunctions:           Name         MICRO_ROS_UTILITIES_PUBLIC rosidl_runtime_c__String   micro_ros_string_utilities_init(const char * data)Create a rosidl_runtime_c__String from a char pointer.        MICRO_ROS_UTILITIES_PUBLIC rosidl_runtime_c__String   micro_ros_string_utilities_init_with_size(const size_t size)Create a rosidl_runtime_c__String from a size.        MICRO_ROS_UTILITIES_PUBLIC rosidl_runtime_c__String   micro_ros_string_utilities_set(rosidl_runtime_c__String str, const char * data)Create a rosidl_runtime_c__String from a char pointer.        const MICRO_ROS_UTILITIES_PUBLIC char *   micro_ros_string_utilities_get_c_str(rosidl_runtime_c__String str)Returns the char pointer to the rosidl_runtime_c__String data.        rosidl_runtime_c__String   micro_ros_string_utilities_append(rosidl_runtime_c__String str, const char * data)Appends a char pointer to the end of a rosidl_runtime_c__String.        MICRO_ROS_UTILITIES_PUBLIC rosidl_runtime_c__String   micro_ros_string_utilities_remove_tail_chars(rosidl_runtime_c__String str, const size_t n)Removes characters from the end of a string.        MICRO_ROS_UTILITIES_PUBLIC void   micro_ros_string_utilities_destroy(rosidl_runtime_c__String * str)Destroys a rosidl_runtime_c__String.    Functions Documentation: function micro_ros_string_utilities_init: MICRO_ROS_UTILITIES_PUBLIC rosidl_runtime_c__String micro_ros_string_utilities_init(  const char * data)Create a rosidl_runtime_c__String from a char pointer. Parameters:  data char pointerReturn: rosidl_runtime_c__String string containing data       Attribute   Adherence         Allocates Memory   Yes       Thread-Safe   No       Uses Atomics   No       Lock-Free   Yes   function micro_ros_string_utilities_init_with_size: MICRO_ROS_UTILITIES_PUBLIC rosidl_runtime_c__String micro_ros_string_utilities_init_with_size(  const size_t size)Create a rosidl_runtime_c__String from a size. Parameters:  size size of the required stringReturn: rosidl_runtime_c__String string of size size       Attribute   Adherence         Allocates Memory   Yes       Thread-Safe   No       Uses Atomics   No       Lock-Free   Yes   function micro_ros_string_utilities_set: MICRO_ROS_UTILITIES_PUBLIC rosidl_runtime_c__String micro_ros_string_utilities_set(  rosidl_runtime_c__String str,  const char * data)Create a rosidl_runtime_c__String from a char pointer. Parameters:  str rosidl_runtime_c__String to set data char pointerReturn: rosidl_runtime_c__String string containing data       Attribute   Adherence         Allocates Memory   Yes       Thread-Safe   No       Uses Atomics   No       Lock-Free   Yes   function micro_ros_string_utilities_get_c_str: const MICRO_ROS_UTILITIES_PUBLIC char * micro_ros_string_utilities_get_c_str(  rosidl_runtime_c__String str)Returns the char pointer to the rosidl_runtime_c__String data. Parameters:  str a rosidl_runtime_c__StringReturn: const char char pointer       Attribute   Adherence         Allocates Memory   Yes       Thread-Safe   No       Uses Atomics   No       Lock-Free   Yes   function micro_ros_string_utilities_append: rosidl_runtime_c__String micro_ros_string_utilities_append(  rosidl_runtime_c__String str,  const char * data)Appends a char pointer to the end of a rosidl_runtime_c__String. Parameters:  str a rosidl_runtime_c__String data characters to appendReturn: rosidl_runtime_c__String new string       Attribute   Adherence         Allocates Memory   Yes       Thread-Safe   No       Uses Atomics   No       Lock-Free   Yes   function micro_ros_string_utilities_remove_tail_chars: MICRO_ROS_UTILITIES_PUBLIC rosidl_runtime_c__String micro_ros_string_utilities_remove_tail_chars(  rosidl_runtime_c__String str,  const size_t n)Removes characters from the end of a string. Parameters:  str a rosidl_runtime_c__String n number of characters to removeReturn: rosidl_runtime_c__String new string       Attribute   Adherence         Allocates Memory   Yes       Thread-Safe   No       Uses Atomics   No       Lock-Free   Yes   function micro_ros_string_utilities_destroy: MICRO_ROS_UTILITIES_PUBLIC void micro_ros_string_utilities_destroy(  rosidl_runtime_c__String * str)Destroys a rosidl_runtime_c__String. Parameters:  str a rosidl_runtime_c__String      Attribute   Adherence         Allocates Memory   Yes       Thread-Safe   No       Uses Atomics   No       Lock-Free   Yes   "
        }, {
        "id": 88,
        "url": "https://micro-ros.github.io//docs/concepts/benchmarking/benchmarking/",
        "title": "Benchmarking",
        "body": " - Table of contents:  Introduction to Benchmarking Our benchmarking tool framework Trace Framework Abstraction Shadow Builder Binary generation for instrumented code     Receiving inputs   Parse and Check   TFA Execution   Compilation    Step to start benchmarkingIntroduction to Benchmarking: Developing a working and stable application, from the scribbles to the finalexecuting binary, is a long and hard task. During this process, developers may comeacross stability and perfomance issues. In addition to these issues, somespecified QoS might be difficult to quantify.  Solving those problems without theproper tools might be frustrating, tedious tasks leading to reduce developersefficiency. An adapted benchmarking tool could overcome all those developmentobstacles and increase development time.  There are different KPI (KeepPerformance Indicators) that one might be interested into. In the framework ofmicro-ROS, the KPI can be freely chosen by the developer. In this way, thebenchmarking tool will remain flexible and allow the community to constantly addsupport for a lot of different KPI. The problems we want to tackle are:  Out there, many benchmarking tools exist, each of them targeting different KPIs.  Different platforms (Linux/Nuttx/Baremetal et. c. ).  Too few time/resources to code benchmarking tool for each.  Avoid code overhead: Keep code clarity.  Avoid execution overhead: Do not want to make execution slower when benchmarking. Our Benchmarking tool framework: The benchmarking tool under development is providing a framework to allowdevelopers to create their own benchmarking tool. Each part a developer wants tobenchmark can be added as a plugin using the provided framework. In this wayplugins can be shared and this improves re-usability as much as possible. Trace Framework Abstraction: The Shadow builder alone only parse comments from the application and pass italong to the Trace Framework Abstraction (TFA) Core. The TFA core is aware ofthe plugins that are available, all the plugins’ capabilities and platformtarget. The process goes as explained below:  The line containing the functionality Benchmarking::XX::YY will be checkedagainst all the available plugins.  Plugins that are capable of handling functionality will respond with a piece ofcode that will be replaced with a piece of code.  Then the output file will be added in a folder corresponding to the platformtype and benchmarking type. Being generic is the key for this benchmarking tool. The plugins will incontrary bring the specific implementation needed to benchmark a specificplatform. Every plugin will provide information as requested by the parser:  Provide a list of supported platforms.  Provide a list of functions that are handled.  Provide snippet codes that will be added for benchmarking.  Provide a list of patches and/or patch code Optional provide an end script to run and execute the benchmarksShadow Builder: This section will introduce some concepts related to the shadow builder (SB). The Shadow builder is a tool that will transparently instrument the code tobenchmark. The tools will be able to output an “instrumented code” that will belater be compiled as a normal code. The following steps describe what the shadowbuilder process flow:  Get configuration file from the user (Benchmarking Configuration File).  Get appropriate sources.  Execute Trace Framework Abstraction Configuration file.  Parse the sources file needed Injecting code.  Compile the targeted binary for different platforms.  If needed, depending what type benchmark is undertaken, compile anothertarget binary benchmarking. The SB (Shadow Builder) is meant to be as transparent as possible for the user. And if the benchmarking is not activated, it should be bypassed. The SB is in charge of getting the path/git repository to the source code thatneeds to be benchmarking. The benchmarking. The sources are specified by theuser in the benchmarking configuration file. In order to inject code, there are some tools that allow this. CLang AST toolwill allow to inject some code. Binary generation for instrumented code: The binary generation is the process of compiling the source code. In order tobenchmark, previously to compile the source code, it is necessary to instrumentthe code. The code will be instrumented in a transparent way for theprogrammer/user. Therefore, a configuration file provided by the programmer willbe parsed and code injected as described in a configuration file. Receiving inputs: The binary generation’s pipeline receives two inputs to work with:  Configuration Benchmarking file.  Source code to benchmark. In short, the configuration describes:  What is benchmarked (sources).  Where to benchmark.  What type of benchmark.  Optionally against what base line to compare (base line source)Parse and Check: Once the input received the Shadow Builder parses the configurationfile. From the configuration file, the Shadow builder gets:  The different benchmarking to be achieved.  The targeted platforms. In addition to parsing, the Shadow Builder is in charge of checkingcapabilities and consistency within the configuration file and the differentTFA’s plugins registered in the TFA module. TFA Execution: Once parsed and checked against the TFA module capabilities, the ShadowBuilder will be in charge of translating configuration into source code. Thetranslated sources will also be achieved in cooperation with the TFA module. Thedetailed steps of the TFA can be found here. At the end of this step, the TFAwill generate the new forged source code ready for compilation. In addition topatched source code, the TFA will generate scripts that will the benchmarks. Compilation: The compilation will happen for every kind of benchmarks andplatforms targeted. Depending on the kind of benchmark that is being executed,there will be one or more binaries per benchmarks session. The number of binarygenerated also depends on what plugins are provided by the user to the shadowbuilder. The shadow builder will retrieve capabilities of the plugins andrequest from the developer, match them and generated software according to thematches. Step to start benchmarking: The shadow Builder will be executed as follow:  Software sources are passed to the Shadow Builder.  The source are passed and upon comments containing /Benchmarking::XX::YY/(a tag) the code line is passed to the Trace Framework Abstraction module. Using comments is preferable → No includes needed.  All plugins that registered to the TFA the Benchmarking::XX::YY functionalitywill return a piece of code that will be added to the source.  Once all parsed, the shadow builder will compile for all the differentplatforms requested either by plugins or by user configuration. "
        }, {
        "id": 89,
        "url": "https://micro-ros.github.io//docs/concepts/benchmarking/concept/",
        "title": "Concepts",
        "body": " - Table of contents:  Introduction to Benchmarking Our benchmarking tool framework Trace Framework Abstraction Shadow Builder Binary generation for instrumented code     Receiving inputs   Parse and Check   TFA Execution   Compilation    Step to start benchmarkingIntroduction to Benchmarking: Developing working and stable application from the scribbles to the finalexecuting binary is long and hard tasks. During this process developers may comeacross stabilities issues, perfomances issues. In addition to these issues, somespecified QoS might be difficult to quantify.  Solving those problems without theproper tools might be frustrating, tedious tasks leading to reduce developersefficiency. An adapted benchmarking tool could overcome all those developmentobstacles and increase development time.  There are different KPI (KeepPerformance Indicators) that one might be interested into. In the framework ofthis micro-ROS, the KPI can be freely chosen by the developer. In this way, thebenchmarking tool will remain flexible and allow the community to constantly addsome support for a lot of different KPI. The problems we want to tackle are:  Out there, many benchmarking tools exist. Each of targeting different KPIs.  Different platforms (Linux/Nuttx/Baremetal et. c. ).  Too few time/resources to code benchmarking tool for each.  Avoid code overhead: Keep code clarity.  Avoid execution overhead: Do not want to make execution slower when benchmarking. Our Benchmarking tool framework: The benchmarking tool under development is providing a framework to allowdevelopers to create their own benchmarking tool. Each part a developer wants tobenchmark can be added as a plugin using the provided framework. In this wayplugins can be shared and this improves re-usability as much as possible. Trace Framework Abstraction: The Shadow builder alone only parse comments from the application and pass italong to the Trace Framework Abstraction (TFA) Core. The TFA core is aware ofthe plugins that are available, all the plugins’ capabilities and platformtarget. The process goes as explained below:  The line containing the functionality Benchmarking::XX::YY will be checkedagainst all the available plugins.  Plugins that are capable of handling functionality will respond with a piece ofcode that will be replaced with a piece of code.  Then the output file will be added in a folder corresponding to the platformtype and benchmarking type. Being generic is the key for this benchmarking tool. The plugins will incontrary bring the specific implementation needed to benchmark a specificplatform. Every plugin will provide information as requested by the parser:  Provide a list of supported platforms.  Provide a list of functions that are handled.  Provide snippets codes that will be added for benchmarking.  Provide a list of patches and/or patch code Optional provide an end script to run and execute the benchmarksShadow Builder: This section will introduce some concept related to the shadow builder (SB). The Shadow builder is a tool that will transparently instrument the code tobenchmark. The tools will be able to output an “instrumented code” that will belater be compiled as a normal code. The following steps describe what the shadowbuilder process flow:  Get configuration file from the user (Benchmarking Configuration File).  Get appropriate sources.  Execute Trace Framework Abstraction Configuration file.  Parse the sources file needed Injecting code.  Compile the targeted binary for different platform.  If needed, depending what type benchmark is undertaken, compile anothertarget binary benchmarking. The SB (Shadow Builder) is meant to be as transparent as possible for the user. And if the benchmarking is not activated, it should be bypassed.  Getappropriate sources The SB is in charge of getting the path/git repository to the source code thatneeds to be benchmarking. The benchmarking. The sources are specified by theuser in the benchmarking configuration file.  Injecting code In order to inject code, there are some tools that allow this. CLang AST toolwill allow to inject some code. Binary generation for instrumented code: The binary generation is the process of compiling the source code. In order tobenchmark, previously to compile the source code, it is necessary to instrumentthe code. The code will be instrumented in a transparent way for theprogrammer/user. Therefore, a configuration file provided by the programmer willbe parsed and code injected as described in a configuration file. Receiving inputs: The binary generation’s pipeline receives two inputs to work with:  Configuration Benchmarking file.  Source code to benchmark. In short, the configuration describes:  What is benchmarked (sources).  Where to benchmark.  What type of benchmark.  Optionally against what base line to compare (base line source)Parse and Check: Once the input received the Shadow Builder parses the configurationfile. From the configuration file, the Shadow builder gets:  The different benchmarking to be achieved.  The targeted platforms. In addition to parsing, the Shadow Builder is in charge of checkingcapabilities and consistency within the configuration file and the differentTFA’s plugins registered in the TFA module. TFA Execution: Once parsed and checked against the TFA module capabilities, the ShadowBuilder will be in charge of translating configuration into source code. Thetranslated sources will also be achieved in cooperation with the TFA module. Thedetailed steps of the TFA can be found here. At the end of this step, the TFAwill generate the new forged source code ready for compilation. In addition topatched source code, the TFA will generate scripts that will the benchmarks. Compilation: The compilation will happen for every kind of benchmarks andplatforms targeted. Depending on the kind of benchmark that is being executed,there will be one or more binaries per benchmarks session. The number of binarygenerated also depends on what plugins are provided by the user to the shadowbuilder. The shadow builder will retrieve capabilities of the plugins andrequest from the developer, match them and generated software according to thematches. Step to start benchmarking: The shadow Builder will be executed as follow:  Software sources are passed to the Shadow Builder.  The source are passed and upon comments containing /Benchmarking::XX::YY/(a tag) the code line is passed to the Trace Framework Abstraction module. Using comments is preferable → No includes needed.  All plugins that registered to the TFA the Benchmarking::XX::YY functionalitywill return a piece of code that will be added to the source.  Once all parsed, the shadow builder will compile for all the differentplatforms requested either by plugins or by user configuration. "
        }, {
        "id": 90,
        "url": "https://micro-ros.github.io//docs/concepts/benchmarking/memo_prof/",
        "title": "Memory profiling",
        "body": " - Abstract: In this section, we analyze the memory footprint of the micro-ROS Client library. To perform the profiling, we have taken into account both applications of publishers/subscribers into/to ROS topics of known size and client/server type applications. We explored several different configurations by tuning key parameters such as message size, entity number, history size and transport protocol. Also, we discriminated between different types of memory. Indeed, while the XRCE-DDS Client is completely dynamic memory free, the micro-ROS Client makes use of both static and dynamic memory. It is therefore key to assess how much of each type of memory micro-ROS consumes, especially for what concerns real-timeness and determinism in the library behaviour. We performed the measurements for applications running on FreeRTOS and on an ESP32 board connected by UDP (via WiFi) to a micro-ROS Agent running on a Linux machine. Results show that the total memory consumption of the Client is higher than that of the XRCE-DDS middleware, at least by using the default configuration parameters of the library. However, by opportunely adjusting some of these parameters (e. g. , the MTU or the history size) to the needs of the specific application, it is possible to tune the total memory consumption to fit way better the limited resources of the target devices. Table of contents:  Memory management of the micro-ROS stack     Memory management of the XRCE-DDS library   Memory management of the RMW   Additional considerations   Memory buffers    Measurements and methodology     Tested scenarios   Results         Pub-Sub apps     Client-Server apps          Conclusions   Memory management of the micro-ROS stack: micro-ROS’ target devices are low-to-mid range Microcontroller Units (MCUs) with highly constrained resources, so that it is critical to assess the Client’s memory consumption to help users selecting the optimal library configuration for their application and the adequate platform on which to run it. Given the limited memory resources of these devices, the possibility to manipulate and tune its memory consumption is key. micro-ROS tries to address the memory management issue by prioritizing the use of static memory instead of dynamic memory as much as possible, and by optimizing the memory footprint of the applications by tuning a set of configuration parameters related with the memory resources at compile-time. This tuning can be done by acting on two different memory resources: those handled by the Micro XRCE-DDS library and those handled by its RMW implementation rmw-microxrcedds. In this section, we resume the most relevant parameters that control these resources and how the user can manipulate the micro-ROS memory consumption by acting on each of these layers. Memory management of the XRCE-DDS library: The Micro XRCE-DDS Client is completely dynamic and static memory free, implying that all memory footprint depends only on how the stack grows during the execution. Handling of this resource is done at configuration time, when the user can enable or disable several profiles before compiling, thus allowing to fix the executable code size. As part of these profiles, the user can control the memory growth by manipulating the Maximum Transmission Unit (MTU) and the communication streams. The MTU regulates the size of the communication streams and matches the available memory in the internal buffers of the transport layer, which is the memory block where the messages will be written and stored when exchanged.  It defaults to 512 B for all transports available in micro-ROS. Communication streams regulate how messages flow between the Clients and the Agent and represent ordered flows of information. There are two kinds of streams, Best-Effort and Reliable. Best-Effort streams consist in a single data buffer where only one message at a time is handled. Because of this, Best-Effort streams send and receive data leaving the reliability to the transport layer, and the message size handled by such a stream must be less or equal than the MTU defined in the transport used. On the other hand, Reliable streams enable lossless communication, regardless of the transport layer and allow message fragmentation to send and receive messages longer than the MTU. The number of chunks allowed to store the fragmented messages is controlled by the XRCE-DDS history (also referred to as XRCE_history in the following sections), which defaults to 4 slots. Memory management of the RMW: The rmw-microxrcedds layer uses static memory for allocating the resources associated with the ROS client support libraries, such as nodes, publishers, subscribers etc. This memory is managed by static memory pools that are shared among all the entities of a given application. The number of pools is fixed by the RMW message history (also referred to as RMW_history in the rest of the text), a parameter which is chosen by the user as a CMake flag. These RMW pools act as message queues where to keep the subscription messages before the user reads them. The size of each pool is given by the MTU × XRCE_history. Additional considerations: It should be clear by now that the two history buffers involved in the Client-Agent communication are different in nature: the XRCE-DDS history is used to store chunks of fragmented messages if Reliable communication is implemented. Thanks to this, in Reliable mode one can send or receive up to MTU × XRCE_history minus the memory reserved for headers, whereas Best-Effort communication streams can only exchange messages of size smaller or equal to the MTU.  The history of the RMW, in turn, controls the reception of data in the case of subscription and services. In this case, a buffer ring is generated in the RMW to store and cushion the data received from the XRCE-DDS library while handling the take calls received from the user’s interface to fetch the data and send them through the higher layers all the way up to the user’s application. Notice that this reflects the different behaviours of the XRCE-DDS library and of the RMW under subscription. While the XRCE-DDS library functions with callbacks, by warning the user whenever a new message comes in, the RMW functions by polling: this library listens to the topics the user has subscribed to and stores them until they are explicitly requested. Finally notice that the nature and size of the memory consumed by publications and subscriptions is quite different. The reason is that subscribers stockpile the data in pre-allocated memory buffers. This enables storage of messages in slots (whose number depends on the XRCE-DDS and RMW histories) for a twofold purpose: to avoid loss of data in the case Reliable communication has been opted for, and this is reflected by the XRCE-DDS history, and to allow a flexible message handling and asynchronous message passing between the various layers, which is reflected in the RMW_history. The case of services matches closely that of subscribers, since in a request/response pattern all entities involved need to receive, and thus store and handle, data. The diagrams shown below address all the features discussed in this section in a graphical way.   Fig. 1: Illustrative diagram of the memory management of the micro-ROS Client library in publishers and subscribers applications.   Fig. 2: Illustrative diagram of the memory management of the micro-ROS Client library in service applications. Memory buffers: The total memory consumed by a micro-ROS application running on a MCU can be calculated as the direct sum of different chunks of memory, each devoted to a different function: static memory, stack and dynamic memory. In this section we give a brief description on these kinds of memory used by the micro-ROS library. Static Memory The static memory has been calculated as the difference between the memory occupied by the . bss and . data sections with a non-zero number of entities, and the memory occupied by the same sections when no micro-ROS application is running, that is, the memory occupied by the rest of components of the RTOS and libraries. This allows discriminating between the memory effectively occupied by micro-ROS and the one that is not specific to it. Notice that we don’t take into consideration neither the constant data stored in flash memory (. text section) nor the data buffer, which is the buffer that stores the data before serialization, since it is specific to the user application and not directly related to the micro-ROS Client operations. Stack Memory The stack is the memory consumed by the functions used by the program, when executing. Whilst the static memory can be straightforwardly calculated by just analyzing the compiled binary objects, the stack is the chunk of memory one cannot know precisely before running the application. The stack consumed during the program execution is taken into account by means of a FreeRTOS specific function involved in the memory management capabilities offered by this RTOS, the uxTaskGetStackHighWaterMark() function. This function returns the amount of stack that remains unused when the stack consumed by the program is at its greatest value. By subtracting this figure to the total stack available, which is known, one can obtain the stack peak used by the app. Dynamic Memory This is the memory dynamically allocated by the program by calls to calloc() and malloc() functions in the C language. To measure it we have hijacked the call to dynamic memory related functions since the ROS 2 stack allows users to feed the program with custom memory allocators. To better understand micro-ROS’ use of dynamic memory, we need to differentiate between two stages of the micro-ROS operation. In the first stage micro-ROS is initialized, entities such as nodes, publishers and subscribers are created, and all layers get ready for operation. This is the configuration stage and micro-ROS performs all the dynamic memory operations here. The second is the operation stage, in which the actual publications, subscriptions and all other node operations occur. This stage is dynamic memory free in the whole micro-ROS stack. An optional third stage exists, in which the micro-ROS layers are closed and cleaned and all the dynamic memory allocated in the configuration stage is freed. Measurements and methodology: Tested scenarios: In this section, we summarize the experimental setup and the different scenarios explored in order to provide a comprehensive review on the memory footprint of the micro-ROS library. In general, our aim is to assess how both the total memory and its independent constituents (static, stack and dynamic) are affected by:  The topic size (in the form of an array of bytes of variable size) The number of ROS entities (pub/sub and service/client) The communication stream type used (Reliable vs Best-Effort)In the first setup, we analyse the total memory consumption of applications that publish or subscribe to topics of variable size while sweeping through the number of entities (publishers and subscribers) and employ UDP transport. We do so for the two different QoS types, Reliable and Best-Effort. In the second setup, we report on how the total memory is distributed between static, stack and dynamic. The third set of measurements was taken for one subscription only, for a fixed message size and varying the history cache of the RMW layer from 1 to 20 units. In the fourth set of measurements we measure the footprint of applications of requesters/repliers that act according to a client/service pattern. Results: In this section, we detail the methodology employed for the memory profiling of the experimental configurations described above, and for each of them we present the results obtained. The measurements are conducted on a micro-ROS Client application with a varying number of entities: either publishers/subscribers (from 1 to 15) or client/server (from 1 to 10). All the tested apps run on top of FreeRTOS and inside of an ESP32 board. The board is connected by UDP transport (WiFi) to a micro-ROS Agent running on a Linux machine. As explained above, the choice of FreeRTOS has been by virtue of its memory management functionalities, which easily allow to compute the memory used by applications. In order to provide an assessment as much realistic as possible, the following parameters have been set to their default values: the creation mode employed was by XML in all tested cases, the MTU was held fixed to its default value of 512 B, and the XRCE-DDS library history cache was always kept fixed to 4. Pub-Sub apps: Total memory as a function of entities number and message size In this section, we report the total memory used by either publisher or subscriber applications in both Best-Effort and Reliable modes, using UDP transport, an RMW history of 8 shared slots, an MTU of 512 B and an XRCE-DDS history of 4 slots. The total memory consumption is reported as a function of the entity number and message size. The number of publishers/subscribers has been varied, which is equivalent to changing the number of topics, since in our design of the set-up we associate each publisher/subscriber with just one topic. In principle, in the Reliable case one can occupy the generated buffers with message sizes up to MTU × XRCE_history, whereas in the Best-Effort case it can be filled with messages with size up to MTU, which correspond respectively to to 512 B × 4 = 2048 B and 512 B with our default chosen values. This is due to the absence of fragmentation in Best-Effort communication streams, while, thanks to fragmentation, an entity communicating in Reliable mode can send/receive a message opportunely chunked in a number of pieces equal to the XRCE_history, each of the size of the MTU. However, from table 1 one can see the message size only ranges from 0 and 1366 B in the case of Reliable entities, and between 0 and 490 B for entities in Best-Effort mode. This is due to the fact that in both cases some memory is consumed by headers and, most importantly, in the Reliable case, some is consumed by confirmation messages such as heartbeats and acknacks.   Fig 3: Total memory usage (in Bytes) of micro-ROS publisher and subscription applications in both Best-Effort and Reliable modes with UDP transport, default parameters and as a function of the entities number (x axis) and of the message size (legend). From these plots, we can draw some conclusions and observe trends. First of all it appears clear that the total memory consumption varies with the number of entities but not with the message size. The reason for this is that all message sizes explored fit into the static buffers pre-allocated by the program at compile-time. We therefore expect that the memory consumption would only vary with the message size when the total space occupied by the topic plus the confirmation messages (in the reliable case) and the overhead exceeds the buffer size. In the case of increasing the number of entities, instead, the overall memory grows (as we’ll see below, this is driven by an increase in both the static and the dynamic memories, while the stack is not affected). By performing a simple calculation, we can see that the memory occupied by one publisher under the above experimental conditions is of ~ 400 B, while that occupied by one subscriber is ~ 500 B. The fact that there is virtually no substantial difference between the memory usage of these two entities, notwithstanding the fact that subscribers have a RMW_history associated, is ascribable to the fact that the memory pools of the RMW are shared among all the entities participating in a given application, and therefore it doesn’t mark a difference between subscribers (in need to store messages before they are fetched from the higher layers) and publishers. Finally, we see that there is no substantial difference between Reliable and Best-Effort modes, exception made for the upper threshold of the message size that can be sent in these two modes, as explained at the beginning of this section. Memory breakdown To get a better insight on the type of memory consumed by these applications, below we provide the same data but broken down into its constituent memory chunks. We do so for just one message size (1 B), since, as we have seen, this number doesn’t affect the total memory consumed (nor its constituents).   Fig 4: Static, stack and dynamic memory usage (in Bytes) of micro-ROS publisher and subscription applications in both Best-Effort and Reliable modes with UDP transport, default parameters and fixed message size as a function of the entities number. From these results we see that both the static and the dynamic memories change with the entity number, while the stack stays constant. Role of the RMW history In this scenario, we have measured the static memory consumed as a function of the RMW history, when this ranges from 1 to 20 units, for a single subscriber application and with a message of fixed size (again, as seen above this size doesn’t affect the memory consumption as long as it’s smaller than the pre-allocated buffer size), with UDP transport and an XRCE-DDS history of 4, using Reliable communication. The results are summarized in the plot below:   Fig 5: Static memory usage (in Bytes) of a micro-ROS subscription application in reliable mode with UDP transport, default parameters and fixed message size as a function of the RMW history. From this plot, we see that the total static memory used changes by MTU × RMW_history (which is equal to 512 × 4 for the parameters employed) for each unit of RMW memory that we add to the application. Client-Server apps: We now pass to investigate our last case-scenario, where in spite of pub/sub apps, we consider a different kind of ROS object, that of services, in which the communication between entities follow a request/reply pattern. See below the results for the memory consumed, for a number of servers and clients ranging from 1 to 10. Notice that we report both the behaviour and values of the individual consituents (static, stack, and dynamic) and of the total memory.   Fig 6: Total memory usage (in Bytes) of micro-ROS service and clients applications as a function of the number of servers and clients. As already done in the case of publishers and subscribers, we can calculate the total memory consumed by a single entity. From this calculation it results that the memory occupied by one server or one client is on the order of ~ 300 B. From this figure, we see that the memory occupied by a server and that occupied by a client is virtually identical, and it is on the same order of magnitude as that occupied by a publisher or subscriber application. Conclusions: To sum up, we have seen that:  Memory consumption doesn’t vary with message size as long as the sum of the latter plus the overheads can be accommodated by the static buffer pre-allocated at compile-time.  Static and Dynamic memories vary with the entity number, while the stack remains constant.  A single publisher/subscriber app with default configuration parameters and with UDP transport consumes ~ 400-500 B of total memory.  A single client/server app with default configuration parameters and with UDP transport consumes ~ 300 B of total memory, on the same order of magnitude of pub/sub applications.  In the case of a single subscription, the total static memory used changes by MTU × XRCE_history for each unit of RMW history that is added to the application. "
        }, {
        "id": 91,
        "url": "https://micro-ros.github.io//docs/concepts/benchmarking/results/",
        "title": "Results",
        "body": " - Table of contents:  From tracing to benchmarking Communication results Real-time results Executions Function call statistics Static memory usage Dynamic memory usage Power consumptionFrom tracing to benchmarking: The low-level RTOS (NuttX) was instrumented in a specific way that provides different categories of benchmarking measurements (memory, execution, etc…). The gathered data is following the Common Trace Format. The raw trace is later processed using the Babeltrace API trace manipulation toolkit. The data interpretation is up to the user. More information about benchmarks results and methodologies are dealt with within the following document The results, on which the interpretation are done, are available in the benchmarking_results repository. General methodology: Depending on what type of communication medium micro-ROS is set up with, the methodology may vary. Of course, the variations are small and related to the transport protocol. In order to achieve benchmarking, the RTOS and the application were instrumented. Depending on the target assessment, different probes were placed in different parts of the RTOS. The data format follows a standard called Common Trace Format (V1. 8). This standard is also used in Zephyr, one of the RTOSes supported by the micro-ROS project together with NuttX. As a matter of fact, the CTF core was ported from Zephyr to NuttX. Data are retrieved and analysed with babeltrace and the babeltrace python API. All events are timed using an internal free-running timer (in the case of NuttX running on the Olimex STM32-E407 TIM2). Thanks to this the device can have timer clock offering a resolution of nearly 10 nanoseconds. The current configuration of the resolution is 100 nanoseconds, which is more than enough to assess communication perforances, considering that the minimal Ethernet (64bytes) frame at 100Mbps. Each measurement is timestamped using the free-running timer mentionned earlier. The software configuration is likely to change. However the software role will be kept the same:  Agent running on a PC Subscriber running on one Olimex STM32-E407, Publisher running on one Olimex STM32-E407. At a hardware level the USB - CDC/ACM console is going to be used on the Olimex STM32-E407 boards for Ethernet and Serial benchmarkings. For 6LoWPAN the serial USART6 will be used as the console to reduce the memory footprint and execution impact. Hence the USB OTG1 of both Olimex STM32-E407 boards shall be connected to a computer. Additional hardware setup must performed but will depend on the type of topology (Ethernet / Serial / 6LoWPAN): The results shown below are the fruit of a same application: The publisher. Only the micro-ROS related functions were benchmarked. Hence, all the serial/IP/radio configuration parts of the code won’t be taken into account. Below the data processing is described. From the serialised binary CTF data to the output from the Babeltrace API: Communication results: Following is the communication bitrate RX/TX: Observations: According to the data, the Ethernet performs the best, which is expected. Real-time results: Below we report the execution benchmarking The data extracted from the Babeltrace show the following about the NuttX scheduler. The additional information are:  The thread_id 0 is the idle thread The thread_id 3 is the low priority work queue (RTOS kthread), The thread_id 7 is the publisher. [01:00:21. 445833238] (+0. 000009524) 0 thread_resume: { thread_id = 7 }[01:00:21. 445993047] (+0. 000159809) 0 thread_suspend: { thread_id = 7 }[01:00:21. 446002761] (+0. 000009714) 0 thread_resume: { thread_id = 3 }[01:00:21. 446051904] (+0. 000049143) 0 thread_suspend: { thread_id = 3 }[01:00:21. 446061428] (+0. 000009524) 0 thread_resume: { thread_id = 0 }[01:00:21. 446085428] (+0. 000024000) 0 thread_suspend: { thread_id = 0 }[01:00:21. 446095428] (+0. 000010000) 0 thread_resume: { thread_id = 3 }[01:00:21. 446133047] (+0. 000037619) 0 thread_suspend: { thread_id = 3 }[01:00:21. 446142571] (+0. 000009524) 0 thread_resume: { thread_id = 0 }[01:00:21. 446273523] (+0. 000130952) 0 thread_suspend: { thread_id = 0 }[01:00:21. 446283523] (+0. 000010000) 0 thread_resume: { thread_id = 3 }[01:00:21. 446335809] (+0. 000052286) 0 thread_suspend: { thread_id = 3 }[01:00:21. 446345333] (+0. 000009524) 0 thread_resume: { thread_id = 7 }[01:00:21. 446505333] (+0. 000160000) 0 thread_suspend: { thread_id = 7 }[01:00:21. 446514952] (+0. 000009619) 0 thread_resume: { thread_id = 3 }[01:00:21. 446564190] (+0. 000049238) 0 thread_suspend: { thread_id = 3 }[01:00:21. 446573714] (+0. 000009524) 0 thread_resume: { thread_id = 0 }[01:00:21. 446597714] (+0. 000024000) 0 thread_suspend: { thread_id = 0 }[01:00:21. 446607714] (+0. 000010000) 0 thread_resume: { thread_id = 3 }[01:00:21. 446645333] (+0. 000037619) 0 thread_suspend: { thread_id = 3 }[01:00:21. 446654857] (+0. 000009524) 0 thread_resume: { thread_id = 0 }[01:00:21. 446779047] (+0. 000124190) 0 thread_suspend: { thread_id = 0 }[01:00:21. 446789142] (+0. 000010095) 0 thread_resume: { thread_id = 3 }[01:00:21. 446841333] (+0. 000052191) 0 thread_suspend: { thread_id = 3 }[01:00:21. 446850857] (+0. 000009524) 0 thread_resume: { thread_id = 7 }[01:00:21. 447010571] (+0. 000159714) 0 thread_suspend: { thread_id = 7 }[01:00:21. 447020285] (+0. 000009714) 0 thread_resume: { thread_id = 3 }Observations: According to the results reported above, the software is running a deterministic way. Indeed, by looking closer, it is noticeable that the running sequence is the same. Additionally, timing deltas between correlated events have a really low variation when switching between events (consecutive thread_suspend/thread_resume). Moreover, the scheduler performs fast context switches, which on average, last 10 microseconds. Executions: Following is depicted the execution benchmarking. The amount of time spend on the CPU split into two parts (I/O operations, Subscriber operations): Observations:  According to the data, most of the time was spent during I/O operations. Function call statistics: Below are reported the function calls count per each communication medium: Ethernet Serial 6LoWPAN Static memory usage: Below is the representation of the static memory analysis: Observations: The 6LoWPAN is the medium consuming most of the static memory as this protocol is running on top of IP version 6. Dynamic memory usage: The graphic below is showing the total number dynamic allocations. Each bin is split into group of chunk memory blocks. In each group lies different chunk sizes. The size of each group are comprise between a minimum size, which is the size of the previous group. And a maximum size, which is the size display in the legend. For instance a block with the legend colored yellow represents all block that are greater than the previous group of chunk memory, here 16 bytes. But that the are lower or equal to 32 bytes.  Observations: Independently from the communication mediums, blocks allocated are not huge and not numerous. The most of the allocations are happening during initialisation. Power consumption: Below is depicted energy consumption categorised by communication medium below: Observations: The communication medium has a high impact on the throughput, which in turn has an impact on the power consumption. The Ethernet provides a high throughput, but at the price of a higher power consumption. In comparison, the serial communciation medium provides a low bitrate with the advantage to consuming a lot less energy. "
        }, {
        "id": 92,
        "url": "https://micro-ros.github.io//docs/concepts/build_system/external_build_systems/",
        "title": "External Build Systems",
        "body": " - Once you have read about the official micro_ros_setup tool, this page will present some other approaches for building micro-ROS as a module or component integrated into other build systems. micro-ROS component for ESP-IDF: The micro-ROS component for ESP-IDF allows to integrate micro-ROS as a component in an Espressif ESP-IDF Build System. This component allows the user to integrate the micro-ROS API and utilities in an already created ESP-IDF project just by cloning or copying a folder. Configuration of the micro-ROS library is based on the colcon. meta file. For more details visit the Git repository. micro-ROS module for Zephyr: The micro-ROS module for Zephyr allows to integrate micro-ROS as a module in a Zephyr-based project. In detail, it enables to integrate the micro-ROS API and utilities in an existing Zephyr project just by cloning or copying a folder. The procedure for configuring the built micro-ROS library is based in colcon. meta. For more details visit the Git repository. micro-ROS for Arduino: The micro-ROS for Arduino support package is a special port of micro-ROS provided as a set of precompiled libraries for specific platforms. The main reason for this approach is that Arduino does not allow the build of a complex library such as micro-ROS, so by using this approach a ready-to-use solution is provided to the Arduino users. Along with this support package, there are detailed instructions for rebuilding the micro-ROS for Arduino libraries for users that need to tune the default configuration. micro-ROS for STM32CubeMX: The micro-ROS for STM32CubeMX package is a set of utilities which enables the seamless configuration, set-up and integration of micro-ROS into an STM32 controller based project. As such, it allows micro-ROS to be virtually supported by the full set of boards offered by STMicroelectronics. Its usage is based on Dockers, via a prepared Dockerfile which eases micro-ROS library generation outside of a ROS 2 environment. "
        }, {
        "id": 93,
        "url": "https://micro-ros.github.io//docs/concepts/build_system/",
        "title": "micro-ROS Build System",
        "body": " - micro-ROS provides two ways of building a micro-ROS application for embedded platforms:  micro_ros_setup: integrates and hides the RTOS-specific build tools in few scripts provided as a ROS 2 package.  Platform-specific integrations: We have integrated micro-ROS with several platforms build tools. Click here to learn more. micro_ros_setup provides a standalone build system in the form of a ROS 2 package for use in any normal ROS 2 workspace. This tool is available in the micro-ROS/micro_ros_setup repository. The micro_ros_setup tool allows compiling and generating images that contain micro-ROS apps for the supported hardware boards and RTOSes. As the micro_ros_setup package can be installed like any other ROS 2 package, its usage will be through the ROS 2 CLI tool. Compiling, generating an image and flashing it on a board can be done just with four ROS 2 commands. A detailed description about the usage of this package can be found in the tutorial section. micro-ROS client: Once installed, the build system tool provides some utilities that can be used in order to prepare, build, flash and use a micro-ROS application. The micro-ROS build system is a four-step procedure. In the first step, the user can create a new micro-ROS application by configuring the target hardware and RTOS: # Create stepros2 run micro_ros_setup create_firmware_ws. sh [RTOS] [HARDWARE BOARD]It is possible to obtain a list of the supported hardware by running the command without any argument. By doing so, it is possible to see that along with the RTOSes and hardware supported by micro-ROS this build system also provides with three extra options:  By using zephyr as RTOS and host as hardware name, it is possible to obtain a Zephyr RTOS image with your micro-ROS app that runs in your host computer.  By using just host as RTOS, micro-ROS will build a set of micro-ROS demo applications natively in your host machine. These applications behave just like micro-ROS apps (using the same abstraction layers and middleware implementation) and allow the user to debug and test the applications on a PC.  By using generate_lib as RTOS it is possible to configure the build system for generating static libraries (. a) and a set of headers (include) that can be linked in any other external tool. This option requires a valid CMake toolchain. Once the build system has created the new firmware project, it is possible to configure it using: # Configure stepros2 run micro_ros_setup configure_firmware. sh [APP] [OPTIONS]By running this command without any argument, it will output a list of example applications valid for the selected RTOS. Common options available at this configuration step are:  --transport or -t: udp, serial or any hardware specific transport label --dev or -d: agent string descriptor in a serial-like transport --ip or -i: agent IP in a network-like transport --port or -p: agent port in a network-like transportFinally, it is possible to build and flash a micro-ROS app using: # Build stepros2 run micro_ros_setup build_firmware. sh# Flash stepros2 run micro_ros_setup flash_firmware. shmicro-ROS agent: The micro-ROS build system is also able to ease the compilation of the micro-ROS Agent in a ROS 2 workspace by using these commands: # Download micro-ROS-Agent packagesros2 run micro_ros_setup create_agent_ws. shros2 run micro_ros_setup build_agent. shsource install/local_setup. bashros2 run micro_ros_agent micro_ros_agent [OPTIONS]Tip 1: To learn use of the micro_ros_setup build system hands-on, please see the core tutorials. Tip 2 : Remember that the micro-ROS Agent can be also be used with this simple Docker command: docker run -it --rm -v /dev:/dev --privileged --net=host microros/micro-ros-agent:$ROS_DISTRO [OPTIONS] "
        }, {
        "id": 94,
        "url": "https://micro-ros.github.io//docs/concepts/client_library/diagnostics/",
        "title": "Diagnostics",
        "body": " - Although diagnostics is not part of the ROS 2 Client Library packages (i. e. , rclcpp, rclpy), it definitely can be counted to the extended client library as it provides very generic and application-independent functionalities. That’s why the micro-ROS Client Library comes with basic diagnostics functionalities. These are compatible with ROS 2 diagnostics and comprise three features only:  Diagnostic message types (optimized for Micro-XRCE-DDS - no dynamic arrays) Updater mechanisms for rclc Selected basic diagnostic monitors for microcontrollersThe micro-ROS diagnostics packages do not provide any aggregator as we assume that such aggregation takes place on a microprocessor running standard ROS 2. Hence, we assume the following typical architecture: In order for the standard ROS 2 diagnostic aggregator to aggregate micro-ROS diagnostic message types, the ROS 2 agent has to translate micro-ROS diagnostic messages to standard ROS 2 diagnostic messages (tbd). For more information, please see https://github. com/micro-ROS/micro_ros_diagnostics/. For further information on ROS 2 diagnostics, see ROS 2 diagnostics and ROS 2 diagnostic_msgs. "
        }, {
        "id": 95,
        "url": "https://micro-ros.github.io//docs/concepts/client_library/embedded_tf/",
        "title": "Embedded Transform (TF)",
        "body": " - Introduction and Goal: The TF transform graph, with its support for both a temporal history, and distributed information sources, has been a novel tool for robotics frameworks when it was released in 2008. Functionally, it is based in scene graph concepts known from computer graphics [Foote 2013], but these only rarely offer distribution, and did not offer temporal histories at all (mainly, because this is not needed for frame-based rendering applications like in computer graphics). Distributed scene graphs have become more widely available also in computer graphics. In robotics, work by de Laet et al. [De Laet et al. 2013] has extended transforms graphs to also contain twist (i. e. , angular motion) information, and to provide more compile-time error checking. This is currently not integrated with distribution mechanisms, but could be used on a single system. One persistent issue with transform graphs has been their resource use. ROS TF works through replicated copies of the entire transform tree at every node that uses it, and is implemented through unicast TCP connections between nodes. In systems with many dynamic parts, this has sometimes been called the TF firehose, because of the large stream of incoming messages. micro-ROS will go beyond this state of the art by running the dynamic transform tree in an embedded device, while keeping resource use to a minimum based on an analysis of the spatial and temporal details actually necessary. Further, enabling real-time queries even in the face of concurrent updates through integration will be realized through integration with the micro-ROS real-time executor. It is also planned to integrate the embedded TF will with the node lifecycle to achieve further power-savings Roadmap: This task has been cancelled as discussed in the EU project review in September 2019. Acknowledgments: This activity has received funding from the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (grant agreement n° 780785). "
        }, {
        "id": 96,
        "url": "https://micro-ros.github.io//docs/concepts/client_library/execution_management/",
        "title": "Execution Management",
        "body": " - Table of contents:    Introduction   Analysis of rclcpp standard Executor     Architecture   Scheduling Semantics    RCLC-Executor     Requirement Analysis   Features   Executor API   Examples   Download    Callback-group-level Executor     API Changes   Test Bench    Related Work References AcknowledgmentsIntroduction: Predictable execution under given real-time constraints is a crucial requirement for many robotic applications. While the service-based paradigm of ROS allows a fast integration of many different functionalities, it does not provide sufficient control over the execution management. For example, there are no mechanisms to enforce a certain execution order of callbacks within a node. Also the execution order of multiple nodes is essential for control applications in mobile robotics. Cause-effect-chains comprising of sensor acquisition, evaluation of data and actuation control should be mapped to ROS nodes executed in this order, however there are no explicit mechanisms to enforce it. Furthermore, when input data is collected in field tests, saved with ROS-bags and re-played, often results are different due to non-determinism of process scheduling. Manually setting up a particular execution order of subscribing and publishing topics in the callbacks or by tweaking the priorities of the corresponding Linux processes is always possible. However, this approach is error-prone, difficult to extend and requires an in-depth knowledge of the deplyed ROS 2 packages in the system. Therefore the goal of the Real-Time Executor is to support roboticists with practical and easy-to-use real-time mechanisms which provide solutions for:  Deterministic execution Real-time guarantees Integration of real-time and non real-time functionalities on one platform Specific support for RTOS and microcontrollersIn ROS 1 a network thread is responsible for receiving all messages and putting them into a FIFO queue (in roscpp). That is, all callbacks were called in a FIFO manner, without any execution management. With the introduction of DDS (data distribution service) in ROS 2, the messages are buffered in DDS. In ROS 2, an Executor concept was introduced to support execution management, like priorization. At the rcl-layer, a wait-set is configured with handles to be received and in a second step, the handles are taken from the DDS-queue. A handle is a term defined in rcl-layer and summarizes timers, subscriptions, clients and services etc. . The standard implementation of the ROS 2 Executor for the C++ API (rclcpp) has, however, certain unusual features, like precedence of timers over all other DDS handles, non-preemptive round-robin scheduling for non-timer handles and considering only one input data for each handle (even if multiple could be available). These features have the consequence, that in certain situations the standard rclcpp Executor is not deterministic and it makes proving real-time guarantees hard. We have not looked at the ROS 2 Executor implementation for Python frontend (rclpy) because we consider a micro-controllers platform, on which typically C or C++ appliations will run. Given the goals for a Real-Time Executor and the limitations of the ROS 2 standard rclcpp Executor, the challenges are:  to develop an adequate and well-defined scheduling mechanisms for the ROS 2 framework and the real-time operating system (RTOS) to define an easy-to-use interface for ROS-developers to model requirements (like latencies, determinism in subsystems) mapping of ROS framework and OS scheduler (semi-automated and optimized mapping is desired as well as generic, well-understood framework mechanisms)Our approach is to provide Real-Time Executors on two layers as described in section Introduction to Client Library. One based on the rcl-layer written in C programming language and one based on rclcpp written in C++. As the first step, we propose the LET-Executor for the rcl-layer in C, which implements static order scheduling policy with logic execution time semantics. In this scheduling policy, all callbacks are executed in a pre-defined order. Logical execution time refers to the concept, that first input data is read before tasks are executed.  Secondly, we developed a Callback-group-level Executor, which allows to prioritize a group of callbacks. These approaches are based on the concept of Executors, which have been introduced in ROS 2. In the future, we plan to provide other Real-Time Executors for the rcl- and rclcpp-layer. Analysis of rclcpp standard Executor: ROS 2 allows to bundle multiple nodes in one operating system process. To coordinate the execution of the callbacks of the nodes of a process, the Executor concept was introduced in rclcpp (and also in rclpy). The ROS 2 design defines one Executor (instance of rclcpp::executor::Executor) per process, which is typically created either in a custom main function or by the launch system. The Executor coordinates the execution of all callbacks issued by these nodes by checking for available work (timers, services, messages, subscriptions, etc. ) from the DDS queue and dispatching it to one or more threads, implemented in SingleThreadedExecutor and MultiThreadedExecutor, respectively. The dispatching mechanism resembles the ROS 1 spin thread behavior: the Executor looks up the wait sets, which notifies it of any pending callback in the DDS queue. If there are multiple pending callbacks, the ROS 2 Executor executes them in an in the order as they were registered at the Executor. Architecture: The following diagram depicts the relevant classes of the standard ROS 2 Executor implementation: Note that an Executor instance maintains weak pointers to the NodeBaseInterfaces of the nodes only. Therefore, nodes can be destroyed safely, without notifying the Executor. Also, the Executor does not maintain an explicit callback queue, but relies on the queue mechanism of the underlying DDS implementation as illustrated in the following sequence diagram: The Executor concept, however, does not provide means for prioritization or categorization of the incoming callback calls. Moreover, it does not leverage the real-time characteristics of the underlying operating-system scheduler to have finer control on the order of executions. The overall implication of this behavior is that time-critical callbacks could suffer possible deadline misses and a degraded performance since they are serviced later than non-critical callbacks. Additionally, due to the FIFO mechanism, it is difficult to determine usable bounds on the worst-case latency that each callback execution may incur. Scheduling Semantics: In a recent paper CB2019, the rclcpp Executor has been analyzed in detail and a response time analysis of cause-effect chains has been proposed under reservation-based scheduling. The Executor distinguishes four categories of callbacks: timers, which are triggered by system-level timers, subscribers, which are triggered by new messages on a subscribed topic, services, which are triggered by service requests, and clients, which are triggered by responses to service requests. The Executor is responsible for taking messages from the input queues of the DDS layer and executing the corresponding callback. Since it executes callbacks to completion, it is a non-preemptive scheduler, However it does not consider all ready tasks for execution, but only a snapshot, called readySet. This readySet is updated when the Executor is idle and in this step it interacts with the DDS layer updating the set of ready tasks. Then for every type of task, there are dedicated queues (timers, subscriptions, services, clients) which are processed sequentially. The following undesired properties were pointed out:  Timers have the highest priority. The Executor processes timers always first.  This can lead to the intrinsic effect, that in overload situations messages from the DDS queue are not processed.  Non-preemptive round-robin scheduling of non-timer handles. Messages arriving during the processing of the readySet are not considered until the next update, which depends on the execution time of all remaining callbacks. This leads to priority inversion, as lower-priority callbacks may implicitly block higher-priority callbacks by prolonging the current processing of the readySet.  Only one message per handle is considered. The readySet contains only one task instance, For example, even if multiple messages of the same topic are available, only one instance is processed until the Executor is idle again and the readySet is updated from the DDS layer. This aggravates priority inversion, as a backlogged callback might have to wait for multiple processing of readySets until it is considered for scheduling. This means that non-timer callback instances might be blocked by multiple instances of the same lower-priority callback. Due to these findings, the authors present an alternative approach to provide determinism and to apply well-known schedulability analyses to a ROS 2 systems. A response time analysis is described under reservation-based scheduling. RCLC-Executor: Here we introduce the rclc Executor, which is a ROS 2 Executor implemented based on and for the rcl API, for applications written in the C language. Often embedded applications require real-time to guarantee end-to-end latencies and need deterministic runtime behavior to correctly replay test data. However, this is difficult with the default ROS 2 Executor because of its complex semantics, as discussed in the previous section. First, we will analyse the requirements for such applications and, secondly, derive simple features for an Executor to enable deterministic and real-time behavior. Then we will present the API of the RCLC-Executor and provide example usages of the RCLC-Executor to address these requirements. Requirement Analysis: First we discuss a use-case in the embedded domain, in which the time-triggered paradigm is often used to guarantee deterministic and real-time behavior. Then we analyse software design patterns in mobile robotics which enable deterministic behavior. Real-time embedded application used-case: In embedded systems, real-time behavior is approached by using the time-triggered paradigm, which means that the processes are periodically activated. Processes can be assigned priorities to allow pre-emptions. Figure 1 shows an example, in which three processes with fixed periods are shown. The middle and lower process are preempted multiple times depicted with empty dashed boxes.  Figure 1: Fixed periodic preemptive scheduling To each process one or multiple tasks can be assigned, as shown in Figure 2. These tasks are executed sequentially, which is often called cooperative scheduling.  Figure 2: Processes with sequentially executed tasks. While there are different ways to assign priorities to a given number of processes,the rate-monotonic scheduling assignment, in which processes with a shorter period have a higher priority, has been shown optimal if the processor utilization is less than 69% LL1973. In the last decades many different scheduling approaches have been presented, however fixed-periodic preemptive scheduling is still widely used in embedded real-time systems KZH2015. This becomes also obvious, when looking at the features of current operating systems. Like Linux, real-time operating systems, such as NuttX, Zephyr, FreeRTOS, QNX etc. , support fixed-periodic preemptive scheduling and the assignment of priorities, which makes the time-triggered paradigm the dominant design principle in this domain. However, data consistency is often an issue when preemptive scheduling is used and if data is being shared across multiple processes via global variables. Due to scheduling effects and varying execution times of processes, writing and reading these variables could occur sometimes sooner or later. This results in an latency jitter of update times (the timepoint at which a variable change becomes visible to other processes). Race conditions can occur when multiple processes access a variable at the same time. So solve this problem, the concept of logical-execution time (LET) was introduced in HHK2001, in which communication of data occurs only at pre-defined periodic time instances: Reading data only at the beginning of the period and writing data only at the end of the period. The cost of an additional latency delay is traded for data consistency and reduced jitter. This concept has also recently been applied to automotive applications NSP2018.  Figure 3: Data communication without and with Logical Execution Time paradigm. An Example of the LET concept is shown in Figure 3. Assume that two processes are communicating data via one global variable. The timepoint when this data is written is at the end of the processing time. In the default case (left side), the process p3 and p4 receive the update. At the right side of the figure, the same scenario is shown with LET semantics. Here, the data is communicated only at period boundaries. In this case, the lower process communicates at the end of the period, so that always process p3 and p5 receive the new data. The described embedded use case relies on the following concepts:  periodic execution of processes assignment of fixed priorities to processes preemptive scheduling of processes co-operative scheduling of tasks within a process (sequential execution) data synchronization with LET-semanticsWhile periodic activation is possible in ROS2 by using timers, preemptive scheduling is supported by the operating system and assigning priorities on the granularity of threads/processes that correspond to the ROS nodes; it is not possible to sequentially execute callbacks, which have no data-dependency. Furthermore data is read from the DDS queue just before the callback is executed and data is written sometime during the time the application is executed. While the spin_period function of the rclcpp-Executor allows to check for data at a fixed period and executing those callbacks for which data is available, however, with this spin-function does not execute all callbacks irrespective wheter data is available or not. So spin_period is not helpful to periodically execute a number of callbacks (aka tasks within a process). So we need a mechanism that triggers the execution of multiple callbacks (aka tasks) based on a timer. Data transmission is achieved via DDS which does not allow to implement a LET-semantics. To summarize, we derive the following requirements: Derived Requirements:  trigger the execution of multiple callbacks sequential processing of callbacks data synchronization with LET semanticsSense-plan-act pipeline in robotics: Now we describe common software design patterns which are used in mobile robotics to achieve deterministic behavior. For each design pattern we describe the concept and the derived requirements for a deterministic Executor. Concept: A common design paradigm in mobile robotics is a control loop, consisting of several phases: A sensing phase to aquire sensor data, a plan phase for localization and path planning and an actuation-phase to steer the mobile robot. Of course, more phases are possible, here these three phases shall serve as an example. Such a processing pipeline is shown in Figure 4.  Figure 4: Multiple sensors driving a Sense-Plan-Act pipeline. Typically multiple sensors are used to perceive the environment. For example an IMU and a laser scanner. The quality of localization algorithms highly depend on how old such sensor data is when it is processed. Ideally the latest data of all sensors should be processed. One way to achive this is to execute first all sensor drivers in the sense-phase and then process all algorithms in the plan-phase. Currently, such a processing order cannot be defined with the default ROS2-Executor. One could in principle design a data-driven pipeline, however if e. g. the Laser scan is needed by some other callback in the sense-phase as well as in the plan-phase, the processing order of these subscribers is arbitrary. For this sense-plan-act pattern, we could define one executor for each phase. The plan-phase would be triggered only when all callbacks in the sense-phase have finished. Derived Requirements:  triggered execution of callbacksSynchronization of multiple rates: Concept: Often multiple sensors are being used to sense the environment for mobile robotics. While an IMU sensor provides data samples at a very high rate (e. g. , 500 Hz), laser scans are availabe at a much slower frequency (e. g. 10Hz) determined by the revolution time. Then the challenge is, how to deterministically fuse sensor data with different frequencies. This problem is depicted in Figure 5.  Figure 5: How to deterministically process multi-frequent sensor data. Due to scheduling effects, the callback for evaluating the laser scan might be called just before or just after an IMU data is received. One way to tackle this is to write additional synchronization code inside the application. Obviously, this is a cumbersome and not-portable solution. An Alternative would be to evalute the IMU sample and the laser scan by synchronizing their frequency. For example by processing always 50 IMU samples with one laser scan. This approach is shown in Figure 6. A pre-processing callback aggregates the IMU samples and sends an aggregated message with 50 samples at 10Hz rate. Now both messages have the same frequency. With a trigger condition, which fires when both messages are available, the sensor fusion algorithm can expect always synchronized input data.  Figure 6: Synchronization of multiple input data with a trigger. In ROS 2, this is currently not possible to be modeled because of the lack of a trigger concept in the ROS2 Executor. Message filters could be used to synchronize input data based on the timestamp in the header, but this is only available in rclcpp (and not in rcl). Further more, it would be more efficient to have such a trigger concept directly in the Executor. Another idea would be to activly request for IMU data only when a laser scan is received. This concept is shown in Figure 7. Upon arrival of a laser scan mesage, first, a message with aggregated IMU samples is requested. Then, the laser scan is processed and later the sensor fusion algorithm. An Executor, which would support sequential execution of callbacks, could realize this idea.  Figure 7: Synchronization with sequential processing. Derived Requirements from both concepts:  triggered execution sequential procesing of callbacksHigh-priority processing path: Motivation: Often a robot has to fullfill several activities at the same time. For example following a path and avoiding obstacles. While path following is a permanent activity, obstacle avoidance is trigged by the environment and should be immediately reacted upon. Therefore one would like to specify priorities to activities. This is depicted in Figure 8: Figure 8: Managing high priority path with sequential order. Assuming a simplified control loop with the activities sense-plan-act, the obstacle avoidance, which might temporarily stop the robot, should be processed before the planning phase. In this example we assume that these activites are processed in one thread. Derived requirements:  sequential processing of callbacksFeatures: Based on the real-time embedded use-case as well as the software architecture patterns in mobile robotics, we propose an Executor with the following main features:  user-defined sequential execution of callbacks trigger condition to activate processing data synchronization: LET-semantics or rclcpp Executor semanticsAs stated before, this Executor is based on the RCL library and is written in C to nativly support microcontroller applications written in C. These features are now described in more detail. The rclc-Executor supports all event types like the ROS 2 rclc executor, which are:  subscription timer service client guard conditionSequential execution:  At configuration, the user defines the order of handles.  At configuration, the user defines whether the handle shall be called only when new data is available (ON_NEW_DATA) or whether the callback shall always be called (ALWAYS).  At runtime, all handles are processed in the user-defined order     if the configuration of handle is ON_NEW_DATA, then the corresponding callback is only called if new data is available   if the configuration of the handle is ALWAYS, then the corresponding callback is always. If no data is available, then the callback is called with no data (e. g. NULL pointer).    Trigger condition:    Given a set of handles, a trigger condition based on the input data of these handles shall decide when the processing is started.     Available options:      ALL operation: fires when input data is available for all handles   ANY operation: fires when input data is available for at least one handle   ONE: fires when input data for a user-specified handle is available   User-defined function: user can implement more sophisticated logic   LET-Semantics:  Assumption: time-triggered system, the executor is activated periodically When the trigger fires, reads all input data and makes a local copy Processes all callbacks in sequential order Write output data at the end of the executor’s period (Note: this is not implemented yet)Additionally we have implemented the current rclcpp Executor semantics (“RCLCPP”):  waiting for new data for all handles (rcl_wait) using trigger condition ANY if trigger fires, start processing handles in pre-defined sequential order request from DDS-queue the new data just before the handle is executed (rcl_take)The selection of the Executor semantics is optional. The default semantics is “RCLCPP”. Executor API: The API of the RCLC-Executor can be divided in two phases: Configuration and Running. Configuration phase: During the configuration phase, the user shall define:  the total number of callbacks the sequence of the callbacks trigger condition (optional, default: ANY) data communcation semantics (optional, default ROS2)As the Executor is intended for embedded controllers, dynamic memory management is crucial. Therefore at initialization of the RCLC-Executor, the user defines the total number of callbacks. The necessary dynamic memory will be allocated only in this phase and no more memory in the running phase. This makes this Executor static in the sense, that during runtime no additional callbacks can be added. Then, the user adds handles and the corresponding callbacks (e. g. for subscriptions and timers) to the Executor. The order in which this takes place, defines later the sequential processing order during runtime. For each handle the user can specify, if the callback shall be executed only if new data is available (ON_NEW_DATA) or if the callback shall always be executed (ALWAYS). The second option is useful when the callback is expected to be called at a fixed rate. The trigger condition defines when the processing of these callbacks shall start. For convenience some default conditions have been defined:  trigger_any(default) : start executing if any callback has new data trigger_all : start executing if all callbacks have new data trigger_one(&amp;data) : start executing if data has been received user_defined_function: the user can also define its own function with more complex logicWith ‘trigger_any’ being the default, the current semantics of the rclcpp Executor is selected. The data communication semantics can be  ROS2 (default) LETTo be compatible with ROS2 rclcpp Executor, the existing rclcpp semantics is implemented as ‘ROS2’. That is, with the spin-function the DDS-queue is constantly monitored for new data (rcl_wait). If new data becomes available, then is fetched from DDS (rcl_take) immediately before the callback is executed. All callbacks are processed in the user-defined order, this is the only difference to the rclcpp Executor, in which no order can be specified. Secondly, the LET semantics is implemented such that at the beginning of processing all available data is fetched (rcl_take) and buffered and then the callbacks are processed in the pre-defined operating on the buffered copy. Running phase: As the main functionality, the Executor has a spin-function which constantly checks for new data at the DDS-queue, like the rclcpp Executor in ROS2. If the trigger condition is satisfied then all available data from the DDS queue is processed according to the specified semantics (ROS or LET) in the user-defined sequential order. After all callbacks have been processed the DDS is checked for new data again. Available spin functions are  spin_some - spin one time spin_period - spin with a period spin - spin indefinitlyExamples: We provide the relevant code snippets how to setup the RCLC-Executor for the embedded use case and for the software design patterns in mobile robotics applications as described above. Embedded use-case: With seqential execution the co-operative scheduling of tasks within a process can be modeled. The trigger condition is used to periodically activate the process which will then execute all callbacks in a pre-defined order. Data will be communicated using the LET-semantics. Every Executor is executed in its own tread, to which an appropriate priority can be assigned. In the following example, the Executor is setup with 4 handles. We assume a process has three subscriptions sub1, sub2, sub3. The sequential processing order is given by the order as they are added to the Executor. A timer timer defines the period.  The trigger_one with the paramter timer is used, so that whenever the timer is ready, all callbacks are processed. Finally the data communication semantics LET is defined. #include  rcl_executor/let_executor. h // define subscription callbackvoid my_sub_cb1(const void * msgin){ // . . . }// define subscription callbackvoid my_sub_cb2(const void * msgin){ // . . . }// define subscription callbackvoid my_sub_cb3(const void * msgin){ // . . . }// define timer callbackvoid my_timer_cb(rcl_timer_t * timer, int64_t last_call_time){ // . . . }// necessary ROS 2 objectsrcl_context_t context;  rcl_node_t node;rcl_subscription_t sub1, sub2, sub3;rcl_timer_t timer;rcle_let_executor_t exe;// define ROS contextcontext = rcl_get_zero_initialized_context();// initialize ROS nodercl_node_init(&amp;node, &amp;context,. . . );// create subscriptionsrcl_subscription_init(&amp;sub1, &amp;node, . . . );rcl_subscription_init(&amp;sub2, &amp;node, . . . );rcl_subscription_init(&amp;sub3, &amp;node, . . . );// create a timerrcl_timer_init(&amp;timer, &amp;my_timer_cb, . . . );// initialize executor with four handlesrclc_executor_init(&amp;exe, &amp;context, 4, . . . );// define static execution order of handlesrclc_executor_add_subscription(&amp;exe, &amp;sub1, &amp;my_sub_cb1, ALWAYS);rclc_executor_add_subscription(&amp;exe, &amp;sub2, &amp;my_sub_cb2, ALWAYS);rclc_executor_add_subscription(&amp;exe, &amp;sub3, &amp;my_sub_cb3, ALWAYS);rclc_executor_add_timer(&amp;exe, &amp;timer);// trigger when handle 'timer' is readyrclc_executor_set_trigger(&amp;exe, rclc_executor_trigger_one, &amp;timer);// select LET-semanticsrclc_executor_data_comm_semantics(&amp;exe, LET);// spin foreverrclc_executor_spin(&amp;exe);Sense-plan-act pipeline: In this example we want to realise a sense-plan-act pipeline in a single thread. The trigger condition is demonstrated by activatingthe sense-phase when both data for the Laser and IMU are available. Three executors are necessary exe_sense, exe_plan and exe_act. The two sensor acquisition callbacks sense_Laser and sense_IMU are registered in the Executor exe_sense. The trigger condition ALL is responsible to activate the sense-phase only when all data for these two callbacks are available. Finally all three Executors are spinning using a while-loop and the spin_some function. The definitions of callbacks are omitted. . . . rcl_subscription_t sense_Laser, sense_IMU, plan, act;rcle_let_executor_t exe_sense, exe_plan, exe_act;// initialize executorsrclc_executor_init(&amp;exe_sense, &amp;context, 2, . . . );rclc_executor_init(&amp;exe_plan, &amp;context, 1, . . . );rclc_executor_init(&amp;exe_act, &amp;context, 1, . . . );// executor for sense-phaserclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb1, ON_NEW_DATA);rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb2, ON_NEW_DATA);rclc_let_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_all, NULL);// executor for plan-phaserclc_executor_add_subscription(&amp;exe_plan, &amp;plan, &amp;my_sub_cb3, ON_NEW_DATA);// executor for act-phaserclc_executor_add_subscription(&amp;exe_act, &amp;act, &amp;my_sub_cb4, ON_NEW_DATA);// spin all executorswhile (true) { rclc_executor_spin_some(&amp;exe_sense); rclc_executor_spin_some(&amp;exe_plan); rclc_executor_spin_some(&amp;exe_act);}Sensor fusion: The sensor fusion synchronizing the multiple rates with a trigger is shown below. . . . rcl_subscription_t aggr_IMU, sense_Laser, sense_IMU;rcle_let_executor_t exe_aggr, exe_sense;// initialize executorsrclc_executor_init(&amp;exe_aggr, &amp;context, 1, . . . );rclc_executor_init(&amp;exe_sense, &amp;context, 2, . . . );// executor for aggregate IMU datarclc_executor_add_subscription(&amp;exe_aggr, &amp;aggr_IMU, &amp;my_sub_cb1, ON_NEW_DATA);// executor for sense-phaserclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb3, ON_NEW_DATA);rclc_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_all, NULL);// spin all executorswhile (true) { rclc_executor_spin_some(&amp;exe_aggr); rclc_executor_spin_some(&amp;exe_sense);}The setup for the sensor fusion using sequential execution is shown below. Note that the sequetial order is sense_IMU, which will request the aggregated IMU message, and then sense_Laserwhile the trigger will fire, when a laser message is received. . . . rcl_subscription_t sense_Laser, sense_IMU;rcle_let_executor_t exe_sense;// initialize executorrclc_executor_init(&amp;exe_sense, &amp;context, 2, . . . );// executor for sense-phaserclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb1, ALWAYS);rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);rclc_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_one, &amp;sense_Laser);// spinrclc_executor_spin(&amp;exe_sense);High priorty path: This example shows the sequential processing order to execute the obstacle avoidance obst_avoidafter the callbacks of the sense-phase and before the callback of the planning phase plan. The control loop is started when a laser message is received. Then an aggregated IMU message is requested,like in the example above. Then all the other callbacks are always executed. This assumes that these callbackscommunicate via a global data structure. Race conditions cannot occur, because the callbacksrun all in one thread. . . . rcl_subscription_t sense_Laser, sense_IMU, plan, act, obst_avoid;rcle_let_executor_t exe;// initialize executorsrclc_executor_init(&amp;exe, &amp;context, 5, . . . );// define processing orderrclc_executor_add_subscription(&amp;exe, &amp;sense_IMU, &amp;my_sub_cb1, ALWAYS);rclc_executor_add_subscription(&amp;exe, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);rclc_executor_add_subscription(&amp;exe, &amp;obst_avoid, &amp;my_sub_cb3, ALWAYS);rclc_executor_add_subscription(&amp;exe, &amp;plan, &amp;my_sub_cb4, ALWAYS);rclc_executor_add_subscription(&amp;exe, &amp;act, &amp;my_sub_cb5, ALWAYS);rclc_executor_set_trigger(&amp;exe, rclc_executor_trigger_one, &amp;sense_Laser);// spinrclc_executor_spin(&amp;exe);Summary: The RCLC Executor is an Executor for C applications and can be used with default rclcpp Executor semantics. If additional deterministic behavior is necessary, the user can rely on pre-defined sequential execution, trigged execution and LET-Semantics for data synchronization. The concept of the rclc-Executor has been published in SLL2020. Future work:  Full LET semantics (writing data at the end of the period)     one publisher that periodically publishes   if Executors are running in multiple threads,publishing needs to be atomic   Download: The RCLC-Executor can be downloaded from the micro-ROS rclc repository. In this repository, the rclc package provides the RCLC-Executor and the rclc_examples package provides several demos. Further more, the rclc Executor is also available from the ros2/rclc repository. Callback-group-level Executor: The Callback-group-level Executor was an early prototype for a refined rclcpp Executor API developed in micro-ROS. It has been derived from the default rclcpp Executor and addresses some of the aforementioned deficits. Most important, it was used to validate that the underlying layers (rcl, rmw, rmw_adapter, DDS) allow for multiple Executor instances without any negative interferences. As the default rclcpp Executor works at a node-level granularity – which is a limitation given that a node may issue different callbacks needing different real-time guarantees - we decided to refine the API for more fine-grained control over the scheduling of callbacks on the granularity of callback groups using. We leverage the callback-group concept existing in rclcpp by introducing real-time profiles such as RT-CRITICAL and BEST-EFFORT in the callback-group API (i. e. rclcpp/callback_group. hpp). Each callback needing specific real-time guarantees, when created, may therefore be associated with a dedicated callback group. With this in place, we enhanced the Executor and depending classes (e. g. , for memory allocation) to operate at a finer callback-group granularity. This allows a single node to have callbacks with different real-time profiles assigned to different Executor instances - within one process. Thus, an Executor instance can be dedicated to specific callback group(s) and the Executor’s thread(s) can be prioritized according to the real-time requirements of these groups. For example, all time-critical callbacks are handled by an “RT-CRITICAL” Executor instance running at the highest scheduler priority. The following figure illustrates this approach with two nodes served by three Callback-group-level Executors in one process: The different callbacks of the Drive-Base node are distributed to different Executors (visualized by the color red, yellow and green).  For example the onCmdVel and publishWheelTicks callback are scheduled by the same Executor (yellow). Callbacks from different nodes can be serviced by the same Executor. API Changes: In this section, we describe the necessary changes to the Executor API:    include/rclcpp/callback_group. hpp:      Introduced an enum to distinguish up to three real-time classes (requirements) per node (RealTimeCritical, SoftRealTime, BestEffort)   Changed association with Executor instance from nodes to callback groups.       include/rclcpp/executor. hpp          Added functions to add and remove individual callback groups in addition to whole nodes.           Replaced private vector of nodes with a map from callback groups to nodes.          include/rclcpp/memory_strategy. hpp      Changed all functions that expect a vector of nodes to the just mentioned map.       include/rclcpp/node. hpp and include/rclcpp/node_interfaces/node_base. hpp      Extended arguments of create_callback_group function for the real-time class.    Removed the get_associated_with_executor_atomic function.    The callback-group-level executor has been merged into ROS 2 rclcpp in pull request 1218. Test Bench: As a proof of concept, we implemented a small test bench in the present package cbg-executor_ping-pong_cpp. The test bench comprises a Ping node and a Pong node which exchange real-time and best-effort messages simultaneously with each other. Each class of messages is handled with a dedicated Executor, as illustrated in the following figure. With the test bench, we validated the functioning of the approach. In this example, the callback for the high priority task (red line) consumes 10ms and the low priority task (blue line) 40ms in the Pong Node. With a ping rate of 20 Hz, the CPU saturates (10ms*20+40ms*20=1000ms). With higher frequencies the high priorty task can continue to send its pong message, while the low priority pong task degrades. With a frequency of 100Hz the high priority task requires 100% CPU utilization. With higher ping rates it keeps sending pong messages with 100Hz, while the low priority task does not get any CPU ressources any more and cannot send any messages. The test bench is provided in the cbg_executor_demo. Related Work: In this section, we provide an overview to related approaches and link to the corresponding APIs. Fawkes Framework: Fawkes is a robotic software framework, which supports synchronization points for sense-plan-act like execution. It has been developed by RWTH Aachen since 2006. Source code is available at github. com/fawkesrobotics. Synchronization: Fawkes provides developers different synchronization points, which are very useful for defining an execution order of a typical sense-plan-act application. These ten synchronization points (wake-up hooks) are the following (cf. libs/aspect/blocked_timing. h):  WAKEUP_HOOK_PRE_LOOP WAKEUP_HOOK_SENSOR_ACQUIRE WAKEUP_HOOK_SENSOR_PREPARE WAKEUP_HOOK_SENSOR_PROCESS WAKEUP_HOOK_WORLDSTATE WAKEUP_HOOK_THINK WAKEUP_HOOK_SKILL WAKEUP_HOOK_ACT WAKEUP_HOOK_ACT_EXEC WAKEUP_HOOK_POST_LOOPConfiguration at compile time: At compile time, a desired synchronization point is defined as a constructor parameter for a module. For example, assuming that mapLaserGenThread shall be executed in SENSOR_ACQUIRE, the constructor is implemented as: MapLaserGenThread::MapLaserGenThread() :: Thread( MapLaserGenThread , Thread::OPMODE_WAITFORWAKEUP),   BlockedTimingAspect(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_ACQUIRE),   TransformAspect(TransformAspect::BOTH_DEFER_PUBLISHER,  Map Laser Odometry )Similarly, if NaoQiButtonThread shall be executed in the SENSOR_PROCESS hook, the constructor is: NaoQiButtonThread::NaoQiButtonThread() :: Thread( NaoQiButtonThread , Thread::OPMODE_WAITFORWAKEUP),   BlockedTimingAspect(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_PROCESS)Runtime execution: At runtime, the Executor iterates through the list of synchronization points and executes all registered threads until completion. Then, the threads of the next synchronization point are called. A module (thread) can be configured independent of these sense-plan-act synchronization points. This has the effect, that this thread is executed in parallel to this chain. The high level overview of the Fawkes framework is shown in the next figure. At compile-time the configuration of the sense-plan act wakeup hook is done (upper part), while at run-time the scheduler iterates through this list of wakeup-hooks (lower part): Hence, at run-time, the hooks are executed as a fixed static schedule without preemption. Multiple threads registered in the same hook are executed in parallel. Orthogonal to the sequential execution of sense-plan-act like applications, it is possible to define further constraints on the execution order by means of a Barrier. A barrier defines a number of threads, which need to have finished before the thread can start, which owns the barrier. These concepts are implemented by the following main classes:  Wakeup hook by SyncPoint and SyncPointManager, which manages a list of synchronization points.  Executor by the class FawkesMainThread, which is the scheduler, responsible for calling the user threads.  ThreadManager, which is derived from BlockedTimingExecutor, provides the necessary API to add and remove threads to wakeup hooks as well as for sequential execution of the wakeup-hooks.  Barrier is an object similar to condition_variable in C++. Discussion: All threads are executed with the same priority. If multiple sense-plan-act chains shall be executed with different priorities, e. g. to prefer execution of emergency-stop over normal operation, then this framework reaches its limits. Also, different execution frequencies cannot be modeled by a single instance of this sense-plan-act chain. However, in robotics the fastest sensor will drive the chain and all other hooks are executed with the same frequency. The option to execute threads independent of the predefined wakeup-hooks is very useful, e. g. for diagnostics. The concept of the Barrier is useful for satisfying functional dependencies which need to be considered in the execution order. References:    [L2020] Ralph Lange: Advanced Execution Management with ROS 2, ROS-Industrial Conference, Dec 2020 [Slides]     [SLL2020] J. Staschulat, I. Lütkebohle and R. Lange, “The rclc Executor: Domain-specific deterministic scheduling mechanisms for ROS applications on microcontrollers: work-in-progress,” 2020 International Conference on Embedded Software (EMSOFT), Singapore, Singapore, 2020, pp. 18-19. [Paper] [Video]     [L2018] Ralph Lange: Callback-group-level Executor for ROS 2. Lightning talk at ROSCon 2018. Madrid, Spain. Sep 2018. [Slides] [Video]     [CB2019] D. Casini, T. Blaß, I. Lütkebohle, B. Brandenburg: Response-Time Analysis of ROS 2 Processing Chains under Reservation-Based Scheduling, in Euromicro-Conference on Real-Time Systems 2019. [Paper] [slides]     [EK2018] R. Ernst, S. Kuntz, S. Quinton, M. Simons: The Logical Execution Time Paradigm: New Perspectives for Multicore Systems, February 25-28 2018 (Dagstuhl Seminar 18092). [Paper]     [BP2017] A. Biondi, P. Pazzaglia, A. Balsini, M. D. Natale: Logical Execution Time Implementation and Memory Optimization Issues in AUTOSAR Applications for Multicores, International Worshop on Analysis Tools and Methodologies for Embedded and Real-Time Systems (WATERS2017), Dubrovnik, Croatia. [Paper]     [LL1973] Liu, C. L. ; Layland, J. :Scheduling algorithms for multiprogramming in a hard real-time environment, Journal of the ACM, 20 (1): 46–61, 1973.     [HHK2001] Henzinger T. A. , Horowitz B. , Kirsch C. M. (2001) Giotto: A Time-Triggered Language for Embedded Programming. In: Henzinger T. A. , Kirsch C. M. (eds) Embedded Software. EMSOFT 2001. Lecture Notes in Computer Science, vol 2211. Springer, Berlin, Heidelberg     [NSP2018] A. Naderlinger, S. Resmerita, and W. Pree: LET for Legacy and Model-based Applications,Proceedings of The Logical Execution Time Paradigm: New Perspectives for Multicore Systems (Dagstuhl Seminar 18092), Wadern, Germany, February 2018.     [KZH2015] S. Kramer, D. Ziegenbein, and A. Hamann: Real World Automotive Benchmarks For Free, International Workshop on Analysis Tools and Methodologies for Embedded adn Real-Time Sysems (WATERS), 2015. [Paper]   Acknowledgments:  This activity has received funding from the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (grant agreement n° 780785). "
        }, {
        "id": 97,
        "url": "https://micro-ros.github.io//docs/concepts/client_library/features/",
        "title": "Feature List",
        "body": " - The micro-ROS Client Library, formed by standard ROS 2 Client Support Library (rcl) and the new ROS 2 Client Library package (rclc), is going to feature all major ROS concepts such as  Nodes Publishers/subscriptions Services/clients Graph Executor Lifecycle ParametersMost features are already available in the Foxy release. Please see our Feature Overview page for details on the status. To learn developing your own application nodes with rcl + rclc, please head to the corresponding programming tutorial. "
        }, {
        "id": 98,
        "url": "https://micro-ros.github.io//docs/concepts/client_library/introduction/",
        "title": "Introduction to Client Library",
        "body": " - The Client Library provides the micro-ROS API for the user code, i. e. , for application-level micro-ROS nodes. The goal is to provide all relevant, major ROS 2 concepts in an optimized implementation for microcontrollers. At the same time, we strive to make the API as compatible as possible to standard ROS 2, to facilitate porting of code. To minimize the long-term maintenance cost, we use existing data structures and algorithms from the ROS 2 stack and bring necessary changes in the mainline stack as far as possible. That’s why the micro-ROS client library is built up from standard ROS 2 Client Support Library (rcl) and a new ROS 2 Client Library package (rclc). Together, as depicted below, rcl + rclc form a feature-complete client library in the C programming language.  Important features and properties:  Use of rcl data structures where possible to avoid runtime overhead by wrappers.  Convenience functions for common tasks (e. g. , creation of a publisher, finalization of a subscription) provided by rclc.  Dedicated Executor for fine-grained control over triggering and processing order of callbacks.  Specialized implementations for graphs, lifecycle nodes, diagnostics, etc. Check out the subpages (see left) for more information.  For the interested reader: The rationales for the decision to use a combination of rcl + rclc are explained in our decision paper (PDF) from 2019. "
        }, {
        "id": 99,
        "url": "https://micro-ros.github.io//docs/concepts/client_library/lifecycle_and_system_modes/",
        "title": "Lifecycle and System Modes",
        "body": " - Table of contents  Introduction and Goal Requirements Background: ROS 2 Lifecycle Main Features     Basic Lifecycle   Extended Lifecycle   System Hierarchy and Modes   Mode Inference   Mode Manager   Error Handling and Rules    AcknowledgmentsIntroduction and Goal: Modern robotic software architectures often follow a layered approach. The layer with the core algorithms for SLAM, vision-based object recognition, motion planning, etc. is often referred to as skill layer or functional layer. To perform a complex task, these skills are orchestrated by one or more upper layers named executive layer and planning layer. Other common names are task and mission layer or deliberation layer(s). In the following, we used the latter term. We observed three different but closely interwoven aspects to be handled on the deliberation layer:  Task Handling: Orchestration of the actual task, the straight-forward, error-free flow.  Contingency Handling: Handling of task-specific contingencies, e. g. , expectable retries and failure attempts, obstacles, low battery.  System Error Handling: Handling of exceptions, e. g. , sensor/actuator failures. The mechanisms being used to orchestrate the skills are service and action calls, re-parameterizations, set values, activating/deactivating of components, etc. We distinguish between function-oriented calls to a running skill component (set values, action queries, etc. ) and system-oriented calls to individual or multiple components (switching between component modes, restart, shutdown, etc. ).  Analogously, we distinguish between function-oriented notifications from the skill layer in form a feedback on long-running service calls, messages on relevant events in the environment, etc. and system-oriented notifications about component failures, hardware errors, etc. Our observation is that interweaving of task handling, contingency handling, and system error handling generally leads to a high complexity of the control flow on the deliberation layer. Yet, we hypothesize that this complexity can be reduced by introducing appropriate abstractions for system-oriented calls and notifications. Therefore, our goal within this work is to provide suitable abstractions and framework functions for (1. ) system runtime configuration and (2. ) system error and contingency diagnosis, to reduce the effort for the application developer of designing and implementing the task, contingency and error handling. This goal is illustrated in the following example architecture, which is described and managed based on a model file: The main features of the approach are (detailed in the remainder):  Extended Lifecycle: Extensible concept to specify the runtime states of components, i. e ROS 2 lifecycle nodes.  System Hierarchy and Modes: Modeling approach for specifying a ROS system in terms of its system hierarchy and system modes, i. e. different (sub-)system configurations.  Mode Manager: A module to manage and change the system runtime configuration.  Mode Inference: A module for deriving the entire system state and mode from observable system information, i. e. states, modes, and parameters of its components.  Error Handling: Lightweight concept for specifying an error handling and recovery mechanism. Requirements: The list of requirements is maintained in the doc folder of the micro-ROS system modes repository, at:https://github. com/micro-ROS/system_modes/blob/master/system_modes/doc/requirements. md Background: ROS 2 Lifecycle: Our approach is based on the ROS 2 Lifecycle. The primary goal of the ROS 2 lifecycle is to allows greater control over the state of a ROS system. It allows consistent initialization, restart and/or replacing of system parts during runtime. It provides a default lifecycle for managed ROS 2 nodes and a matching set of tools for managing lifecycle nodes. The description of the concept can be found at:http://design. ros2. org/articles/node_lifecycle. htmlThe implementation of the Lifecycle Node is described at:https://index. ros. org/doc/ros2/Managed-Nodes/. Main Features: Basic Lifecycle: The ROS 2 Lifecycle has been implemented for micro-ROS as part of the C programming language client library rclc, see rclc_lifecycle for source-code and documentation. The rclc_lifecycle package is a ROS 2 package that provides convenience functions to bundle a ROS Client Library (rcl) node with the ROS 2 Node Lifecycle state machine in the C programming language, similar to the rclcpp Lifecycle Node for C++. An example, how to use the rclc Lifecycle Node is given in the file lifecycle_node. c in the rclc_examples package. Extended Lifecycle: In micro-ROS, we extend the ROS 2 lifecycle by allowing to specify modes, i. e. substates, specializing the active state based on the standard ROS 2 parameters mechanism. We implemented this concept based on rclc_lifecycle and rclcpp_lifecycle for ROS 2 and micro-ROS. Documentation and code can be found at:github. com:system_modes/README. md#lifecycle System Hierarchy and Modes: We provide a modeling concept for specifying the hierarchical composition of systems recursively from nodes and for specifying the states and modes of systems and (sub-)systems with the extended lifecycle, analogously to nodes. This system modes and hierarchy (SMH) model also includes an application-specific the mapping of the states and modes along the system hierarchy down to nodes. The description of this model can be found at:github. com:system_modes/README. md#system-modesA simple example is provided at:github. com:system_modes_examples/README. md#example-mode-file Mode Inference: The mode inference infers the entire system states (and modes) based on the lifecycle states, modes, and parameter configuration of its components, i. e. the ROS 2 lifecyle nodes. It parses the SMH model and subscribes to lifecycle/mode change requests, lifecycle/mode changes, and parameter events. Based on the lifecycle change events it knows the actual lifecycle state of all nodes. Based on parameter change events it knows the actual parameter values of all nodes, which allows inference of the modes of all nodes based on the SMH model. Based on the SMH model and the inferred states and modes of all nodes, states and modes of all (sub-)systems can be inferred bottom-up along the system hierarchy. This can be compared to the latest requested states and modes to detect a deviation. The documentation and code can be found at:github. com:system_modes/README. md#mode-inferenceThe mode inference can be best observed in the mode monitor, a console-based debugging tool, see:github. com:system_modes/README. md#mode-monitor Mode Manager: Building upon the Mode Inference mechanism, the mode manager provides additional services and topics to manage and adapt system states and modes according to the specification in the SMH model. The documentation and code can be found at:github. com:system_modes/README. md#mode-managerA simple example is provided at:github. com:system_modes_examples/README. md#setup Error Handling and Rules: If the actual state/mode of the system or any of its parts diverges from the target state/mode, we define rules that try to bring the system back to a valid target state/mode, e. g. , a degraded mode. Rules work in a bottom-up manner, i. e. starting from correcting nodes before sub-systems before systems. Rules are basically defined in the following way: if: system. target == {target state/mode} &amp;&amp; system. actual != {target state/mode} &amp;&amp; part. actual == {specific state/mode}then: system. target := {specific state/mode}If actual state/mode and target state/mode diverge, but there is no rule for this exact situation, the bottom-up rules will just try to return the system/part to its target state/mode. Note: This feature is suited for simple, well-defined rules according to the depicted syntax. For more complex orchestration, integration of system modes with ontological reasoning (metacontrol) has been validated and successfully shown in the MROS project, e. g. , within a navigation sub-system of a mobile robot. Acknowledgments: This activity has received funding from the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (grant agreement n° 780785). "
        }, {
        "id": 100,
        "url": "https://micro-ros.github.io//docs/concepts/fiware_interoperability/",
        "title": "Interoperability with FIWARE",
        "body": " - Motivation: Among the goals of the micro-ROS project, one of the key issues has been that of providing interoperability with third outstanding and broadly used platforms. One of the selected components has been the FIWARE Context Broker, a standard for context data management adopted by several EU boosted initiatives for facilitating the development of smart solutions for different domains. This section explains how to achieve interoperability between micro-ROS and this platform, passing through the integration of the latter with ROS 2. Thanks to this interoperability, the FIWARE’s Context Broker becomes micro-ROS’ platform of choice for sharing context information with any other system integrated into the FIWARE ecosystem. Interoperability: pros and cons of the different possible solutions: This subsection will explain all the design alternatives for the interoperability between micro-ROS and the FIWARE Context Broker. From now on, the developed solution for intercommunicating micro-ROS with FIWARE will be called FIROS2 Integration Service. FIROS2 requires transformation libraries to convert ROS 2 messages into FIWARE NGSIv2 messages and the other way around. For each message, one transformation library is required.  In the implementation of these transformation libraries, it is required to be able to serialize/deserialize ROS 2 messages. Also, an NGSIv2 serialisation/deserialisation mechanism will be used. The FIROS2 package provides a standard NGSIv2 serialisation/deserialisation mechanisms, but ROS 2 serialisation/deserialisation is more complex, due to its dependencies with the message type. Therefore, FIROS2 Integration Service needed to be implemented providing a simple user-wise solution to automatically generate the transformation libraries for ROS 2 types. To accomplish this, two different approaches can be taken:  Implementing an ad-hoc bridging communication tool for translating FIWARE’s messages into micro-ROS (that is, ROS 2) messages types, and viceversa.  Relying on an integration platform that uses a common types language representation, and defines a conversion library from/to the generic type to the specific type of each middleware. While the first approach might result in a more lightweight tool, it has several flaws, for instance a more difficult maintenance and the incapability of communicating with any other middleware, rather than ROS2 or micro-ROS. On the other hand, using an integration service platform, such as SOSS, enables automatically the possibility of communicating with a wide (and growing) set of middlewares, if their System Handle implementation is available. SOSS: System-Of-Systems-Synthesizer: SOSS addresses the task of providing a common interface for communicating software platforms that speak different languages. It is composed of a core library, which defines a set of abstract interfaces and provides some utility classes to form a plugin-based framework. This pluggable interface allows the user to leverage any of the supported plugins or System Handles for a specific middleware, such as DDS, ROS2, FIWARE, or ROS, for the desired integration. SOSS can act as an intermediate message-passing tool that, by speaking a common language, centralizes and mediates the integration of several applications running under different communication middlewares. A SOSS instance is configured and launched by means of a YAML file, which allows the user to provide a mapping between the different topics and services that two or more applications can exchange information about. Users can also develop their own System Handles for a new middleware, automatically granting communication capabilities with all the rest of supported middlewares. Usually, types are defined using a common language representation, used by SOSS to create a shared representation of the exchanged information, so that it can be processed, converted and remapped to every middleware’s types implementation, when required. This common representation is provided, user-wise, using IDL definitions, which are parsed and converted into Dynamic Types representations at runtime, using eProsima’s XTypes-DDS implementation.  SOSS-FIWARE System Handle: The FIWARE System Handle allows bringing information from and to FIWARE’s Context Broker into the SOSS world. This System Handle is configured and launched in the same way as any SOSS System Handle. Besides the standard information included in any System Handle’s configuration (such as system’s name and type, which would be fiware for this specific System Handle),in the case of the FIWARE System Handle users must specify two extra YAML key-value pairs, which are the host’s IP and port in which this System Handle will try to connect to an instance of FIWARE’s Orion Context Broker. Regarding more specific details about the implementation, FIWARE does not allow certain characters in its entities names. For this reason, if a type defined in the topics section of the configuration file has in its name a /, the FIWARE System Handle will map that character into two underscores. This is something important to notice when connecting to ROS2, because in ROS2 most of the types have a / in their names. To deal with this issue, using SOSS remapping capabilities come in handy. Of course, given that micro-ROS applications act as a bridge between microcontrollers and the ROS 2 dataspace (using the micro-ROS Agent), FIROS2 should also take care of communicating FIWARE’s Context Broker with ROS 2, leveraging the existing ROS 2 System Handle, which comes natively included into the SOSS package. This is exactly the situation reflected in the use case that is explained below. FIROS2 use case: connecting FIWARE with ROS 2: Installation:  Create a colcon workspace.    $ mkdir -p soss_ws/src $ cd soss_ws    Clone the SOSS project into the source subfolder.    $ git clone https://github. com/osrf/soss_v2. git src/soss --branch feature/xtypes-dds    Clone the SOSS-FIWARE project into the source subfolder.    $ git clone https://github. com/eProsima/SOSS-FIWARE. git src/soss-fiware --branch feature/xtypes-support    The workspace layout should now look like this:   soss_ws  |  |_ src    |    |_ soss    |  |    |  |_ (other soss project subfolders)    |  |_ packages    |     |    |     |_ (other soss system handle subfolders)    |     |_ soss-ros2 (ROS2 system handle)    |    |_ soss-fiware        |        |_ fiware (soss-fiware colcon package)        |_ fiware-test (soss-fiware-test colcon package)    In the workspace folder, execute colcon.    $ colcon build --packages-up-to soss-ros2 soss-fiware    Source the resulting enviromnment:   $ source install/local_setup. bash   Configuration: SOSS must be configured with a YAML file, which tells the program everything it needs to know in order to establish the connection between two or more systems that the user wants. For example, if the user wants to exchange a simple string message between FIWARE and ROS2, the configuration file for SOSS should look as follows:   systems:    ros2: { type: ros2 }    fiware: { type: fiware, host: CONTEXT_BROKER_IP, port: 1026}  routes:    fiware_to_ros2: { from: fiware, to: ros2 }    ros2_to_fiware: { from: ros2, to: fiware }  topics:    hello_fiware: { type:  std_msgs/String , route: ros2_to_fiware }    hello_ros2: { type:  std_msgs/String , route: fiware_to_ros2 }In the project’s CMakeLists. txt file, users must specify which ROS 2 packages are required for their SOSS instance,by means of the provided soss-rosidl-mix macro in order to generate the proper IDL types definition and typesupport files resulting from ROS 2 msg/srv files:   soss_rosidl_mix(   PACKAGES geometry_msgs nav_msgs test_msgs . . .    MIDDLEWARES ros2  )Note: if the package list is modified, it is recommended to re-build the whole colcon workspace. Otherwise, . mix files might not be generated for the new ROS 2 type package(s) included in the aforementioned macro. Finally, after source the colcon workspace, you can launch FIROS2 with:   cd &lt;path_to_yaml_config_file&gt;  soss &lt;yaml_config_file_name&gt;. yaml"
        }, {
        "id": 101,
        "url": "https://micro-ros.github.io//docs/concepts/middleware/IoT/",
        "title": "DDS-XRCE, MQTT & IoT",
        "body": " - Nowadays almost everybody knows what it is or has heard something about IoT. An informal definition could be “everything connected with everything”. However, to be a bit more precise, IoT or Internet of Things is extending regular connectivity, traditionally reserved for specific devices, to almost any kind of equipment we can imagine, from small sensors in our fields and farms to life monitors in hospitals. It is estimated that in 2020, 50 billion of such as devices will be connected to each other (@evans2011cisco). One thing that these 50 billion devices will share is the need to communicate, that is the field where the middleware plays an important role inside this vast technological challenge. The middleware is in charge of facilitating the network deployment allowing developers to focus on the application implementation. This article will introduce two standards though and developed with IoT in mind, MQTT and DDS-XRCE. MQTT: Message Queuing Telemetry Transport (MQTT) is one of the most used protocols in IoT solutions. It has been designed as a lightweight message protocol to be used over TCP transports providing a standard and simple publish/subscribe interface for exchanging data. The communication mechanism of MQTT is based on a client-server architecture. This means that clients (MQTT Clients) are connected to a server (MQTT Broker) which is in charge of orchestrating the exchange of data using a publish-subscribe messaging pattern. In other words, clients publish messages associated with a particular Topic in the Broker, and this last redirects these messages to the clients subscribed to the Topic. So in MQTT, we can speak of some key concepts: Broker, Client, Topic, Message, Publish and Subscribe. Each of these concepts has its role and meaning:  The Broker acts as the backbone of the system.  Dealing with the messages of topics.  The Clients are the parts in charge of publishing and receiving subscription data from the Broker.  The Topic is a channel of information.  Message a piece of information on a defined Topic.  Publish is the action of sending a Message for a defined Topic to the Broker.  Subscribe is the action of reflecting an interest in receiving all the Messages of a defined Topic. It is handled in by the Broker. All this is done over a TCP protocol allowing the connection between Clients and Brokers over WANs and the Internet. Such a connection is made statically, i. e. , the client must know the Broker address before a first connection is made. These communications could obey three different QoS specifying the delivery behaviour:       QoS   Guaranteed delivery   Duplicity protection         QoS0   No   No       QoS1   Yes   No       QoS2   Yes   Yes   As mentioned before, there is the concept of Topic in this kind of middleware. The Topic’s type is set by the application as well as its name. Publications are done using the Topic name and a set of data with a user-defined format. Analogously, subscriptions are done to Topic names, while the data interpretation is the responsibility of the Clients. MQTT standard does not mark how this topic-type tuple is related, so the responsibility of topic understanding resides on the user side. This architecture and communication pattern natively allows the interchange of data between devices (M2M protocol), composing this way a good IoT middleware. DDS-XRCE: The DDS for eXtremely Resource-Constrained Environments (DDS-XRCE) is a wire protocol, adopted by the Object Management Group (OMG),whose aim is to provide access to the DDS (Data Distribution Service) data-space from low resource devices. As in the MQTT case, the DDS-XRCE follows a client-server architecture where clients (XRCE Clients) are connected to a server (XRCE Agent). In contrast to MQTT, the XRCE Agent is not in charge of managing the publication/subscription of Topics, but it acts on behalf of the XRCE Clients in the DDS global data-space. That is, the DDS-XRCE protocol allows the XRCE Clients to act as first-class citizens in a traditional DDS network.  This protocol specified how the XRCE Clients interact with the XRCE Agent. Basically, there are two ways of interactions between them:  XRCE Clients can handle proxy entities on the Agent.  Such proxy entities are the ones acting on the DDS network.  This allows the Clients to operate as a stateless system, as the state resides in the Agent.  This, among other things, will enable sleep cycles, and resource-constrained devices to communicate with DDS.  XRCE Clients can publish/subscribe to/from any DDS Topic as if they were regular DDS participants.  This makes the separation between resource-constrained devices and DDS networks diffuse, so they can participate as real entities in DDS world. In a nutshell, DDS-XRCE provides the XRCE Client with a simple publish/subscribe messaging pattern with which to communicate with existing DDS networks. In the same way as traditional DDS networks, there are some inherited concepts:  Topic.  Channels of information Message.  Information pieces.  Publish.  The operation which exposes Messages.  Subscribe.  The procedure which allows receiving chosen Messages. Also, added ones:  XRCE Client.  These are lightweight actors on resource-constrained devices with a simple publish/subscribe interface.  XRCE Agent.  Central part of the protocol providing the required DDS access to the XRCE Clients mentioned above. The DDS-XRCE wire protocol is specified to be in at least TCP and UDP transport protocol, but there is room to expand to other protocols. Currently, implementations are supporting Serial links and possible to be extended to any other such Zigbee, 6LoWPAN, and more. DDS-XRCE allows setting two different delivery QoS:  Reliable.  Best-effort. As part of the DDS family standard, the use of OMG’s IDL standard has also been included. This provides the user with a way to define the types of topics used as well as setting a standard serialisation format. Doing that ensures interoperability and leverage the application layer of the matter of defining custom serialisation formats and type matching mechanisms. This protocol brings a new spectrum of possibilities to IoT devices as it brings all the benefits of DDS (Distributed system, configurable QoS, interoperability). MQTT vs DDS-XRCE: At this point, you probably are wondering which are the differences between MQTT and DDS-XRCE. At first glance, they seem to share a lot of the foundations such as similar architecture and communication patterns but differ on some crucial matters, exposed in the following table.           DDS-XRCE   MQTT         architecture pattern   client-server   client-server       messaging pattern   publish-subscribe   publish-subscribe       transport protocol   UDP/TCP/Serial/Custom   TCP       security   DTLS/TLS (non normative)   TLS (non normative)       types   Standard IDL   Opaque, user choice       QoS   Reliable &amp; best-effort   3 Message delivery       session oriented   yes   yes       minimum overhead   12 B***   5 B* **       maximum overhead   16 B***   2^16 B*       max payload size   64 KB   256 MB       topologies   1 to 0, 1 to 1, 1 to n   1 to 0, 1 to 1, 1 to n       discovery support   yes   no   _ * Scales with the topic name. _ _ ** For a topic name composed by 8 ASCII characters (8 Bytes) the MQTT overhead will equate to DDS-XRCE overhead. From that point, the MQTT overhead will scale with the name size. However, DDS-XRCE will be static_ _ *** Maximum and minimum DDS-XRCE overhead depends on whether the message using client ID. _ The previous tables compare both protocols. Aside from this protocol differences, we may point out one of the critical concepts of DDS-XRCE, bringing small devices to distributed networks. This provides this protocol with a great range of use cases as well as prepared to be scaled in a significant amount being far more dynamic in this sense to MQTT alternative. "
        }, {
        "id": 102,
        "url": "https://micro-ros.github.io//docs/concepts/middleware/Micro_XRCE-DDS/",
        "title": "Micro XRCE-DDS",
        "body": " - This page is dedicated to describing the most salient features of Micro XRCE-DDS,the default middleware implementation for micro-ROS’ rmw layer. eProsima Micro XRCE-DDS is an open-source wire protocol that implements the OMG DDS for eXtremely Resource Constrained Environment standard (DDS-XRCE). The aim of the DDS-XRCE protocol is to provide access to the DDS Global-Data-Space from resource-constrained devices. This is achieved thanks to a client-server architecture, where low resource devices, called XRCE Clients, are connected to a server, called XRCE Agent, which acts on behalf of its clients in the DDS Global-Data-Space.  Micro XRCE-DDS is composed by two main elements:  Micro XRCE-DDS Agent: a C++11 out-of-the-box application which implements the XRCE Agent functionality.  Micro XRCE-DDS Client: a C99 library which implements the XRCE Client side functionality. In addition, Micro XRCE-DDS uses other two components:  Micro CDR: a de/serialization engine used in the Client library.  Micro XRCE-DDS Gen: a code generator tool used for generating Micro CDR de/serialization functions and Client apps examples from IDL sources. Application: Micro XRCE-DDS is focused on microcontroller applications which require to access a publisher/subscriber architecture. Some examples of this kind of applications are those found in sensor networks, IoT or robotics. Some companies such as Renesas and ROBOTIS are using Micro XRCE-DDS as a middleware solution. Furthermore, the micro-ROS project, whose goal is to put ROS 2 onto microcontroller, has adopted Micro XRCE-DDS as its default middleware layer. Main Features: Low Resource Consumption: As it was mentioned above, Micro XRCE-DDS is focused on microcontroller applications. Therefore, the design and implementation of this middleware have been carried out taking into account the memory constraints of this kind of devices. A proof of this is the fact that the XRCE Client is completely dynamic memory free. From the point of view of the memory footprint, the latest version of this library has a memory consumption of less than 75 KB of Flash memory and around 3 KB of RAM for a complete publisher and subscriber application handling messages sizes on the order of 512 B. For more detailed information on the memory consumption as a function of message size, entity number and internal memory management of the middleware library, please refer to the Micro XRCE-DDS memory profiling section. Moreover, this library is highly configurable thanks to a profile concept that enables to choose, add or remove some features in configuration time. That allows customizing the XRCE Client library size, if there are features that are not used. There are several definitions for configuring and building the Client library at compile-time. These definitions allow to create a version of the library according to the application requirements, and can be modified in the client. config file. For incorporating the desired configuration, it is necessary to run the cmake command every time the definitions change. For more information on how to configure micro-ROS by opportunely tuning parameters either in the Micro XRCE-DDS libraryorin its rmw implementation rmw_microxrcedds, consult this tutorial and the rmw_microxrcedds README. Multi-Transport Support: As part of the profiles discussed in the previous section, the user can choose between several transport layers to communicate the Clients with the Agent. Indeed, in contrast to other IoT middleware such as MQTT and CoaP, which work over only a particular transport layer, XRCE supports multiple transport protocols natively. In particular, the latest version of Micro XRCE-DDS support: UDP, TCP and a custom Serial transport protocol. Apart from this, Micro XRCE-DDS has a transport interface for both Agent and Client which allows to implement custom transports in a straightforward manner. This makes the port of Micro XRCE-DDS to different platforms and the addition of new transports a seamless task that any user can undertake. Multi-Platform Support: The XRCE Client supports FreeRTOS, Zephyr and NuttX as embedded RTOS. Moreover, it also runs on Windows and Linux. On the other hand, the XRCE Agent supports Windows and Linux. QoS support: The XRCE Client library allows the user to use two different approaches for creating DDS entities in the XRCE Agent:  By XML (the default option) By referenceWhen using the default option, users are enabled to create entities either in Reliable or Best-Effort mode, with the XML files written and stored on the Client side. But these QoS configurations may not fit some users’ requirements. For these cases, Micro XRCE-DDS allows to create entities directly on the Agent, where the user can write custom XML QoS as in DDS. Each entity available on the Agent will be associated to a label, so that the Clients can to create the entities they need for the communication by just referring to these labels. Additionally, using references will also reduce the memory consumption of the Client inside the MCU. This is because the reference approach allows avoiding to build the parts of the code where XMLs are stored. Notice that this mechanism is inherited by micro-ROS which, as a consequence, will be able to leverage the same full set of QoS as ROS 2. For a comprehensive review on how to use custom QoS in micro-ROS, please visit this dedicated page in the tutorials section. Other links:  Manual at Read the Docs Micro XRCE-DDS on GitHub XRCE Client on GitHub XRCE Agent on GitHub rmw_microxrcedds on GitHub Micro XRCE-DDS memory profiling Middleware optimization tutorial.  How to use custom QoS in micro-ROS"
        }, {
        "id": 103,
        "url": "https://micro-ros.github.io//docs/concepts/middleware/memo_prof/",
        "title": "Micro XRCE-DDS memory profiling",
        "body": " - Abstract: In this section, we analyze the memory footprint of the Micro XRCE-DDS Client and Agent libraries. In both cases, we consider an application of a given number of publishers and/or subscribers into/from topics of known size. As for the Client, we performed the measurements for an app running on the Real Time Operating System (RTOS) FreeRTOS and on an Olimex STM32-E407 board, and connected by serial transport (UART) to a Micro XRCE-DDS Agent running on a Linux machine. As for the Agent, we performed the measurements for a lightweight Agent running on a Linux machine, communicating with a XRCE-DDS Client application running on the same host machine. Results show that the total memory consumption of the Client makes this library fit for the same class of low-range microcontrollers targeted by the rosserial protocol. On the other hand, the lightweight version of the Agent is apt for being compiled on more performant systems only. Table of contents Memory Profiling of the Micro XRCE-DDS Client on FreeRTOS     Memory and Configurability   Methodology   Results and Discussion    Memory Profiling of the Micro XRCE-DDS Agent on Linux     Available Middleware Implementations for the Agent   Methodology and Results   Memory Profiling of the Micro XRCE-DDS Client on FreeRTOS: Micro XRCE-DDS target applications are low range Microcontroller Units (MCUs) with highly constrained memory resources, so that it becomes critical to assess the XRCE-DDS Client memory consumption with extreme precision to help users selecting the adequate platforms to develop their applications. In this section, we report on the memory footprint of the Micro XRCE-DDS Client library for two simple applications, one publishing and the other subscribing to topics of known size, running on the Real Time Operating System (RTOS) FreeRTOS and on an Olimex STM32-E407 board. The board running the Client is connected by serial transport (UART) at 115200 baud to a Micro XRCE-DDS Agent running on a Linux machine. This choice has been made since FreeRTOS provides memory management functionalities that easily allows to compute the stack memory used by a given program as the difference between the total allocated memory, known to the programmer, and the minimum stack left unused during the program execution. Memory and Configurability: Given the limited memory resources offered by the systems targeted by the XRCE-DDS library, the possibility to manipulate the memory size of the Client is key. This can be done at two different levels:  At configuration time: to fix the size of the executable code size, the library can be compiled enabling or disabling several profiles. Indeed, theClient library follows a profile concept that enables to choose, add or remove some features in configuration time, thus allowing the user to customize its size. As we’ll see below, as part of these profiles one can choose for instance to communicate in reliable or best-effort mode. For more information, please refer to the Client library documentation.  At run time: the Client library is both dynamic and static memory free, implying that all memory footprint depends only on how the stack grows duringthe execution. The parameters that, together with the library functions, control the stack are the streams and the Maximum Transmission Unit (MTU).      The MTU is transport-dependent, and it can be configured by the user. The selected value represents the maximum message size that can be sent received without fragmenting the message. The transport uses the MTU value to create an internal buffer, which is the memory block where the messages will be written and stored when interchanged.    As for the streams, the user can define a maximum of 127 best-effort streams and 128 reliable streams, but for the majority of purposes, only one stream in either best effort or reliable mode is used. Moreover, reliable streams have a history associated, whose size can be tailored to fit the specific requirements of the application. In this case, the size of the stream corresponds to the total reserved memory for the stream, equal to the maximum message size times the associated history. In the best-effort case, no history is stored and the memory reserved for the stream equals the maximum message size.    Methodology: In this section, we detail the methodology employed for the memory profiling. A Micro XRCE-DDS Client application is created with a varying number of either publishers or subscribers, associated with their own datawriters or datareaders. Moreover, each is associated with a topic of known size and with two streams, one for input and one for output messages. Finally, a minimum history size of 2 is used in the case of reliable communication. The MTU selected for the serial transport used by these applications has been fixed to 512 B, which in turn sets the size of the transport buffer. In order to provide a complete characterization of the memory consumption, the following parameters have been varied:  Creation mode: this is one of the profiles that can be configured at compile time. We have explored both XML and reference modes for the creation of the entities on the Agent on behalf of the Client. In the first case, entities are created according to an XML configuration file defined by the user on the Client app. In the second case, they are created directly on the Agent according to preconfigured reference entities known beforehand by the Agent, to which the Client simply refers.  Stream types: best-effort vs reliable communication modes between the Client and the Agent. Best-effort streams send and receive data leaving the reliability to the transport layer, and the message size handled by a best-effort stream must be less or equal than the Maximum Transmission Unit (MTU) defined in the transport used. On the other hand, reliable streams perform the communication without loss regardless of the transport layer and allow message fragmentation to send and receive messages longer than the MTU. To avoid a loss of data, the reliable streams use additional messages to confirm the delivery, along with a history of the messages sent and received. As a result, best effort streams will consume fewer resources than reliable streams.  Size of the topics, ranging between 0 and ~ 3 KB for the publisher (both best-effort and reliable) and for the reliable subscriber, and between 0 and ~ 400 B for the subscriber best-effort. The reason for the latter is that, given the absence of fragmentation in best-effort communication streams, the maximum message size that a best-effort subscriber can support equals the transport buffer size (or MTU), that we have fixed to 512 B. On the other hand, thanks to fragmentation, a reliable subscriber can receive a message of arbitrary size opportunely chunked in pieces of the size of the MTU.  Number of publishers/subscribers, which is equivalent to changing the number of topics, since in our design of the set-up we have associated each publisher/subscriber with just one topic. The memory usage of a MCU by means of one such XRCE-DDS application is split into different chunks, each devoted to a different function:  Data buffer: This buffer stores the topic data before serialization. We don’t include it in our footprint as this memory is application specific and not related to the Micro XRCE-DDS Client operations.  Output buffer: This buffer is the portion of memory dedicated to the allocation of the entity creation requests, plus that of the serialized topic in the case of publishers. Therefore, in this case its size will be equal to the maximum between these values, whereas in the case of a subscriber application it will equal the size of the created entity. Notice that the entity creation consumption critically depends on the creation mode.  Input buffer: This buffer is used by subscriber applications to store data coming from the Agent, and by publishers in the case of reliable communication, to receive confirmation that all the information has been correctly received by the Agent.  Transport buffer: This is equal to the MTU, fixed to 512 B in the present analysis.  Stack usage: The stack is the memory consumed by the functions used by the program, when executing. Whilst the memory consumed by the buffers above, all stored in static memory, can be straightforwardly calculated by just analyzing the compiled binary objects, the stack is the chunk of memory we cannot know before running our application. In order to measure it, we make use of the FreeRTOS uxTaskGetStackHighWaterMark() funcion. This function returns the amount of stack that remained unused when the XRCE-DDS task stack was at its greatest value. By subtracting this value to the total stack available (which is known), we thus obtain the stack peak used by our XRCE-DDS app.  Fig. 1: Illustrative diagram of the memory partition in the XRCE-DDS Client library. Summarizing, we calculate the total memory usage of our XRCE-DDS app as the sum of the static memory used (which will in general be of the size of the output/input buffers plus the transport buffer) and of the stack used, calculated by means of the uxTaskGetStackHighWaterMark() function provided by FreeRTOS. Results and Discussion:  Publishers  Fig. 2: Memory usage (in Bytes) of the XRCE-DDS Client as a function of topic size (in Bytes) and publishers number.  Subscribers  Fig. 3: Memory usage (in Bytes) of the XRCE-DDS Client as a function of topic size (in Bytes) and subscribers number. As it comes to light from these plots, no significant variability is shown among the instances considered. As for the publishers, all four cases follow the same trend. Notice that both for publishers and subscribers the curves are flat for small enough topic sizes (&lt; 400 kB) when creation of entities happens by XML. Indeed, in these cases the size of the output buffer is determined by the buffer size needed for entities’ creation, and it only changes when the topic size exceeds that required by entities’ creation. Publishers/subscribers number is seen to not affect the measurements. This is expected for this specific experimental set-up because just one topic at a time is sent/received, and therefore the number of topics doesn’t enter the overall memory consumption. Notice however that, under a different configuration in which multiple topics are sent or received at the same time, the size of the memory buffer would grow accordingly. The difference observable between the publishers and subscribers’ memory footprint is due to the fact that a subscriber always needs two static-memory buffers: an output buffer to write and send subscription requests, and an input buffer to store the response to those requests, that is, the data coming from the Agent. Memory Profiling of the Micro XRCE-DDS Agent on Linux: The Micro XRCE-DDS Agent is at the moment only supported by standard Operating Systems such as Linux, Windows and Mac. However, more and more users are beginning to show an interest to port the Agent to a MCU, and compiling it on top of an RTOS. Since this task hasn’t been carried out yet, as a first step towards the exploration of such a scenario we have performed an analysis of the memory footprint of a lightweight version of the Agent on Linux. Available Middleware Implementations for the Agent: The Agent counts with three middleware implementations: FastMiddleware, FastDDSMiddleware and CedMiddleware (refer to this link in order to learn more). The FastMiddleware and FastDDSMiddleware use respectively eProsima Fast RTPS and eProsima Fast DDS, Cpp implementations of the RTPS (Real Time Publish Subscribe) protocol and of the DDS standard. These middlewares allow the Client to produce and consume data in the DDS Global Data Space. These Agents have the default behaviour described in the DDS-XRCE standard, that is, for each DDS-XRCE entity a DDS proxy entity is created, and the writing/reading actions produce publishing/subscribing operations in DDS. On the other hand, the CedMiddleware (Centralized Middleware) makes use of the Agent as a broker, that accepts connections and messages published from Clients, processes subscribe/unsubscribe requests, forwards messages that match other Clients’ subscriptions, and closes Clients’ connections. This Agent is much more lightweight than those with output to DDS, and is therefore the appropriate candidate for assessing the memory consumption of the lightest possible version of an Agent that could mediate a pseudo-p2p communication among Clients. Methodology and Results: We have investigated the memory consumption of an Agent communicating with a mock Client application on Linux that is publishing and subscribing to topics of known size. We have measured on the one hand the binary size of the compiled Agent, and then analyzed its heap and stack usage. For the latter, the number of pub/sub pairs has been varied from 1 to 32, with a single topic associated with each pair, and the topic size has been varied too, from 8 to 256 B. The binary size of the compiled Agent resulted to be 385 KB. As for the RAM memory, the tool that has been used for establishing the CedMiddleware memory footprint is Valgrind, an instrumentation framework for building dynamic analysis tools. Specifically, we made use of Massif, a memory profiler which measures how much heap and stack memory a program uses. The reported measurements correspond to the memory peak resulting from the analysis provided by this tool. The total heap + stack consumption is plotted as a function of the topic size and number below.   Fig. 4: Memory usage (in KiloBytes) of the XRCE-DDS Agent as a function of topic size (in Bytes) and topics number. We see from these results that for applications that involve around 10-15 pub/sub pairs (and equal number of topics), the memory consumption of the Agent could be compatible with cross-compilation and later execution into a mid-to-high range MCU with RAM memory on the order of ~ 300-400 KB and flash of less than 500 KB. This preliminary analysis therefore paves the way for the possibility to port the Ced Agent to RTOSes such as those already supported by the XRCE-DDS Client (Zephyr, NuttX and FreeRTOS) and thus bringing this component of the library to resource-constrained systems, as well. We mention that, to date, both the FastDDSMiddleware and the CedMiddleware Agents have been successfully ported to Raspberry Pis (RPis) on both Ubuntu and Raspbian and that several micro-ROS use-cases and demos already function with the Agent on a RPi. "
        }, {
        "id": 104,
        "url": "https://micro-ros.github.io//docs/concepts/middleware/rosserial/",
        "title": "Micro XRCE-DDS compared to rosserial",
        "body": " - In ROS, there is a package that stands out when we want to send ROS messages through serial communications. This package is rosserial. rosserial allows platforms based on microcontrollers to communicate with a regular computer communicating with ROS network on its behalf. rosserial provides the protocol to set such communication, using a client-server architecture approach. rosserial-clients serialise data into the serial link, then, the serialised data is received by the rosserial-server and forwarded to the conventional ROS network. An analogous process is done to forward data from the ROS network towards the microcontroller. This rosserial-server can be used either in C++ or Python; meanwhile, the rosserial-client has a set of available supported microprocessors. This solution is commonly used to integrate hardware pieces within Robots using ROS. Rosserial, in those cases, acts as a bridge between hardware communication protocols and a ROS network. Micro XRCE-DDS: One of the capabilities of Micro XRCE-DDS is the use of serial connection between a microcontroller and a DDS/ROS 2 capable computer. Such a connection is possible thanks to the use of OMG’s DDS-XRCE standard and a serial transport layer. This solution follows the same client-server architecture as rosserial, which it is one of the most suitable approaches when we speak of microcontroller communications. The libraries in charge of implementing this architecture are the Client and the Agent. Clients generate entities within the Agent which will act on behalf of the Clients on a DDS network. This usage, as you can see, resembles the one used by rosserial, but they have subtle differences in their implementations which we will expose in this article. Micro XRCE-DDS vs rosserial: Now that we have a basic understanding of rosserial and Micro XRCE-DDS we will provide a comparison between them. Micro XRCE-DDS over Serial Transport: Micro XRCE-DDS, when communicating over serial transports (it allows communications over other transports such as UDP, TCP …), uses a serial protocol with a predefined format. This format is explained in the following frame dissection: 0    8    16    24        40         X         X+16+--------+--------+--------+--------+--------+--------//--------+--------+--------+| FLAG  | SADD | RADD |    LEN    |   PAYLOAD   |    CRC    |+--------+--------+--------+--------+--------+--------//--------|--------+--------+ FLAG: synchronization flag (0xFF).  SADD: source address.  RADD: remote address.  LEN: payload length without framing (2 bytes in little-endian).  PAYLOAD: serialised message with XRCE headers.  CRC: message CRC after stuffing. This is the message that is serialised on the link layer. This is the message going from an towards the microcontroller thanks to two different operations: publish and subscribe. rosserial: In contrast, this is the rosserial frame: 0    8    16       32       40   56        X       X+16+-------+-------+-------+-------+-------+-------+-------+-------//-------+------+------+| FLAG | PROT |   LEN   |   LCRC   | TOPID |   PAYLOAD  |   MCRC  |+-------+-------+-------+-------+-------+-------+-------+-------//-------|------+------+ FLAG: synchronization flag (0xFF).  PROT: protocol version.  LEN: payload length (2 bytes in little-endian).  LCRC: length CRC.  TOPID: topic ID.  PAYLOAD: serialised message.  MCRC: message CRC. As you can see comparing with the Micro XRCE-DDS serial frame, it uses a completely different frame. Comparison: The following table, summarises the key aspects of both implmentations:           Micro XRCE-DDS serial   rosserial         API   C/C++   C++       integrity   HDLC framing   none       security   CRC-16-CCITT   vague CRC (% 256)       memcopy   uxr_stream —&gt; serial_buffer —&gt; hardware_buffer   serialization_buffer —&gt; hardware_buffer       memory usage   uxr_stream + (2 * aux-buffer[42 B])   2 * serialization_buffer       message size limit   uxr_stream size   hardware_buffer size       reliability   yes   no       routing   yes   no       overhead   7 B + 12 B*   9 B       architecture   client-server   client-server   * Overhead is divided between framing, 7 B and that added by DDS-XRCE protocol 12 B. As exposed in this table, Micro XRCE-DDS serial increases the number of memory operations but reduces in a great way the memory required for serial communications as it does not require that the hardware buffer has the same size as the serialisation buffer. This use of buffers reduces memory usage. Also, Micro XRCE-DDS serial provides routing and reliability capabilities in contrast with rosserial. The DDS-XRCE protocol embraces standards for some of its parts, like the usage of standard CRC or a standard framing. "
        }, {
        "id": 105,
        "url": "https://micro-ros.github.io//docs/concepts/rtos/comparison/",
        "title": "Comparison between RTOSes",
        "body": " - In this section, we present a techincal comparison between the three RTOSes supported by micro-ROS:  NuttX FreeRTOS ZephyrThe comparison regards the features listed below:  Standardized API to application level Maturity Supported hardware Scheduling options IO Support (native or vendor-specific module needed) Networking stack Storage and Display Memory Footprint Safety Certification License POSIX level supportKey questions:  Evaluation POSIX-compliance of RTOS.  What is the effort in providing an additional layer for non-POSIX RTOS regarding micro-ROS or ROS 2? Support of RTOS for specific HW platformsTable of Comparisons:       OS   NuttX   FreeRTOS   Zephyr         Feature                   Standardization                   POSIX   yes   partial   partial       POSIX. 1 1   yes   wrapper   partial       POSIX. 1b 2   yes   partial   partial       POSIX. 1c 3   yes   yes   partial                           OSEK/VDX   no   no   no       Maturity                   First release   2007   2003   2016       Last release   2019   2020   2019       Update rate   about 3 months   irregular   3 months       Community   open-source   open-source   Linux Foundation Collaboration Project, (Intel, Linaro (ARM), nordic, NXP, Synopsys)                           Supported Hardware                   Olimex STM32-E407 (Cortex-M4)   yes   yes   yes, explicitly       Bosch XDK 5   not explicitly, but similar 6   yes   no5       MPC57xx   no   no   no       Scheduling                   Priority-based   FIFO   yes   yes       Round-Robin 4   yes   yes 6   co-operative       Sporadic Server   yes   no   no       Reservation Based Scheduling (RBS)   no   no   no       Rate Monotonic Scheduling (RMS)   ?   yes 10   yes 10       Semaphore /Mutex Management   yes (Priority Inheritance)   yes   yes       IO                   I2C   yes   yes 8   yes       SPI   yes   yes 8   yes       UART   hw-specific   yes 8   yes       USB   yes   vendor-specific   yes       CAN   yes   vendor-specific   yes       CAnopen   no   vendor-specific   yes       Modbus   yes   vendor-specific   ?       Networking 7                   BLE-Stack   unclear   yes 8   yes       6LoWPAN   yes   no   yes       TLS       yes 8   yes       Thread       no   ?       Ethernet   yes   yes 8   yes       Wifi   yes   yes 8   yes       NFC   unclear   no   yes       RFID   yes   no   yes       Storage &amp; Display 7                   File System   yes   yes   yes       Graphical User Interface       vendor-specific   ?       Memory Footprint                   RAM   “small footprint”   236 B scheduler + 64 B / task   “small footprint”       ROM   “small footprint”   5 - 10 kB   “small footprint”       Safety Certification                   Software Development Process DO178B Level A / EUROCAE ED-12B   no   SafeRTOS: DO178C (Aerspace) by Wittenstein   no       Functional Safety IEC-61508   no   SafeRTOS (SIL 3)   soon       License   BSD   MIT and Commercial   Apache 2   1 Processes, signals, fpe, segmentation, bus errors, timers, file and directory ops, pipes, c library, IO Port Interface 2 Real-time, clocks, semaphores, messages, shared mem, async io, memory locking. 3 Threads. 4 Executing every task in round-robin fashion but only for a pre-defined time slice. 5 XDK is based on a microcontroller of the ARM Cortex M3 EFM32GG390F1024 Giant Gecko family by Silicon Labs. Note that the version used in the XDK is not fully supported by Zephyr. 6 Note: Time slicing 7 Hardware-support for Networking and Storage often depends on the platform and sometimes packages of hardware-vendors are available, which work for a particular operating system. But it is in general difficult to determine the harware-support of a given RTOS. 8 FreeRTOS interfaces that are provided through theFreeRTOS reference distribution repository at https://github. com/aws/amazon-freertos 9 FreeRTOS ethernet support is provided through the FreeRTOS+TCP stack. 10 Rate Monotonic Scheduling can be achieved by assigning the priorities of threads with the so-called rate-monotonic policy. That is, the thread with the highest rate has the highest priority and the thread with the lowest rate the lowest priority. It is assumed that all threads are activated periodically with fixed rates. Some Related Work:  Choosing the right RTOS for IoT platform, Milinkovic et al, INFOTEH-JAHORINA Vol. 14, 2015: comparison of FreeRTOS, ChibiOS/RT, Erika, RIOT FreeRTOS Architecture"
        }, {
        "id": 106,
        "url": "https://micro-ros.github.io//docs/concepts/rtos/",
        "title": "Why a Real-Time Operating System?",
        "body": " - The use of Real-Time Operating Systems (RTOSes) is a general practice in nowadays embedded systems. These systems typically consist of a resource-constrained microcontroller that executes an application which requires an interaction with external components. In many cases, this application contains a time-critical task where a strict time deadline or deterministic response is required. Bare-metal applications are also used nowadays, but require very low-level programming skills and lack of the hardware abstraction layers that RTOSes offers. On the other hand, RTOSes typically use hardware abstraction layers (HAL) that ease the use of hardware resources, such us timers and communication buses, lightening the development and allowing the reuse of code. In addition, they offer threads and tasks entities which, together with the use of schedulers, provide the necessary tools to implement determinism in the applications. The scheduling consists of different algorithms, among which users can choose the ones that better fits their applications. Another feature that RTOSes normally offer is the stack management, helping in the correct memory usage of the MCU resources, a valuable good in embedded systems. RTOS in micro-ROS: Due to the benefits presented above, micro-ROS integrates RTOSes in its software stack. This enhances the capabilities of micro-ROS and allows reusing all the tools and functions provided by the RTOSes. As the micro-ROS software stack is modular, the exchange of software entities is expected and desired at all levels, including the RTOS layer. Like the Operating Systems (OSes) available for computers, the RTOSes also have different support for standard interfaces. This is established in a family of standards named POSIX. As we aim to port or reuse code of ROS 2 that was natively coded in Linux (a mostly POSIX-compliant OS), the use of RTOSes that comply with these standards is beneficial, as the porting effort of the code is minimal. Both NuttX and Zephyr comply to a good degree with POSIX standards, making the porting effort minimal, whereas FreeRTOS provides a plugin, FreeRTOS+POSIX, thanks to which an existing POSIX compliant application can be easily ported to FreeRTOS ecosystem, and therefore leverage all its functionality. Notice that calls to the RTOS functions are made by several abstraction layers in the micro-ROS stack. The main layer using the RTOS primitives is the middleware. Indeed, it requires accessing the transport resources (serial, UDP or 6LoWPAN communications for example) and the time resources of the RTOS in order to operate properly. In addition, it is desirable that the micro-ROS client libraries (rcl, rclc) have also access to RTOS resources in order to handle mechanisms such as scheduling or power management. In this way, the developer can optimize the application at various levels. At present, micro-ROS supports three RTOSes, which all come with (basic) POSIX implementations: FreeRTOS, Zephyr and NuttX, all of them integrated into the micro-ROS build system. By clicking on the logos below, you’ll be redirected to the Overview section, where the most relevant aspects and key features of each RTOS are presented.   FreeRTOS Zephyr NuttX A thorough technical comparison between these RTOSes can be found here. Disclaimer: All logos and product names are property of their respective owners. All company names, logos and product names used in this website are for identification purposes only. Their use does not imply endorsement. "
        }, {
        "id": 107,
        "url": "https://micro-ros.github.io//docs/imprint",
        "title": "Imprint",
        "body": " - Published by:eProsima, Plaza de la Encina 10-11 Nucleo 4 2ª Planta, 28760 Tres Cantos, Madrid, Spain. E-mail: info@eprosima. com Telephone: +34 918043448 Represented by the CEO:Jaime Martin Losa. Edited by:Members of the EU project OFERA:  eProsima.  Robert Bosch GmbH.  ŁUKASIEWICZ - Instytut PIAP.  FIWARE Foundation. DisclaimerThe editors made an effort to ensure that the content of this web site is kept up to date, keeping it accurate and complete. Nevertheless, errors can be present. The editors and publisher(s) do not give any warranty in terms of the accuracy or completeness of material on this web site and disclaim all liability for loss or damage incurred derived from the use of content obtained from this web. The publisher neither the editors can assume any liability for the content of external pages. The owner of those external pages, in the case, is the sole responsible for their content. Registered trademarks and copyrighted text and images are not (generally) indicated as such on this web site content. The absence of such indications in no way implies that these names, images or text belong to the public domain, their original ownership is keeped untouched. "
        }, {
        "id": 108,
        "url": "https://micro-ros.github.io//docs/overview/ROS_2_feature_comparison/",
        "title": "ROS 2 Feature Comparison",
        "body": " - Comparison of micro-ROS features with ROS 2 features. The following list has been compiled from https://index. ros. org/doc/ros2/Features/ and https://index. ros. org/doc/ros2/Roadmap/, and the features have been organized into sub-tables according to the macrocategories defined in the Features and Architecture page. Microcontroller-optimized client API supporting all major ROS concepts:       ROS 2 Feature       Availability in micro-ROS         Common core client library that is wrapped by language-specific libraries   ✓∘   Use of the client support library rcl from ROS 2 as-is. The rclc package provides convenience functions and an executor for use of rcl+rclc as client library for the C programming language. Roadmap: migrate all functionalities to the rclc, so as to make it an independent abstraction layer on top of the rcl that serves as user’s API.        Composition of node components at compile-, link- or dlopen-time   ✓   Composition at compile-time only. Composition at runtime would depend highly on the RTOS.        Support for nodes with managed lifecycles   ✓   The rclc_lifecycle package provides an rclc_lifecycle_node type which bundles an rcl node with the lifecycle state machine as well as corresponding convenience functions.        Utilities for handling types and topics memory statically and dynamically   ✓   The micro_ros_utilities provides an API for handling types memory using micro-ROS allocators or static memory pools.    Seamless integration with ROS 2:       ROS 2 Feature       Availability in micro-ROS         Publish/subscribe over topics   ✓   Available, but only fixed-size message types supported to avoid dynamic memory allocations.        Clients and services   ✓   Available, but only fixed-size message types supported to avoid dynamic memory allocations.        ROS 1 – ROS 2 communication bridge   ✓   Standard ROS 1 – ROS 2 bridge or SOSS-mediate bridge can be used via micro-ROS Agent to communicate with micro-ROS nodes.        Actions   ∘   To be implemented soon in rclc.        Parameters   ✓∘   Parameter server is implemented in micro-ROS Client. Parameter client is not available yet.        Node Graph   ✓   Available as in ROS 2.        Discovery   ✓+   Discovery between entities available as in ROS 2. Further discovery mechanism available for the Clients to discover Agents on the network.        Inter- and intra-process communication using the same API   ✓∘   Shared-memory interprocess communication on the MCU is available in micro-ROS client. Also the middleware can implement thread-safe operation.        Command-line introspection tools using an extensible framework   ✓   Thanks to graph support, standard ROS 2 tools can be used to introspect the topology of the ROS 2 dataspace, via the Agent, from a microprocessor running a micro-ROS node . At the same time, standard ROS 2 nodes can fetch information regarding the micro-ROS entities present on the network.        Launch system for coordinating multiple nodes   ₋   No launch system for the micro-ROS nodes on an MCU available. Such a system would depend highly on the RTOS. The system-modes concept developed with micro-ROS allows runtime configuration/orchestration of ROS 2 and micro-ROS nodes together.        Namespace support for nodes and topics   ✓   Available as in ROS 2.        Static remapping of ROS names   ∗   Should be available if passed as argument via standard rcl API – to be checked.        Support of rate and sleep with system clock   ∗   rcl timers use POSIX API. Tested successfully on NuttX, but the resolution is very low. A higher resolution could be achieved with hardware timers – which highly depends on the MCU and possibly the RTOS. This feature requires further investigation.        Support for simulation time   ∗   Might be supported out of the box, but needs to be checked. We consider HIL setups with simulation time to be corner cases.    Extremely resource-constrained but flexible middleware:       ROS 2 Feature       Availability in micro-ROS         Transport and serialization over DDS-XRCE and DDS   ✓+   Available transports: UDP, serial (UART) and custom transports as enabled by Micro XRCE-DDS. Serialization between Client and Agent provided by Micro-CDR and between Agent to standard DDS by Fast-CDR.        Support for multiple DDS implementations, chosen at runtime   ✓   Support via the Micro XRCE-DDS Agent is possible in principle, but at compile-time only.        Quality of service settings for handling non-ideal networks   ✓+   For communication over the DDS-XRCE wire protocol, two QoS semantics, reliable and best-effort, are provided and can be set at compile-time. As for communication with the ROS 2 dataspace, micro-ROS entities can benefit from the whole set of QoS allowed by DDS when created by Reference.        DDS-Security support   ✓-   Security is not yet supported in the communication process between the Client and the Agent. However, the micro-ROS Agent can benefit from Fast DDS security capabilities during the creation of DDS entities. Roadmap: Implementation of security mechanisms in Micro XRCE-DDS are planned for future releases.        IDL   ✓+   micro-ROS supports the same IDL types as ROS 2. Generation of C code from IDLs as handled by the Client is performed by the Micro-XRCE-DDS-Gen library, whereas generation of the C++ types handled by the Agent is handled by Fast-DDS-Gen.        Logging   ∗   Could be available as part of the standard logging mechanism in principle but not supported by Micro-XRCE-DDS due to dynamic message size. To be checked …   Multi-RTOS support with generic build system:       Feature       Availability in micro-ROS         Build system   ✓   micro-ROS provides two ways of building a micro-ROS application. The first uses the micro_ros_setup tool integrated in a ROS 2 workspace. With this approach, the build systems of NuttX, FreeRTOS, and Zephyr are integrated with colcon. The other provides micro-ROS as a component for external development frameworks (e. g. , ESP-IDF and Zephyr build system).        Supported hardware   ✓   micro-ROS officially supports four boards. For the moment, all official ports are based on the STM32 series from ST and on the ESP32 from Espressif. Find more info here. More ports have been carried out by users, check the complete list.        Supported Operating Systems   ✓   micro-ROS is supported by the RTOSes FreeRTOS, Zephyr, NuttX, in addition to Linux and Windows.    micro-ROS specific features:       Feature       Availability in micro-ROS         Demos of an all-ROS 2 mobile robot   ✓   Demos of several ROS 2 + micro-ROS robots available. See https://micro-ros. github. io/docs/tutorials/demos/.        Support for real-time code   ✓   Real-time behaviour is key to micro-ROS typical usages. The rclc Executor provides mechanisms for implementing real-time-critical applications. At lower levels, the Micro XRCE-DDS library exhibits real-timeness and determinism for being dynamic memory free and for providing functions to perform tasks within well-defined periods of time.        Support for “bare-metal” microcontrollers   ✓   Bringing ROS 2 onto MCUs is all that micro-ROS is about. The standard approach to micro-ROS assumes an RTOS underneath (e. g. , FreeRTOS, Zephyr, or NuttX). Recent developments aim at loosening this requirement, with the integration into Arduino IDE being a first step towards true micro-ROS bare-metal support.        Continuous Integration   ✓∘   Currently, the CI for micro-ROS is distributed to GitHub and GitLab. Until the end of 2020, all CI should be moved migrated completely to the new CI actions of GitHub. Please note that those packages that are released for standard ROS 2 are also built and tested on build. ros2. org.        Documentation   ✓   High-level documentation at micro-ros. github. io. For detailed information please consult the README. md files in the relevant micro-ROS repositories at github. com/micro-ROS/. For information on the middleware implementation, take a look at the Micro XRCE-DDS documentation.        Peer-to-peer functionality   ✓∘   Prototypical peer-to-peer functionality implemented over broadcast. No QoS available for the moment. Roadmap: improve prototype to achieve true point-to-point connection.        Memory footprint   ✓   A comprehensive profiling of the memory consumption of typical micro-ROS applications can be found here.    Below, you can find the legend of the symbols used in the tables above.       Symbols legend             ✓   Available.        ✓+   Available both on Agent-DDS and Client-Agent sides of the communication.        ✓-   Available on Agent-DDS side of the communication but not on Client-Agent side.        ✓∘   Available with some WIP feature.        ∘   To be implemented soon.        ∗   Further investigation required.        ₋   Currently unavailable.    "
        }, {
        "id": 109,
        "url": "https://micro-ros.github.io//docs/overview/comparison/",
        "title": "Comparison to related approaches",
        "body": " - Micro-ROS brings ROS 2 to microcontrollers. Here, we perform an analysis of the related approaches and eventually show a comparison table. ROSSerial: ROSSerial is a protocol for wrapping standard ROS serialized messages and multiplexing multiple topics and services over a device such as a serial port or network socket. In addition to a protocol definition, there are three types of packages found in this suite:    Client Libraries: Client libraries allow users to easily get ROS nodes up and running on various systems. These clients are ports of the general ANSI C++ rosserial_client library.     ROS-side Interfaces: These packages provide a node for the host machine to bridge the connection from the rosserial protocol to the more general ROS network.     Examples and Use Cases.  It is worth saying that this option cannot be fully compared with micro-ROS because this approach is meant to work with ROS 1, instead of micro-ROS which is focused on ROS 2. Reference: ROSserial Wiki RIOT-ROS2: RIOT-ROS2 is a modification of the main ROS 2 stack, to make it able to run on microcontrollers thanks to the RIOT Operating System. ROS 2 is composed of several layers. Some have been modified to be able to run on the microcontroller, this is a list of the available layers for RIOS-ROS2 project:  ROS Client Library bindings: RCLC ROS Client Library: RCL ROS MiddleWare: rmw_ndn ROS IDL Generators: generator_c ROS IDL Type Support: CBOR ROS IDL Interfaces:     common_interfaces   rcl_interfaces   As a final data, it looks like the development is frozen. This consideration is due to the fact that the last commit goes back to July 2018. Reference:RIOT-ROS2 Comparation table:           rosserial   RIOT-ROS2   micro-ROS         OS   bare-metal   RIOT   NuttX, FreeRTOS and Zephyr       Communications architecture   Bridged   N/A   Bridged       Message format   ROS1   N/A   CDR (from DDS)       Communication links   UART   UART   UART, SPI, IP (UDP), 6LowPAN, …       Communication protocol   Custom   NDN   XRCE-DDS (or any rmw implementation)       Code Base   Independent implementation   Standard ROS 2 stack up to RCL   Standard ROS 2 stack up to RCL (RCLCPP coming)       Node API   Custom rosserial API   RCL,RCLC   RCL (soon RCLCPP)       Callback execution   Sequential, in order of messages   N/A   Choice of ROS 2 executors or MCU optimized executors       Timers   Not included   Not included   Normal ROS 2 timers       Time sync to host   Custom   N/A   NTP/PTP       Lifecycle   Not supported   Partial   Partial, full coming   "
        }, {
        "id": 110,
        "url": "https://micro-ros.github.io//docs/overview/docker_ci_status/",
        "title": "Repositories, dockers and CI status",
        "body": " - Tooling Status:       Repository   Description   CI   Issues / Pull Requests   Documentation         micro-ros-setup    Micro-ROS tool to build and flash Micro-ROS to every supported platform                 micro-ros-espidf-component    Component to used Micro-ROS in ESP IDF build system                 micro-ros-arduino    Micro-ROS precompiled libraries to directly interface with the Arduino IDE                 micro-ros-zephyr-module    Integration of micro-ROS within Zephyr West build system                 micro_ros_raspberrypi_pico_sdk    Integration of micro-ROS within Raspberry PI Pico SDK                 micro_ros_mbed    Integration of micro-ROS within Mbed RTOS                 micro_ros_nuttx_app    Integration of micro-ROS within Nuttx 10                 micro_ros_stm32cubemx_utils    Integration of micro-ROS within STM32CubeMX and STM32CubeIDE                 NuttX fork   NuttX fork to use with micro-ROS. Current status is discontinued             Source Code Repositories Status: Most repositories can be found in GitHub’s micro-ROS organization at github. com/micro-ROS/.       Repository   Description   CI   Issues / Pull Requests   Documentation         Micro XRCE-DDS Client    Client C99 library of eProsima’s open-source implementation of DDS-XRCE                 Micro XRCE-DDS Agent    Agent (bridge to DDS) C++11 library of eProsima’s open-source implementation of DDS-XRCE                 rmw-microxrcedds    ROS 2 RMW adapter for Micro-XRCE-DDS Client library                 rosidl-typesupport-microxrcedds    ROS 2 type support for Micro-XRCE-DDS Client library                 micro-ROS-Agent     Agent (bridge) to ROS 2                 micro-ros-msgs    Specific ROS 2 messages used within micro-ROS architecture                 micro_ros_utilities    micro-ROS utilities for embedded applications                 system_modes    Extension for rclcpp                 rclc     Set of convenience functions and additional concepts, such as executor, to extend the capabilities of ROS 2 rcl in C             Example Application Repositories Status:       Name   Description   CI   Issues / Pull Requests   Documentation         micro-ROS-demos    Collection of generic demos, using publishers, subscribers, custom messages, services and graph introspection                 freertos_apps    Demo applications for FreeRTOS                 zephyr_apps    Demo applications for Zephyr                 raspbian_apps    Demo applications for Raspbian                 nuttx_apps    Demo applications for NuttX (discontinued)                 Kobuki demo   Kobuki (Turtlebot 2) controller demo application using micro-ROS in an Olimex board over NuttX                 Crazyflie demo    Crazyflie drone demo application using micro-ROS over FreeRTOS             Docker Images Status:       Image   Description   Status         base   Base image with a ROS 2 Foxy installation + micro-ROS specific build system tools. Used as base of any other micro-ROS image          micro-ros-agent   Image containing a pre-compiled micro-ROS-Agent, ready to use as a standalone application          micro-ros-demos   Contains pre-compiled micro-ROS demo applications, ready to use to get a taste of micro-ROS capabilities          micro-ros-olimex-nuttx   Contains a ready to flash example for Olimex STM32 E407          micro_ros_static_library_builder   Allows to use a pre-compiled micro-ROS library to develop applications using Arduino IDE          esp-idf-microros   Allows to use micro-ROS as a component of the ESP-IDF build system      Webpage Source Code Repository Status:       Repository   Description   CI   Issues   Pull Requests         micro-ROS. github. io   Micro-ROS official webpage repository.             Bloom Release Status of Code Repository ros2/rclc: Bloom release status of packages in repository github. com/ros2/rclc/ for different architectures and releases.       Package   Release   amd64   arm64   armhf         rclc   Dashing                    Eloquent                    Foxy                     Galactic                     Rolling                                         rclc_examples   Dashing                    Eloquent                    Foxy                     Galactic                     Rolling                                         rclc_lifecycle   Dashing                    Eloquent                    Foxy                     Rolling             "
        }, {
        "id": 111,
        "url": "https://micro-ros.github.io//docs/overview/ext_tools/",
        "title": "Integration into External Tools",
        "body": " - micro-ROS aims to bring ROS 2 to microcontrollers to allow having first-class ROS 2 entities in the embedded world. One of the approaches offered by micro-ROS to build an application for embedded platforms consists in a ROS-specific build system comprising modules which integrate the software for cross-compiling said apps on the supported plaforms, both hardware and firmware-wise. A different approach consists in generating standalone modules and components allowing to integrate micro-ROS into external or custom development frameworks, made possible by a tool dedicated to compiling micro-ROS as a standalone library. The configuration of the generated micro-ROS libraries is based on a colcon. meta file. The modules that exist up to date for integrating into external build systems are the following: micro-ROS component for the ESP-IDF:        ESP-IDF is the official development framework for the ESP32, ESP32-S and ESP32-C Series SoCs.     To date, it has been tested in ESP-IDF v4. 1 and v4. 2 with ESP32 and ESP32-S2.     The micro-ROS component for the ESP-IDF allows the user to integrate the micro-ROS API and utilities in an already created ESP-IDF project just by cloning or copying a folder.     The current ports support Serial (UART),    WiFi, and Ethernet.     Resources:          micro-ROS component for ESP-IDF on GitHub      ESP-IDF on GitHub      ESP-IDF docs             micro-ROS module for the Zephyr build system:        Zephyr is a scalable RTOS built with security in mind, and based on a small-footprint kernel designed for use on resource-constrained systems.     The Zephyr kernel supports multiple hardware architectures, including ARM Cortex-M, Intel x86, ARC, Nios II, Tensilica Xtensa, and RISC-V, and can count with large number of supported boards.     The micro-ROS module for Zephyr allows to integrate the micro-ROS API and utilities in an existing Zephyr-based project just by cloning or copying a folder.     Resources:          micro-ROS module for Zephyr build system on GitHub      Primary GitHub repository for the Zephyr Project      Zephyr Project official webpage             micro-ROS for Arduino:        Arduino is an open-source platform based on an I/O board and a development environment that implements the Processing/Wiring language, intended to enable users to easily generate interactive projects. A CLI is also offered, which aims to be an all-in-one solution providing the tools needed to use any Arduino compatible platform from the command line.     The micro-ROS for Arduino support package is a special bare-metal port of micro-ROS provided as a set of precompiled libraries for specific platforms.     Resources:          micro-ROS for Arduino on GitHub      Arduino IDE on GitHub      Arduino CLI on GitHub      Arduino official website           micro-ROS for STM32CubeMX:        The STM32CubeMX is a graphical tool by ST for configuring STM32 microcontrollers and microprocessors. It enables to optimally program and manipulate the software thanks to a set of utilities that help setting up pinouts, peripherals, and middleware stacks.     micro-ROS for STM32CubeMX is based on a Dockerfile and allows micro-ROS to be virtually supported by the full set of boards offered by STMicroelectronics, in turn enabling the seamless integration of micro-ROS into any STM32 controller based project.     Resources:          micro-ROS for STM32CubeMX on GitHub      STMicroelectronics official webpage      STMicroelectronics official webpage           Disclaimer: All logos and product names are property of their respective owners. All company names, logos and product names used in this website are for identification purposes only. Their use does not imply endorsement. "
        }, {
        "id": 112,
        "url": "https://micro-ros.github.io//docs/overview/features/",
        "title": "Features and Architecture",
        "body": " - Micro-ROS offers seven key features that make it ready for use in your microcontroller-based robotic project: &#10004; Microcontroller-optimized client API supporting all major ROS concepts (. . . )  Micro-ROS brings all major core concepts such as nodes, publish/subscribe, client/service, node graph, lifecycle, etc. onto microcontrollers (MCU). The client API of micro-ROS (in the C programming language) is based on the standard ROS 2 Client Support Library (rcl) and a set of extensions and convenience functions (rclc).  The combination rcl+rclc is optimized for MCUs. After an initialization phase, it can be used without any dynamic memory allocations. The rclc package provides advanced execution mechanisms allowing implementing well-proven scheduling patterns from embedded systems engineering.  &#10004; Seamless integration with ROS 2 (. . . )  The micro-ROS agent connects micro-ROS nodes (i. e. components) on MCUs seamlessly with standard ROS 2 systems. This allows accessing micro-ROS nodes with the known ROS 2 tools and APIs just as normal ROS nodes.  &#10004; Extremely resource-constrained but flexible middleware (. . . )  Micro XRCE-DDS by eProsima meets all requirements for a middleware for deeply embedded systems. That is why micro-ROS has been one of the applications for this implementation of the new DDS for Extremely Resource Constrained Environments (XRCE) standard. For the integration with the ROS middleware interface (rmw) in the micro-ROS stack, static memory pools were introduced to avoid dynamic memory allocations at runtime.  The middleware comes with built-in support for serial transports, UDP over Ethernet, Wi-Fi, and 6LoWPAN, and Bluetooth. Furthermore, the Micro XRCE-DDS source code provides templates for implementing support for further transports.  &#10004; Multi-RTOS support with generic build system (. . . )  Micro-ROS supports three popular open-source real-time operating sytems (RTOS): FreeRTOS, Zephyr, and NuttX. It can be ported on any RTOS that comes with a POSIX interface.  The RTOS-specific build systems are integrated into few generic setup scripts, which are provided as a ROS 2 package. Therefore, ROS developers can use their usual command line tools. In addition, micro-ROS provides selected integrations with RTOS-specific tool chains (e. g. , for ESP-IDF and Zephyr).  &#10004; Permissive license (. . . )  Micro-ROS comes under the same permissive license as ROS 2, which is Apache License 2. 0. This applies to the micro-ROS client library, the middleware layer, and tools.  When creating a project with an underlying RTOS, please take into account the license(s) of the RTOS project or vendor as further explained on the license page.  &#10004; Vibrant community and ecosystem (. . . )  Micro-ROS is developed by a constantly growing, self-organized community backed by the Embedded Working Group, a formal ROS 2 Working Group. The community shares entry level tutorials, provides support via Slack and GitHub, and meets in public Working Group video-calls on a monthly basis. As a matter of course, commercial support is provided for the Micro XRCE-DDS by eProsima.  This community also create tools around micro-ROS. For example, to optimize micro-ROS-based applications to the MCU hardware, specific benchmarking tools have been developed. These allow checking memory usage, CPU time consumption and general performance.  &#10004; Long-term maintainability and interoperability (. . . )  Micro-ROS is made up of well-established components: Famous open-source RTOSs, a standardized middleware, and the standard ROS 2 Client Support Library (rcl). In this way, the amount of micro-ROS-specific code was minimized for long-term maintainability. At the same time, the micro-ROS stack preserves the modularity of the standard ROS 2 stack. Micro-ROS can be used with a custom middleware layer - and thus standard - or a custom ROS client library.  Furthermore, by the System-Of-Systems Synthesizer (SOSS), a fast and lightweight OMG DDS-XTYPES standard integration tool, further middleware protocols can be connected. For example, we have developed the SOSS-FIWARE and SOSS-ROS2 System-Handles, which connect ROS 2 and micro-ROS with the FIWARE Context Broker by the NGSIv2 (Next Generation Service Interface) standard by leveraging the integration capabilities of the SOSS core.  Layered and Modular Architecture: Micro-ROS follows the ROS 2 architecture and makes use of its middleware pluggability to use DDS-XRCE, which is optimized for microcontrollers. Moreover, it uses POSIX-based RTOS (FreeRTOS, Zephyr, or NuttX) instead of Linux.  Dark blue components are developed specifically for micro-ROS. Light blue components are taken from the standard ROS 2 stack. We seek to contribute as much code back to the ROS 2 mainline codebase as possible. "
        }, {
        "id": 113,
        "url": "https://micro-ros.github.io//docs/overview/hardware/",
        "title": "Supported Hardware",
        "body": " - Micro-ROS aims to bring ROS 2 to a wide set of microcontrollers to allow having first-class ROS 2 entities in the embedded world. The main targets of micro-ROS are mid-range 32-bits microcontroller families. Usually, the minimum requirements for running micro-ROS in an embedded platform are memory constraints. Since memory usage in micro-ROS is a complex matter we provide a complete article describing it and a tutorial on how to tune the memory consuption in the micro-ROS middleware. In general micro-ROS will need MCUs that have tens of kilobytes of RAM memory and communication peripherals that enable the micro-ROS Client to Agent communication. The micro-ROS hardware support is divided into two categories:  Officially supported boards Community supported boardsIn order to check the most recent hardware support visit the micro_ros_setup repo. Officially supported boards: The officially supported boards are those which have been carried out or tested officially, and to which LTS is guaranteed.    Espressif ESP32:       &#10004; Key features:          MCU: ultra-low power dual-core Xtensa LX6      RAM: 520 kB      Flash: 4 MB      Peripherals: Ethernet MAC, Wi-Fi 802. 11 b/g/n, Bluetooth v4. 2 BR/EDR, BLE, SPI, I2C, I2S, UART, SDIO, CAN, GPIO, ADC/DAC, PWM          &#127758; Resources:          Official website      Datasheet        &#9881; Supported platforms:          RTOSes: FreeRTOS      External tools: ESP-IDF        &#128268; Supported transports:    UART, WiFi UDP, Ethernet UDP          Arduino Portenta H7:       &#10004; Key features:          MCU: Dual-core Arm Cortex-M7 and Cortex-M4      RAM: 8 MB      Flash: 16 MB      Peripherals: USB HS, Ethernet, WiFi/BT. . .          &#127758; Resources:          Official website        &#9881; Supported platforms:          RTOSes: &ndash;      External tools: Arduino        &#128268; Supported transports:    USB, WiFi UDP          Raspberry Pi Pico RP2040:       &#10004; Key features:          MCU: Dual-core Arm Cortex-M0+      RAM: 264 kB      Flash: up to 16 MB      Peripherals: I2C, SPI, PIO. . .         &#127758; Resources:          Official website      micro-ROS support package        &#9881; Supported platforms:          RTOSes: &ndash;      External tools: Raspberry Pi Pico SDK        &#128268; Supported transports:    USB, UART             ROBOTIS OpenCR 1. 0:       &#10004; Key features:          MCU: ARM Cortex-M7 STM32F746ZGT6      RAM: 320 kB      Flash: 1024 kB      Peripherals: 3-axis IMU, Dynamixel ports, SPI, I2C. . .          &#127758; Resources:          Official website        &#9881; Supported platforms:          RTOSes: &ndash;      External tools: Arduino        &#128268; Supported transports:    USB, UART            Teensy 3. 2:       &#10004; Key features:          MCU: ARM Cortex-M4 MK20DX256VLH7      RAM: 64 kB      Flash: 256 kB      Peripherals: USB, SPI, I2C, CAN, I2S. . .          &#127758; Resources:          Official website        &#9881; Supported platforms:          RTOSes: &ndash;      External tools: Arduino        &#128268; Supported transports:    USB, UART             Teensy 4. 0/4. 1:       &#10004; Key features:          MCU: ARM Cortex-M7 iMXRT1062      RAM: 1024 kB      Flash: 2048 kB      Peripherals: USB, PWM, SPI, I2C, CAN, I2S, SDIO,. . .          &#127758; Resources:          Official website        &#9881; Supported platforms:          RTOSes: &ndash;      External tools: Arduino        &#128268; Supported transports:    USB, UART           Crazyflie 2. 1 Drone:       &#10004; Key features:          MCU: ARM Cortex-M4 STM32F405      RAM: 192 kB      Flash: 1 MB      Peripherals: 3 axis IMU, pressure sensor, SPI, I2C, UART, nRF51822 radio. . .          &#127758; Resources:          Official website        &#9881; Supported platforms:          RTOSes: FreeRTOS      External tools: &ndash;        &#128268; Supported transports:    Custom Radio Link            STM32L4 Discovery kit IoT:       &#10004; Key features:          MCU: ARM Cortex-M4 STM32L4      RAM: 128 kB      Flash: 1 MB      Peripherals: Bluetooth, low-power RF module, 802. 11 b/g/n, NFC, 2 digital microphone, temperature/humidity sensor, 3 axis IMU, ToF sensor. . .          &#127758; Resources:          Official website        &#9881; Supported platforms:          RTOSes: Zephyr      External tools: Zephyr build system        &#128268; Supported transports:    USB, UART, Ethernet UDP            Olimex LTD STM32-E407:       &#10004; Key features:          MCU: STM32F407ZGT6 Cortex-M4F      RAM: 196 kB      Flash: 1 MB      Peripherals: USB OTG, Ethernet, SD Card slot, SPI, CAN, I2C. . .          &#127758; Resources:          Official website      Schematics      User Manual        &#9881; Supported platforms:          RTOSes: Zephyr, FreeRTOS, NuttX      External tools: Zephyr build system        &#128268; Supported transports:    USB (Z, N), UART (Z, F, N), Ethernet UDP (F, N)    Note: Only RTOS initials used for convenience.         Community supported boards: The micro-ROS community supported boards are contributions of micro-ROS’ users and community, and are not guaranteed to be officially supported.    Arduino Due:       &#10004; Key features:          MCU: ARM Cortex-M3 AT91SAM3X8E      RAM: 96 kB      Flash: 512 kB         &#127758; Resources:          Official website        &#9881; Supported platforms:          RTOSes: &ndash;      External tools: Arduino        &#128268; Supported transports:    USB, UART            Arduino Zero:       &#10004; Key features:          MCU: ARM Cortex-M0+ ATSAMD21G18      RAM: 32 kB      Flash: 256 kB         &#127758; Resources:          Official website        &#9881; Supported platforms:          RTOSes: &ndash;      External tools: Arduino        &#128268; Supported transports:    USB, UART            ST NUCLEO-F446ZE:       &#127758; Resources:          Official website        &#9881; Supported platforms:          RTOSes: FreeRTOS      External tools: STM32CubeMX        &#128268; Supported transports:    UART            ST NUCLEO-F746ZG:       &#127758; Resources:          Official website        &#9881; Supported platforms:          RTOSes: FreeRTOS      External tools: STM32CubeMX        &#128268; Supported transports:    UART            ST NUCLEO-H743ZI:       &#127758; Resources:          Official website        &#9881; Supported platforms:          RTOSes: FreeRTOS      External tools: STM32CubeMX        &#128268; Supported transports:    UART         "
        }, {
        "id": 114,
        "url": "https://micro-ros.github.io//docs/overview/license/",
        "title": "License Overview",
        "body": " - This page gives a coarse overview to the license situation of micro-ROS. It is not intended as a legal advice and it does not relieve you to look at the license texts of all components that are used by your micro-ROS-based application or system (i. e. “product”). The following architecture diagram lists the most important repositories with their respective licenses in the form GitHubOrganization/RepositioryName [LicenseName].  All packages taken from standard ROS 2 come under the Apache 2. 0 license. Similarly, all middleware- and client-library-related packages that have been created in the micro-ROS project are provided under Apache 2. 0. In the same way, eProsima’s implementation of the DDS-XRCE standard named Micro XRCE-DDS is provided under Apache 2. 0. One exception is the micro-ROS benchmarking tool. As it links against GPL v3 licensed libraries, it is itself provided under GPL v3. As long as the tool is used by you during development only but not included in the distributed product, this does not affect the license of your product. Things get particularly interesting at the RTOS level: The micro-ROS build tool micro_ros_setup and the various modules for external build systems are provided under Apache 2. 0 but use or are combined with very differently licensed RTOS and board support components. The fact, that typical embedded toolchains build the whole software (RTOS, micro-ROS and application) into one binary image makes the situation more complex compared to typical desktop operating systems with clear separation of individual executables and the OS kernel (cf. for example the Linux syscall exception to GPL). We are aware of the following important license specifics in the RTOS supported by micro-ROS:  NuttX license clearing: With the incubation at The Apache Software Foundation in December 2019, there has been significant license cleanup work. The changelog for version 10. 1 states that thousands of NuttX files have been converted (from BSD) to Apache 2. 0 and that the listing of 3rd party licenses used in NuttX has been improved.  NuttX and uClibc++: Before NuttX version 10, micro-ROS on NuttX required the use of the LGPL-licensed uClibc++ library.  ST-specific extensions for FreeRTOS: The micro-ROS/freertos_apps repository contains extensions for various microcontroller families. Some of the header files for microcontrollers by STMicroelectronics are provided under ST’s Ultimate Liberty license, which “must be used and execute solely and exclusively on or in combination with a microcontroller or microprocessor device manufactured by or for STMicroelectronics. ” Third-party licenses in Arm® Mbed™ OS: The licenses of the third-party components are listed in the LICENSE. md file in the root of the repository. … and in the corresponding tooling:  GPL-licensed build scripts in Zepyhr: The third-party licenses are given directly in the source tree, but docs. zephyrproject. org/latest/LICENSING. html states explicitly that few build scripts are used under GPL v2.  GPL-licensed build tool files in ESP-IDF: The Espressif IoT Development Framework used for the ESP32 includes files menuconfig (Kconfig) and several other build tooling files licensed under GPL v2 or v3.  Static library for Arduino IDE: The micro_ros_arduino repository provides a static library libmicroros. a of the micro-ROS stack for use with the Arduino IDE. In detail, multiple versions of this library are provided, built for different microcontroller families using suitable cross-compiler configurations. The list of repositories included in the library can be found in the built_packages file in the root of the repository. "
        }, {
        "id": 115,
        "url": "https://micro-ros.github.io//docs/overview/rtos/",
        "title": "Supported RTOSes",
        "body": " - micro-ROS aims to bring ROS 2 to microcontrollers to allow having first-class ROS 2 entities in the embedded world. The standard approach to micro-ROS assumes a Real-Time Operating System underneath. Even though recent developments aim at loosening this requirement, with the integration into Arduino IDE as an important step towards true micro-ROS bare-metal support, the RTOS-based support remains the main entrypoint to micro-ROS. To date, micro-ROS is supported by the RTOSes FreeRTOS, Zephyr, NuttX, in addition to Linux and Windows. All three RTOSes are downloaded natively with the micro-ROS build system, and can be chosen when creatinga new firmware workspace. Dedicated tutorials for running your first micro-ROS application on each of these Operating Systems can be found here. The features common to all supported RTOSes are an API compliant with POSIX to some degree, extremely low-to-low memory footprint, and availability of different scheduling algorithms to ensure determinism in micro-ROS apps behavior. Find more details about each of the supported RTOSes below. For a more comprehensive explanation regarding the choice of working with Real-Time Operating Systems, and for a more technical comparison among these three RTOSes, please refer to the RTOS page in the Concepts section, as the present page is meant to solely provide a schematic overview. Real-Time Operating Systems officially supported by the project: In this section, we review the main features of the three RTOSes supported officially by the project, and provide links to useful documentation. FreeRTOS: FreeRTOS is distributed under the MIT license. It is known particularly for its simplicity and the extension a:FreeRTOS provided by Amazon. For micro-ROS, we make use of the POSIX extension.        Key features:          Extremely small footprint      POSIX extension available      Memory management tools      Standard and idle tasks available with assignable priorities      Transport resources: TCP/IP and lwIP         FreeRTOS resources:          Official FreeRTOS website      Download      Documentation        FreeRTOS &amp; micro-ROS:          micro-ROS on FreeRTOS      First micro-ROS Application on FreeRTOS             Zephyr: Zephyr is a fairly new open-source RTOS, developed in a Linux Foundation Project. The members of this project include several renowned semiconductor companies. Zephyr strives for a functional safety certification, which would make it the first open-source RTOS with such a certification.        Key features:          Small footprint      Native POSIX port      Cross Architecture: Huge collection of supported boards      Extensive suite of Kernel services      Multiple Scheduling Algorithms      Highly configurable/Modular for flexibility      Native Linux, macOS, and Windows Development         Zephyr resources:          Official Zephyr website      Meta-tool *West*      Download      Documentation        Zephyr &amp; micro-ROS:          micro-ROS on Zephyr      First micro-ROS Application on Zephyr      First micro-ROS Application on Zephyr Emulator           NuttX: NuttX emphasizes its compliance with standards - including POSIX - and small footprint. It can be fit on 8- to 32-bit microcontrollers. The use of POSIX and ANSI standards, together with the mimic it does to UNIX APIs, makes it friendly to the developers that are used to Linux. NuttX is licensed under BSD license and makes use of the GNU toolchain. Please note that the uClib++ library used with NuttX comes under the stricter GNU LGPL Version 3 license.        Key features:          POSIX compliant interface to a high degree      Rich Feature OS Set      Highly scalable      Real-Time behavior: fully pre-emptible; fixed priority, round-robin, and “sporadic” scheduling         NuttX resources:          Official NuttX website      Download      Documentation        NuttX &amp; micro-ROS:          First micro-ROS Application on NuttX           Bare metal support: Based on the release of micro-ROS as a standalone library with header files, and on the support provided to the Arduino IDE, micro-ROS is available as a bare-metal application, too. Find more details in the dedicated repo. Arduino bare-metal support: The open-source Arduino Software (IDE) is a library making it easy to program any Arduino board.        Key features:          Inexpensive      Cross-platform      Simple, clear programming environment      Open source and extensible software      Open source and extensible hardware        Resources:          Official Arduino Website      micro_ros_arduino repo             Experimentally supported Real-Time Operating Systems: Arm® Mbed™ OS: Mbed OS is an open-source RTOS intended for IoT applications with 32-bit ARM Cortex-M microcontrollers.        Key features:          Small footprint      Many POSIX-compatible modules      Preemptive scheduling      Support of Arm Compiler and GNU Arm Embedded      Online compiler at https://os. mbed. com/compiler/        Mbed OS resources:          Official Mbed website      Source code      Documentation        Mbed OS &amp; micro-ROS:          micro-ROS example for Mbed           Disclaimer: All logos and product names are property of their respective owners. All company names, logos and product names used in this website are for identification purposes only. Their use does not imply endorsement. "
        }, {
        "id": 116,
        "url": "https://micro-ros.github.io//docs/overview/users_and_clients/",
        "title": "Members, Partners, Users and Collaborators",
        "body": " -    &times;  :       Members of the EU project OFERA:                                      Partners:                             Users and Middleware Users:                                      Collaborators:                                                        Disclaimer: All logos and product names are property of their respective owners. All company names, logos and product names used in this website are for identification purposes only. Their use does not imply endorsement. "
        }, {
        "id": 117,
        "url": "https://micro-ros.github.io//privacy",
        "title": "Privacy & Cookies policy",
        "body": " - Privacy policy: Personal data (usually referred to just as “data” below) will only be processed by us to the extent necessary and for the purpose of providing a functional and user-friendly website, including its contents, and the services offered there. Per Art. 4 No. 1 of Regulation (EU) 2016/679, i. e. the General Data Protection Regulation (hereinafter referred to as the “GDPR”), “processing” refers to any operation or set of operations such as collection, recording, organization, structuring, storage, adaptation, alteration, retrieval, consultation, use, disclosure by transmission, dissemination, or otherwise making available, alignment, or combination, restriction, erasure, or destruction performed on personal data, whether by automated means or not. The following privacy policy is intended to inform you in particular about the type, scope, purpose, duration, and legal basis for the processing of such data either under our own control or in conjunction with others. We also inform you below about the third-party components we use to optimize our website and improve the user experience which may result in said third parties also processing data they collect and control. Information about us as controllers of your data: The party responsible for this website (the “controller”) for purposes of data protection law is: eProsima Plaza de la Encina 10-11 Nucleo 4 2ª Planta, 28760 Tres Cantos, Madrid, Spain E-mail: info@eprosima. com Telephone: +34 918043448 The rights of users and data subjects: With regard to the data processing to be described in more detail below, users and data subjects have the right  to confirmation of whether data concerning them is being processed, information about the data being processed, further information about the nature of the data processing, and copies of the data (cf. also Art. 15 GDPR); to correct or complete incorrect or incomplete data (cf. also Art. 16 GDPR); to the immediate deletion of data concerning them (cf. also Art. 17 DSGVO), or, alternatively, if further processing is necessary as stipulated in Art. 17 Para. 3 GDPR, to restrict said processing per Art. 18 GDPR; to receive copies of the data concerning them and/or provided by them and to have the same transmitted to other providers/controllers (cf. also Art. 20 GDPR); to file complaints with the supervisory authority if they believe that data concerning them is being processed by the controller in breach of data protection provisions (see also Art. 77 GDPR). In addition, the controller is obliged to inform all recipients to whom it discloses data of any such corrections, deletions, or restrictions placed on processing the same per Art. 16, 17 Para. 1, 18 GDPR. However, this obligation does not apply if such notification is impossible or involves a disproportionate effort. Nevertheless, users have a right to information about these recipients. Likewise, under Art. 21 GDPR, users and data subjects have the right to object to the controller’s future processing of their data pursuant to Art. 6 Para. 1 lit. f) GDPR. In particular, an objection to data processing for the purpose of direct advertising is permissible. Information about the data processing: Your data processed when using our website will be deleted or blocked as soon as the purpose for its storage ceases to apply, provided the deletion of the same is not in breach of any statutory storage obligations or unless otherwise stipulated below. Model Data Protection Statement for Anwaltskanzlei Weiß &amp; Partner Cookies usage: What are cookies?: A cookie is a small text file that a website saves on your computer or mobile device when you visit the site. It enables the website to remember your actions and preferences (such as login, language, font size and other display preferences) over some time, so you don’t have to keep re-entering them whenever you come back to the site or browse from one page to another. How do we use cookies?: We use cookies for the unique purpose of tracking how many visitors we receive on a page. A third-party application: Google Analytics provides the cookies used for that. Google Analytics is Google’s analytics tool that helps website and app owners to understand how their visitors engage with their properties. It may use a set of cookies to collect information and report website usage statistics without personally identifying individual visitors to Google. The main cookie used by Google Analytics is the ‘_ga’ cookie. In addition to reporting website usage statistics, Google Analytics can also be used, together with some of the advertising cookies described above, to help show more relevant ads on Google properties (like Google Search) and across the web and to measure interactions with the ads we show. Learn more about Analytics cookies and privacy information. Also, some videos embedded in our pages use a cookie to anonymously gather statistics on how you got there and what videos you visited. Enabling these cookies is not strictly necessary for the website to work, but it will provide you with a better browsing experience. You can delete or block these cookies, but if you do that some features of this site may not work as intended. The cookie-related information is not used to identify you personally, and the pattern data is entirely under our control. These cookies are not used for any purpose other than those described here. Do we use other cookies?: Additionally, to the cookies exposed in the previous section, we use a cookie to keep track of your choice in the cookie notice. This cookie is only used for keeping your decision during a set time, expired that time the cookie banner will appear again. This cookie is kept for 31 days. How to control cookies: You can control and delete cookies as you wish. You can delete all cookies that are already on your computer, and you can set most browsers to prevent them from being placed. If you do this, however, you may have to adjust some preferences every time you visit a site, and some services and functionalities may not work. "
        }, {
        "id": 118,
        "url": "https://micro-ros.github.io//docs/tutorials/advanced/benchmarking/",
        "title": "Benchmarking with the Shadow-Builder",
        "body": " -  Benchmarking an applicastion with the TFA Shadow-builder Prerequisites TFA Plugin Configuration Running the shadow-builderBenchmarking an applicastion with the TFA Shadow-builder: This section is dealing with one specific benchmarking tooling called theShadow Builder. More specifically, this tutorial aims to create a plugin fromA to Z and how to instrument your code. For the sake of ease of understanding, this tutorial is proposing tobenchmark the time spent on a simple looping function. Prerequisites: Before getting to the heart of the matter, it is needed to meet the followingrequirements:    It is assumed that the shadow builder and trace framework abstractionterminology and mechanisms are a known. If this is not the case, thedocumentation related to the benchmarking is available inhere.     Using linux, preferably Ubuntu 18. 04 and above, all Debian-baseddistros should do the job.     Some knowledge about C and C++ programming  Once all the checkboxes ticked the tutorial can begin. TFA Plugin: In order to create a plugin, the information that is crucial to figure out are: What is to benchmark? –&gt; The time spent in a a function. How to do so ? –&gt; Is there a plugin already supporting it? Yes, then to do. Andthe code to profil can be instrumented. If no plugin supports it, then a plugin has to be created. Then, another set of questions arises, which are (according to the context):  How could it benefit to others? What piece of code would be used to measure the time? (In C or C++?) What platform can it support? (OS, CPU, etc. ) How should the code be instrumented?The answers to these questions would be:  Create a generic plugin and write a documentation that would beunderstandable for a normal user and an expert user.  Using the timespec and clock_gettime Linux syscall.  From previous answer –&gt; OS: Linux on any CPU as long as it has the same Linux API.  Using a simple way using the comment as follow  ` /** Benchmarking::plugin_name::function */ . The choice for the currenttutorial would be /** Benchmarking::TimeBenchmarking::Timer */`These answers provide us with the minimum necessary for the creation of a plugin. Create a TFA-Plugin: File tree structure: The final code shall be located insrc_root_sb/tfa-plugin/TimeBenchmarking with the following structure: TimeBenchmarking	├── CMakeLists. txt	├── inc	│   └──TimeBenchmarking	│     └── TimeBenchmarking. h	└── src	  └── TimeBenchmarking. cppRegister a new plugin into the TFA core of the shadow builder: The shadow-builder is relying on TFA’s plugins to be executed to answer theparser dispatch. Therefore, the need of some interoperability is needed. Every new plugins are written by implementing the IPlugin interface as shown inthe file src_root/tfa_core/inc/tfa/IPlugin. h. All what the interface needs to do is toimplement the pure virtual function. A simple example would be as in theplugin_test: In the plugin header: class TimeBenchmarking: public IPlugin {public:	TimeBenchmarking();	~TimeBenchmarking();	TFAInfoPlugin&amp; getInfoPlugins();	bool initializePlugin();};extern  C  IPlugin* create() {	return static_cast&lt;IPlugin *&gt;(new TimeBenchmarking);}extern  C  void destroy(IPlugin* p) {	delete p;}In the plugin source code: TimeBenchmarking::TimeBenchmarking() {}TimeBenchmarking::~TimeBenchmarking(){	if(mInfos) {		delete mInfos;	}}Create a listener: Good! Now the plugin is ready to be registered within the TFA’s core. So when asession is running, the plugin will be found. However nothing will reallyhappen. Indeed your plugin is not listening to a specific tag. Just as a reminder, the listener is an object derivated from the interfaceITFACommentListener. It is listening to as specific Tag which will bereplace by a piece of code. The declaration of the object shall be as display below: class Timer: public ITFACommentListener{public:	Timer();	Status runnableComments(const TFACommentInfo&amp; cleanComment,				std::string&amp; replacement);};As shown above, the class is inheriting from the ITFACommentListenner classe. The ITFACommentListener has one pure-virtual method called runnableComments. This means your plugin has to implement the method runnableComments(…). Timer::Timer() :	 ITFACommentListener( Benchmarking::User::Timer ){}Status Timer::runnableComments(const TFACommentInfo&amp; cleanComment,		std::string&amp; replacement){	return Status::returnStatusError();}Now, the functions are correctly implemented. The timer needs several things tomeasure the time spent in a function:  Start the timer before the function, get an intial timestamp Stop the timer after the function has returned, get another timestamp Measure the delta between the two timestamp measured above.  Print the delta in a human readable. This basically means that the plugin will neeed a way to get the timestamps, asdiscussed before, by using the clock_gettime, and print it to the user by usingprintf. A tag can be provided by several parameters. This will be useful for the sake ofthe timer:  A parameter to identify what’s is the timer’s status (i. e. start or stop) A parameter to identify the timer itself in a unique way by the dev A parameter that is needed for header declaration . This would look like that in real life without any tools: #include &lt;time. h&gt; // Needed to access the clock_gettime() function#include &lt;stdio. h&gt; // Needed to access the printf function. void func2benchmark(. . . ){	/** declare and measure the starting timestamp */	struct timestamp timer_start, timer_stop;	clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;timer_start);	// do something very slow	/** Measure the timesampe now, process and show the results */	clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;timer_start);	{		struct timespec *start = &amp;timer_start;		struct timespec *stop = &amp;timer_stop;		struct timespec result;		if ((stop-&gt;tv_nsec - start-&gt;tv_nsec) &lt; 0) {			result. tv_sec = stop-&gt;tv_sec - start-&gt;tv_sec - 1;			result. tv_nsec = stop-&gt;tv_nsec - start-&gt;tv_nsec + 1000000000;		} else {			result. tv_sec = stop-&gt;tv_sec - start-&gt;tv_sec;			result. tv_nsec = stop-&gt;tv_nsec - start-&gt;tv_nsec;		}		printf(/ Exe time: %ld sec : %ld ms : %ld ns//n/ ,				result. tv_sec, result. tv_nsec / 1000000, result. tv_nsec % 1000000);	}}This would llok like this using the tfa: /** Benchmarking::TimeBenchmarking::Timer(declare) */void func2benchmark(. . . ){/** Benchmarking::TimeBenchmarking::Timer(start, timer1) */	//do something very slow/** Benchmarking::TimeBenchmarking::Timer(stop, timer1) */}By taking a look at the differences, the amount of overhead code clarityintroduce by the method is very low. Now, let’s roll-up the sleeves and implement it as a plugin and therefore in ageneric way to be reusable. Declare: In order to declare the include needed to benchmark. The way to do it would beto get the parameter 0 to be a string that matches “declare”. The replacementwill be “#include &lt;time. h&gt;/n#include &lt;stdio. h&gt;/n” It is needed to append “/n” to the end of a line, as this piece of code is goingto be appended to the code. Status Timer::runnableComments(const TFACommentInfo&amp; cleanComment,		std::string&amp; replacement){	const std::vector&lt;std::string&gt; params = comment. getParams();	if (params. size() == 1 &amp;&amp; params[0] ==  declare ) {		replacement =  #include &lt;time. h&gt;/n ;		replacement +=  #include &lt;stdio. h&gt;/n ;		return Status::returnStatusOkay();	}	return Status::returnStatusError();}It is mandatory to return Status::returnStatusOkay() to tell the tfa-core thatthe Tag was handled and therefore that no other plugin will be using it. Start: The starting element will basically record a timestamp in the memory. How to doso in C programming on a Linux system would be as follow: Status Timer::runnableComments(const TFACommentInfo&amp; cleanComment,		std::string&amp; replacement){	const std::vector&lt;std::string&gt; params = comment. getParams();	if (params[0] ==  start  &amp;&amp; params. size() == 2) {		std::string start =  timer_start_  + params[1]; 		std::string stop =  timer_stop_  + params[1]; 		replacement =  struct timespec   + start +  ,   + stop +  ;/n ;		replacement +=  /tclock_gettime(CLOCK_PROCESS_CPUTIME_ID,			  &amp;timer_start_  + params[1] +  );/n ;		return Status::returnStatusOkay();	}	return Status::returnStatusError();}It is mandatory to return Status::returnStatusOkay() to tell the tfa-core thatthe Tag was handled and therefore that no other plugin will be using it. Stop: Then the stopping element, which will be in charge of getting a timestamp,make the delta time spent between the stop and the start and finally print in ahuman-readable way. Status Timer::runnableComments(const TFACommentInfo&amp; cleanComment,		std::string&amp; replacement){	const std::vector&lt;std::string&gt; params = comment. getParams();	const char difftime_func[] =	 {/n/		struct timespec *start = &amp;%s;/n/		struct timespec *stop = &amp;%s;/n/		struct timespec result;/n/		if ((stop-&gt;tv_nsec - start-&gt;tv_nsec) &lt; 0) {/n/			result. tv_sec = stop-&gt;tv_sec - start-&gt;tv_sec - 1;/n/				result. tv_nsec = stop-&gt;tv_nsec - start-&gt;tv_nsec + 1000000000;/n/		} else {/n/			result. tv_sec = stop-&gt;tv_sec - start-&gt;tv_sec;/n/				result. tv_nsec = stop-&gt;tv_nsec - start-&gt;tv_nsec;/n/		}/n/		printf(/ Exe time: %%ld sec : %%ld ms : %%ld ns//n/ ,/n/				result. tv_sec, result. tv_nsec / 1000000, result. tv_nsec/n/				%% 1000000);/n/	}/n ;	if (params[0] ==  stop  &amp;&amp; params. size() == 2) {		std::string start =  timer_start_  + params[1]; 		std::string stop =  timer_stop_  + params[1]; 		char buf[sizeof(difftime_func) + start. length() +			stop. length()];		sprintf(buf, difftime_func, start. c_str(), stop. c_str());		replacement +=  clock_gettime(CLOCK_PROCESS_CPUTIME_ID, 			  &amp;timer_stop_  + params[1] +  );/n ;		replacement += string(buf);		return Status::returnStatusOkay();	}	return Status::returnStatusError();}It is mandatory to return Status::returnStatusOkay() to tell the tfa-core thatthe Tag was handled and therefore that no other plugin will be using it. Additionally, this is necessary to think that the replacement code is actualC code that is going to be compiled. Therefore, one should be careful about thethe way to format it and be careful of the escaping characters. Combine everything together: Finally the whole runnableComment method will look like that: Status Timer::runnableComments(const TFACommentInfo&amp; cleanComment,		std::string&amp; replacement){	const char difftime_func[] =	 {/n/		struct timespec *start = &amp;%s;/n/		struct timespec *stop = &amp;%s;/n/		struct timespec result;/n/		if ((stop-&gt;tv_nsec - start-&gt;tv_nsec) &lt; 0) {/n/			result. tv_sec = stop-&gt;tv_sec - start-&gt;tv_sec - 1;/n/			result. tv_nsec = stop-&gt;tv_nsec - start-&gt;tv_nsec + 1000000000;/n/		} else {/n/			result. tv_sec = stop-&gt;tv_sec - start-&gt;tv_sec;/n/				result. tv_nsec = stop-&gt;tv_nsec - start-&gt;tv_nsec;/n/		}/n/		printf(/ Exe time: %%ld sec : %%ld ms : %%ld ns//n/ ,/n/				result. tv_sec, result. tv_nsec / 1000000, result. tv_nsec /n/				%% 1000000);/n/	}/n ;	const std::vector&lt;std::string&gt; params = comment. getParams();	if (!params. size())	{		return Status::returnStatusError();	}	if (params[0] ==  declare  &amp;&amp; params. size() == 1) {		replacement =  #include &lt;time. h&gt;/n ;		replacement +=  #include &lt;stdio. h&gt;/n ;		return Status::returnStatusOkay();	} else if (params[0] ==  start  &amp;&amp; params. size() == 2) {		std::string start =  timer_start_  + params[1]; 		std::string stop =  timer_stop_  + params[1]; 		replacement =  struct timespec   + start +  ,   + stop +  ;/n ;		replacement +=  /tclock_gettime(CLOCK_PROCESS_CPUTIME_ID, /				&amp;timer_start_  + params[1] +  );/n ;		return Status::returnStatusOkay();	} else if (params[0] ==  stop  &amp;&amp; params. size() == 2) {		std::string start =  timer_start_  + params[1]; 		std::string stop =  timer_stop_  + params[1]; 		char buf[sizeof(difftime_func) + start. length() +			stop. length()];		sprintf(buf, difftime_func, start. c_str(), stop. c_str());		replacement +=  clock_gettime(CLOCK_PROCESS_CPUTIME_ID, /					&amp;timer_stop_  + params[1] +  );/n ;		replacement += string(buf);				return Status::returnStatusOkay();	}	return Status::returnStatusError();}Register the listener: Once the listener is implemented, then it needs to be registered within theTFA plugin manager: bool TimeBenchmarking::initializePlugin(){		/* This is a plugin compatibility platform */	tbp = new TFABenchMarkingPlatform( Linux ,  * ,  * ,  * );	/** Here register the Timer listener */	iclVect. emplace_back(static_cast&lt;ITFACommentListener *&gt;(new					Timer));	/* This is the infoPlugin that holds the plugin name and the		platform information */`	mInfos = new TFAInfoPlugin( Test Plugin , *tbp);	// Will be explained later how to mock up this part. 	return Status::returnStatusOkay();}A protected vector, inherited from the IPlugin, class needs to be appended for each listener this plugin will besupporting and implementing. Compilation files: The compilation file will be the CMakeLists. txt at the root of the plugin It shall look like the following: project(TimeBenchmarking VERSION 0. 1 DESCRIPTION  MY Plugin )set(CMAKE_CXX_STANDARD 14)set(PLUGIN_NAME  TimeBenchmarking )# Needed to get the function to do tests include(. . /. . /CMakeMacros/CMakeTesting. txt)# Plugins include foldersinclude_directories(inc/)# Plugins source fileslist(APPEND TEST_PLUGIN_SRC    src/TimeBenchmarking. cpp)# Needed to create a shareable libraryadd_library(${PLUGIN_NAME} SHARED ${TEST_PLUGIN_SRC})# Target library that we need to link againsttarget_link_libraries(tfa)# Needed to create a version of the shared libraryset_target_properties(${PLUGIN_NAME} PROPERTIES SOVERSION ${PROJECT_VERSION})And finally, it is needed to add into the parent’s folder (i. e. src_root/tfa-plugins/CMakeLists. txt) CMakeLists. txt thesubdirectory of the plugin: cmake_minimum_required(VERSION 3. 10) # CMake version checkset(CMAKE_CXX_STANDARD 14)add_subdirectory(plugin_test)add_subdirectory(myplugin)# Add your project configuration here:add_subdirectory(TimeBenchmarking)The example is available here Compilation: To compile the plugin. From the build folder created before in theshadow-builder. Configuration: TFA configuration: An example fo the configuration file is in the source tree atsrc_root/res/tfa-res/tfa. xml. This file only keeps track of the path where to look for plugins. Watch out! thisfile is a template and renewed at each compilation. In the current context, the path is the default one (i. e. src_root/build): cd src_root/build/ make -j4The shadow builder configuration: The shadow-buidler configuration is providing some hints where the source filesto benchmark can be found and where the ouput folder should be set. A detailed explaination can be foundhere. Running the shadow-builder: Once all the above steps are done and the plugin compiled the command to run thecode’s instrumentation would be: cd src_root/build/ . /shadow-program -s . . /res/sb-res/bcf. xml -t . . /res/tfa-res/tfa. xmlThe output should be put in the folder configured in the bcf configuration file(by default should /tmp/output/) under the folder then session’s name (test bydefault) appended by the date and time when the benchmarking was started. "
        }, {
        "id": 119,
        "url": "https://micro-ros.github.io//docs/tutorials/advanced/create_custom_static_library/",
        "title": "Creating custom static micro-ROS library",
        "body": " - This tutorial aims at providing step-by-step guidance for those users interested in compiling micro-ROS as a standalone library in order to integrate it in custom development tools. This tutorial starts in a previously created micro-ROS environment. Check the first steps of First micro-ROS application on an RTOS for instructions on how to create a micro-ROS environment for embedded platforms. Once your micro-ROS workspace is created and the micro_ros_setup tool is installed, we are going to prepare the micro-ROS environment: ros2 run micro_ros_setup create_firmware_ws. sh generate_libOnce all the packages are downloaded, we need to create a couple of files in order to crosscompile a custom static library and a set of header files: touch my_custom_toolchain. cmaketouch my_custom_colcon. metaExample of a CMake toolchain: For example for a Cortex M3 a sample toolchain could be: set(CMAKE_SYSTEM_NAME Generic)set(CMAKE_CROSSCOMPILING 1)set(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)# SET HERE THE PATH TO YOUR C99 AND C++ COMPILERSset(CMAKE_C_COMPILER gcc)set(CMAKE_CXX_COMPILER g++)set(CMAKE_C_COMPILER_WORKS 1 CACHE INTERNAL   )set(CMAKE_CXX_COMPILER_WORKS 1 CACHE INTERNAL   )# SET HERE YOUR BUILDING FLAGSset(FLAGS  -O2 -ffunction-sections -fdata-sections -fno-exceptions -mcpu=cortex-m3 -nostdlib -mthumb --param max-inline-insns-single=500 -DF_CPU=84000000L -D'RCUTILS_LOG_MIN_SEVERITY=RCUTILS_LOG_MIN_SEVERITY_NONE'  CACHE STRING    FORCE)set(CMAKE_C_FLAGS_INIT  -std=c11 ${FLAGS} -DCLOCK_MONOTONIC=0 -D'__attribute__(x)='  CACHE STRING    FORCE)set(CMAKE_CXX_FLAGS_INIT  -std=c++11 ${FLAGS} -fno-rtti -DCLOCK_MONOTONIC=0 -D'__attribute__(x)='  CACHE STRING    FORCE)set(__BIG_ENDIAN__ 0)Example of a colcon meta file: A sample colcon. meta file with micro-ROS external transports could be: {   names : {     tracetools : {       cmake-args : [         -DTRACETOOLS_DISABLED=ON ,         -DTRACETOOLS_STATUS_CHECKING_TOOL=OFF       ]    },     rosidl_typesupport : {       cmake-args : [         -DROSIDL_TYPESUPPORT_SINGLE_TYPESUPPORT=ON       ]    },     rcl : {       cmake-args : [         -DBUILD_TESTING=OFF ,         -DRCL_COMMAND_LINE_ENABLED=OFF ,         -DRCL_LOGGING_ENABLED=OFF       ]    },      rcutils : {       cmake-args : [         -DENABLE_TESTING=OFF ,         -DRCUTILS_NO_FILESYSTEM=ON ,         -DRCUTILS_NO_THREAD_SUPPORT=ON ,         -DRCUTILS_NO_64_ATOMIC=ON ,         -DRCUTILS_AVOID_DYNAMIC_ALLOCATION=ON       ]    },     microxrcedds_client : {       cmake-args : [         -DUCLIENT_PIC=OFF ,         -DUCLIENT_PROFILE_UDP=OFF ,         -DUCLIENT_PROFILE_TCP=OFF ,         -DUCLIENT_PROFILE_DISCOVERY=OFF ,         -DUCLIENT_PROFILE_SERIAL=OFF ,         -UCLIENT_PROFILE_STREAM_FRAMING=ON ,         -DUCLIENT_PROFILE_CUSTOM_TRANSPORT=ON       ]    },     rmw_microxrcedds : {       cmake-args : [         -DRMW_UXRCE_MAX_NODES=1 ,         -DRMW_UXRCE_MAX_PUBLISHERS=5 ,         -DRMW_UXRCE_MAX_SUBSCRIPTIONS=5 ,         -DRMW_UXRCE_MAX_SERVICES=1 ,         -DRMW_UXRCE_MAX_CLIENTS=1 ,         -DRMW_UXRCE_MAX_HISTORY=4 ,         -DRMW_UXRCE_TRANSPORT=custom       ]    }  }}Building the custom library: Once you have both files ready, just run the build step in the micro-ROS build system: ros2 run micro_ros_setup build_firmware. sh $(pwd)/my_custom_toolchain. cmake $(pwd)/my_custom_colcon. metaOnce the build finishes you will have a precompiled static library with all the micro-ROS functionality in firmware/build/libmicroros. a and you will have all the required headers for your application in firmware/include. Just use them to link against in your development tools, and remember if you are using a commercially available board we are accepting micro-ROS ports from the community. "
        }, {
        "id": 120,
        "url": "https://micro-ros.github.io//docs/tutorials/advanced/create_custom_transports/",
        "title": "Creating custom micro-ROS transports",
        "body": " - This tutorial aims at providing step-by-step guidance for those users interested in creating micro-ROS custom transports, instead of using the ones provided by default in the micro-ROS tools set. This tutorial starts from a previously created micro-ROS environment. Check the first steps of First micro-ROS application on an RTOS for instructions on how to create a micro-ROS environment for embedded platforms. The micro-ROS middleware, eProsima Micro XRCE-DDS, provides a user API that allows interfacing with the lowest level transport layer at runtime,which enables users to implement their own transports in both the micro-ROS Client and micro-ROS Agent libraries. Thanks to this, the Micro XRCE-DDS wire protocol can be transmitted over virtually any protocol, network or communicationmechanism. In order to do so, two general communication modes are provided:  Stream-oriented mode: the communication mechanism implemented does not have the concept of packet. HDLC framing will be used.  Packet-oriented mode: the communication mechanism implemented is able to send a whole packet that includes an XRCE message. These two modes can be selected by activating and deactivating the framing parameter in both the micro-ROS Client and the micro-ROS Agent functions. micro-ROS Client: An example on how to set these external transport callbacks in the micro-ROS Client API is: #include &lt;rmw_microros/rmw_microros. h&gt;. . . struct custom_args {  . . . }struct custom_args args;rmw_uros_set_custom_transport(  true, // Framing enabled here. Using Stream-oriented mode.   (void *) &amp;args,  my_custom_transport_open,  my_custom_transport_close,  my_custom_transport_write,  my_custom_transport_read);It is important to notice that in rmw_uros_set_custom_transport a pointer to custom arguments is set. This reference will be available to every callbacks call. In general, four functions must be implemented. The behaviour of these functions is slightly different, depending on the selected mode: Open function: bool my_custom_transport_open(uxrCustomTransport* transport){  . . . }This function should open and init the custom transport. It returns a boolean indicating if the opening was successful. transport-&gt;args holds the arguments passed through uxr_init_custom_transport. Close function: bool my_custom_transport_close(uxrCustomTransport* transport){  . . . }This function should close the custom transport. It returns a boolean indicating if closing was successful. transport-&gt;args holds the arguments passed through uxr_init_custom_transport. Write function: size_t my_custom_transport_write(    uxrCustomTransport* transport,    const uint8_t* buffer,    size_t length,    uint8_t* errcode){  . . . }This function should write data to the custom transport. It returns the number of bytes written. transport-&gt;args holds the arguments passed through uxr_init_custom_transport.    Stream-oriented mode: The function can send up to length bytes from buffer.     Packet-oriented mode: The function should send length bytes from buffer. If less than length bytes are written, errcode can be set.  Read function: size_t my_custom_transport_read(    uxrCustomTransport* transport,    uint8_t* buffer,    size_t length,    int timeout,    uint8_t* errcode){  . . . }This function should read data from the custom transport. It returns the number of bytes read. transport-&gt;args have the arguments passed through uxr_init_custom_transport.    Stream-oriented mode: The function should retrieve up to length bytes from the transport and write them into buffer in timeout milliseconds.     Packet-oriented mode: The function should retrieve length Bytes from transport and write them into buffer in timeout milliseconds. If less than length bytes are read, errcode can be set.  micro-ROS Agent: The micro-ROS Agent profile for custom transports is enabled by default. An example on how to set the external transport callbacks in the micro-ROS Agent API is: eprosima::uxr::Middleware::Kind mw_kind(eprosima::uxr::Middleware::Kind::FASTDDS);eprosima::uxr::CustomEndPoint custom_endpoint;// Add transport endpoing parameterscustom_endpoint. add_member&lt;uint32_t&gt;( param1 );custom_endpoint. add_member&lt;uint16_t&gt;( param2 );custom_endpoint. add_member&lt;std::string&gt;( param3 );eprosima::uxr::CustomAgent custom_agent(   my_custom_transport ,  &amp;custom_endpoint,  mw_kind,  true, // Framing enabled here. Using Stream-oriented mode.   my_custom_transport_open,  my_custom_transport_close,  my_custom_transport_write  my_custom_transport_read);custom_agent. start();As in the Client API, four functions should be implemented. The behavior of these functions is sightly differentdepending on the selected mode. CustomEndPoint: The custom_endpoint is an object of type eprosima::uxr::CustomEndPoint and it is in charge of handling the endpoint parameters. The Agent, unlike the Client, can receivemessages from multiple Clients so it must be able to differentiate between them. Therefore, the eprosima::uxr::CustomEndPoint should be provided with information about the origin of the messagein the read callback, and with information about the destination of the message in the write callback. In general, the members of a eprosima::uxr::CustomEndPoint object can be unsigned integers and strings. CustomEndPoint defines three methods: Add member bool eprosima::uxr::CustomEndPoint::add_member&lt;*KIND*&gt;(const std::string&amp; member_name);This function allows to dynamically add a new member to the endpoint definition. Ir returns true if the member was correctly added, false if something went wrong (for example, if the member already exists).  KIND: To be chosen from: uint8_t, uint16_t, uint32_t, uint64_t, uint128_t or std::string.  member_name: The tag used to identify the endpoint member. Set member value void eprosima::uxr::CustomEndPoint::set_member_value(const std::string&amp; member_name, const *KIND* &amp; value);This function sets the specific value (numeric or string) for a certain member, which must previously exist in the CustomEndPoint.  member_name: The member whose value is going to be modified.  value: The value to be set, of KIND: uint8_t, uint16_t, uint32_t, uint64_t, uint128_t or std::string. Get member const *KIND* &amp; eprosima::uxr::CustomEndPoint::get_member(const std::string&amp; member_name);This function gets the current value of the member registered with the given parameter. The retrieved value might be an uint8_t, uint16_t, uint32_t, uint64_t, uint128_t or std::string.  member_name: The CustomEndPoint member name whose current value is requested. Open function: eprosima::uxr::CustomAgent::InitFunction my_custom_transport_open = [&amp;]() -&gt; bool{  . . . }This function should open and init the custom transport. It returns a boolean indicating if the opening was successful. Close function: eprosima::uxr::CustomAgent::FiniFunction my_custom_transport_close = [&amp;]() -&gt; bool{  . . . }This function should close the custom transport. It returns a boolean indicating if the closing was successful. Write function: eprosima::uxr::CustomAgent::SendMsgFunction my_custom_transport_write = [&amp;](  const eprosima::uxr::CustomEndPoint* destination_endpoint,  uint8_t* buffer,  size_t length,  eprosima::uxr::TransportRc&amp; transport_rc) -&gt; ssize_t{  . . . }This function should write data to the custom transport. It must usethe destination_endpoint members to set the data destination. It returns the number of bytes written. It should set transport_rc indicating the result of the operation.    Stream-oriented mode: The function can send up to length Bytes from buffer.     Packet-oriented mode: The function should send length Bytes from buffer. If less than length bytes are written, transport_rc can be set.  Read function: eprosima::uxr::CustomAgent::RecvMsgFunction my_custom_transport_read = [&amp;](    eprosima::uxr::CustomEndPoint* source_endpoint,    uint8_t* buffer,    size_t length,    int timeout,    eprosima::uxr::TransportRc&amp; transport_rc) -&gt; ssize_t{  . . . }This function should read data to the custom transport. It must fill source_endpoint members with data source. It returns the number of bytes read. It should set transport_rc indicating the result of the operation.    Stream-oriented mode: The function should retrieve up to length bytes from the transport and write them into buffer in timeout milliseconds.     Packet-oriented mode: The function should retrieve length bytes from the transport and write them into buffer in timeout milliseconds. If less than length bytes are read, transport_rc can be set.  "
        }, {
        "id": 121,
        "url": "https://micro-ros.github.io//docs/tutorials/advanced/create_dds_entities_by_ref/",
        "title": "How to use custom QoS in micro-ROS",
        "body": " - This tutorial explains the procedure for creating micro-ROS entities using fully configurable QoS settings. The micro-ROS default middleware (Micro XRCE-DDS Client) allows the user to take two different approaches for creating ROS 2 (DDS) entities in the micro-ROS Agent (Please check the architecture section for detailed information):  By XML (the default option in micro-ROS RMW) By referenceUsing the default option the micro-ROS user will be able to create entities using RCLC functions such as rclc_publisher_init_default for reliable communications or rclc_publisher_init_best_effort for best effort communications. Please check RCLC for an updated list of convenience functions. For those familiar with the QoS XML format in DDS (click here for detailed information), the underlying QoS profile used by this default mode looks like this: &lt;!-- TOPIC --&gt;&lt;dds&gt; &lt;topic&gt;   &lt;name&gt;[TOPIC NAME]&lt;/name&gt;   &lt;dataType&gt;[TOPIC TYPE]&lt;/dataType&gt; &lt;/topic&gt;&lt;/dds&gt;&lt;!-- DATA WRITER --&gt;&lt;dds&gt; &lt;data_writer&gt;   &lt;historyMemoryPolicy&gt;PREALLOCATED_WITH_REALLOC&lt;/historyMemoryPolicy&gt;   &lt;qos&gt;    &lt;reliability&gt;      &lt;kind&gt;[WRITER RELIABILITY]&lt;/kind&gt;    &lt;/reliability&gt;   &lt;/qos&gt;   &lt;topic&gt;    &lt;kind&gt;NO_KEY&lt;/kind&gt;    &lt;name&gt;[WRITER NAME]&lt;/name&gt;    &lt;dataType&gt;[WRITER TYPE]&lt;/dataType&gt;    &lt;historyQos&gt;      &lt;kind&gt;KEEP_ALL&lt;/kind&gt;    &lt;/historyQos&gt;   &lt;/topic&gt; &lt;/data_writer&gt;&lt;/dds&gt;&lt;!-- DATA READER --&gt;&lt;dds&gt; &lt;data_reader&gt;   &lt;historyMemoryPolicy&gt;PREALLOCATED_WITH_REALLOC&lt;/historyMemoryPolicy&gt;   &lt;qos&gt;    &lt;reliability&gt;      &lt;kind&gt;[READER RELIABILITY]&lt;/kind&gt;    &lt;/reliability&gt;   &lt;/qos&gt;   &lt;topic&gt;    &lt;kind&gt;NO_KEY&lt;/kind&gt;    &lt;name&gt;[READER NAME]&lt;/name&gt;    &lt;dataType&gt;[READER TYPE]&lt;/dataType&gt;    &lt;historyQos&gt;      &lt;kind&gt;KEEP_ALL&lt;/kind&gt;    &lt;/historyQos&gt;   &lt;/topic&gt; &lt;/data_reader&gt;&lt;/dds&gt;But these QoS configurations may not fit some user’s requirements. For these cases, micro-ROS allows the users to write their custom XML QoS and run the agent with a predefined set of QoS. Each entity will have its own label and the micro-ROS client will create the entities using just this reference. Additionally, using references will also reduce the memory consumption of the micro-ROS client inside the MCU. This is because the parts of the code where XML are handled are just not build with the references approach. Let’s see how to create a micro-ROS node that creates entities with custom QoS. First of all, independently of which RTOS you have selected in First micro-ROS Application on an RTOS tutorial, you should have an app configuration file named app-colcon. meta. Inside this app-colcon. meta file we can set application specific CMake options for the micro-ROS packages that are going to be crosscompiled. So, let’s setup the rmw_microxrcedds in order to use references; your app-colcon. meta should look like this: {   names : {     rmw_microxrcedds : {       cmake-args : [        . . .          -DRMW_UXRCE_CREATION_MODE=refs         . . .       ]    }  }}Of course you can combine these configurations with others, e. g. the ones described in the Middleware Configuration tutorial. Once you have this parameter, write your micro-ROS application using RCLC default convenience functions. Just remember that now you are not providing the topic name but a “QoS reference label”: #include &lt;std_msgs/msg/int32. h&gt;. . . std_msgs__msg__Int32 msg;msg. data = 42;. . . rclc_publisher_init_default(&amp;publisher, &amp;node, ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Int32),  my_qos_label );rcl_publish(&amp;publisher, &amp;msg, NULL); . . . This code will tell the micro-ROS Agent to create a publisher using just a text label: my_qos_label. This implies that the micro-ROS Agent must have a file where these labels are written along with some QoS profiles. Let’s create a custom_qos. refs with the following content: &lt;profiles&gt;  &lt;participant profile_name= participant_profile &gt;    &lt;rtps&gt;      &lt;name&gt;default_xrce_participant&lt;/name&gt;    &lt;/rtps&gt;  &lt;/participant&gt;  &lt;topic profile_name= my_qos_label__t &gt;    &lt;name&gt;rt/my_topic_name&lt;/name&gt;    &lt;dataType&gt;std_msgs::msg::dds_::Int32_&lt;/dataType&gt;    &lt;historyQos&gt;     &lt;kind&gt;KEEP_LAST&lt;/kind&gt;     &lt;depth&gt;20&lt;/depth&gt;    &lt;/historyQos&gt;  &lt;/topic&gt;  &lt;data_writer profile_name= my_qos_label__dw &gt;    &lt;historyMemoryPolicy&gt;PREALLOCATED_WITH_REALLOC&lt;/historyMemoryPolicy&gt;    &lt;qos&gt;     &lt;reliability&gt;      &lt;kind&gt;RELIABLE&lt;/kind&gt;     &lt;/reliability&gt;    &lt;/qos&gt;    &lt;topic&gt;      &lt;kind&gt;NO_KEY&lt;/kind&gt;      &lt;name&gt;rt/my_topic_name&lt;/name&gt;      &lt;dataType&gt;std_msgs::msg::dds_::Int32_&lt;/dataType&gt;      &lt;historyQos&gt;        &lt;kind&gt;KEEP_LAST&lt;/kind&gt;        &lt;depth&gt;20&lt;/depth&gt;      &lt;/historyQos&gt;    &lt;/topic&gt;  &lt;/data_writer&gt;&lt;/profiles&gt;When writting this XML file, special care about ROS2 to DDS name mangling has to be taken into account. Read more information about this here. Once you have this file ready, just run the micro-ROS agent with the -r parameter: ros2 run micro_ros_agent micro_ros_agent [PARAMETERS] -r custom_qos. refsOnce the entities are created and the topic is being published, you can check the QoS using: $ ros2 topic info /std_msgs_msg_Int32 --verboseType: std_msgs/msg/Int32Publisher count: 1Node name: _CREATED_BY_BARE_DDS_APP_Node namespace: _CREATED_BY_BARE_DDS_APP_Topic type: std_msgs/msg/Int32Endpoint type: PUBLISHERGID: 01. 0f. 0b. 5c. 8b. 7d. 00. 00. 01. 00. 00. 00. 00. 00. 01. 03. 00. 00. 00. 00. 00. 00. 00. 00QoS profile: Reliability: RMW_QOS_POLICY_RELIABILITY_RELIABLE Durability: RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL Lifespan: 2147483651294967295 nanoseconds Deadline: 2147483651294967295 nanoseconds Liveliness: RMW_QOS_POLICY_LIVELINESS_AUTOMATIC Liveliness lease duration: 2147483651294967295 nanosecondsSubscription count: 0"
        }, {
        "id": 122,
        "url": "https://micro-ros.github.io//docs/tutorials/advanced/create_new_type/",
        "title": "How to include a custom ROS message in micro-ROS",
        "body": " - This tutorial starts in a previously created micro-ROS environment. Check First micro-ROS application on an RTOS for instructions about how to create a micro-ROS environment for embedded platforms. Once your micro-ROS workspace is created, go to firmware/mcu_ws and run the package creating command: cd firmware/mcu_wsros2 pkg create --build-type ament_cmake my_custom_messagecd my_custom_messagemkdir msgtouch msg/MyCustomMessage. msgIn the autogenerated CMakeLists. txt file you should add the following lines just before ament_package(): . . . find_package(rosidl_default_generators REQUIRED)rosidl_generate_interfaces(${PROJECT_NAME}  msg/MyCustomMessage. msg  ). . . In the autogenerated package. xml file you should add the following lines: . . . &lt;build_depend&gt;rosidl_default_generators&lt;/build_depend&gt;&lt;exec_depend&gt;rosidl_default_runtime&lt;/exec_depend&gt;&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;. . . The content of the msg/MyCustomMessage. msg file contains your message defintion. For example, let’s include these fields: bool bool_testbyte byte_testchar char_testfloat32 float32_testfloat64 double_testint8 int8_testuint8 uint8_testint16 int16_testuint16 uint16_testint32 int32_testuint32 uint32_testint64 int64_testuint64 uint64_testNow, you can build your micro-ROS workspace as usual. As explained in First micro-ROS application on an RTOS, the ros2 run micro_ros_setup build_firmware. sh command will build all packages located inside mcu_ws. In your micro-ROS application code, you can use your new message type as usual: #include &lt;my_custom_message/msg/my_custom_message. h&gt;. . . my_custom_message__msg__MyCustomMessage msg;msg. byte_test = 3;msg. uint32_test = 42;. . . rclc_publisher_init_default(&amp;publisher, &amp;node, ROSIDL_GET_MSG_TYPE_SUPPORT(my_custom_message, msg, MyCustomMessage),  my_custom_publisher );rcl_publish(&amp;publisher, &amp;msg, NULL); . . . You can find further information in the ROS 2 Create custom ROS 2 msg and srv files. Using type composition: It is possible to create custom types that include members from another ROS 2 message types packages. For example let’s add a member with type Point32 from the ROS 2 package geometry_msgs. First of all, you have to include the dependency in the CMakeLists. txt: . . . find_package(rosidl_default_generators REQUIRED)find_package(geometry_msgs REQUIRED)rosidl_generate_interfaces(${PROJECT_NAME}  msg/MyCustomMessage. msg  ). . . Also, include the dependency in package. xml: . . . &lt;build_depend&gt;rosidl_default_generators&lt;/build_depend&gt;&lt;exec_depend&gt;rosidl_default_runtime&lt;/exec_depend&gt;&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;&lt;depend&gt;geometry_msgs&lt;/depend&gt;. . . The message definition in msg/MyCustomMessage. msg can now include types from the geometry_msgs package: . . . int64 int64_testuint64 uint64_testgeometry_msgs/Point32 point32_testAnd finally, in your code you can access this new member of your custom type: #include &lt;my_custom_message/msg/my_custom_message. h&gt;. . . my_custom_message__msg__MyCustomMessage msg;msg. byte_test = 3;msg. uint32_test = 42;msg. point32_test. x = 1. 23;msg. point32_test. y = 2. 31;msg. point32_test. z = 3. 12;. . . Note that in order for the micro_ros_agent to register these new types, the package with the custom types you’ve created above, should also be cloned to the host workspace, e. g. ~/uros_ws/src, and compiled there as well before running the agent. "
        }, {
        "id": 123,
        "url": "https://micro-ros.github.io//docs/tutorials/advanced/handling_type_memory/",
        "title": "Handling messages memory in micro-ROS",
        "body": " - This page aims to explain how to handle messages and types memory in micro-ROS. First of all, since the micro-ROS user is in an embedded C99 environment, it is important to be aware of what messages and ROS 2 types are being used in order to handle memory correctly. By watching the . msg or . srv of the types used in a micro-ROS application, you can determine the type of each member. Currently, the following types are supported:  Basic type Array type Sequence type Compound typeLet’s take an example . mgs for clarification: # MyType. msgstd_msgs/Header headerint32[] valuesfloat64 durationint8[10] coefficientsstring nameIn this example:  the member duration is a basic type member,.  the member values is a sequence type member because it has a unbounded sequence of int32, in this case.  the member coefficients is an array type member because it has a bounded sequence of 10 units of int8, in this case.  the member header is an compound type member because it refers to complex type described in the same or other ROS 2 package.  the member name is an string type member and should be understood as a char[] (sequence type member). When dealing with the micro-ROS typesupport the developer needs to take into account how this message is going to be handled in the C99 API of micro-ROS. In general, the micro-ROS typesupport will create a C99 struct representation of the message: typedef struct mypackage__msg__MyType{ std_msgs__msg__Header header; rosidl_runtime_c__int32__Sequence values; double duration; int8 coefficients[10]; rosidl_runtime_c__String name; // equal to rosidl_runtime_c__char__Sequence} mypackage__msg__MyType;So when in an application has a variable of this type, for example mypackage__msg__MyType mymsg;, we know that:  mymsg. coefficients has a C array of int8 mymsg. duration is a double memberbut, what happens with the . . . Sequence and the compound type member? Sequence types in micro-ROS: A sequence type member is an especial type member that hosts a pointer data, a size and a capacity value. The pointer should have memory for storing up to capacity values and size member shows how many element are currently in the sequence. Usually in micro-ROS, the user is in charge of assigning memory and values to this sequence members. In the case of MyType. msg, the values sequence member is represented in C99 as this struct: typedef struct rosidl_runtime_c__int32__Sequence{  int32_t* data;  /* The pointer to an array of int32 */ size_t size;   /* The number of valid items in data */ size_t capacity; /* The number of allocated items in data */} rosidl_runtime_c__int32__Sequence;So user need to handle the type like: mypackage__msg__MyType mymsg;// mymsg. values. data is NULL or garbage now// mymsg. values. size is 0 or garbage now// mymsg. values. capacity is 0 or garbage now// Assigning dynamic memory to the sequencemymsg. values. capacity = 100;mymsg. values. data = (int32_t*) malloc(mymsg. values. capacity * sizeof(int32_t));mymsg. values. size = 0;// Assigning static memory to the sequencestatic int32_t memory[100];mymsg. values. capacity = 100;mymsg. values. data = memory;mymsg. values. size = 0;// Filling some datafor(int32_t i = 0; i &lt; 3; i++){ mymsg. values. data = i; mymsg. values. size++;}Compound types in micro-ROS: When dealing with a compound type, the user should recursively inspect the types in order to determine how to handle each internal member. For example in the MyType. msg example, the header member has the following structure: typedef struct std_msgs__msg__Header{ builtin_interfaces__msg__Time stamp; rosidl_runtime_c__String frame_id;} std_msgs__msg__Header;Remember that rosidl_runtime_c__String is equivalent to rosidl_runtime_c__char__Sequence. And builtin_interfaces__msg__Time looks like: typedef struct builtin_interfaces__msg__Time{ int32_t sec; uint32_t nanosec;} builtin_interfaces__msg__Time;To initialize the header member of MyType. msg: mypackage__msg__MyType mymsg;// Assigning dynamic memory to the frame_id char sequencemymsg. header. frame_id. capacity = 100;mymsg. header. frame_id. data = (char*) malloc(mymsg. values. capacity * sizeof(char));mymsg. header. frame_id. size = 0;// Assigning value to the frame_id char sequencestrcpy(mymsg. header. frame_id. data,  Hello World );mymsg. header. frame_id. size = strlen(mymsg. header. frame_id. data);// Assigning value to other membersmymsg. stamp. sec = 10;mymsg. stamp. nanosec = 20;Sequences of compound types: Users should take into account that sequence type member of compound type member are also valid ROS 2 type. For example, let’s modify the previous example: # MyComplexType. msgstd_msgs/Header[] multiheadersint32[] valuesfloat64 durationint8[10] coefficientsstring nameIn this case, the generated typesupport will be: typedef struct mypackage__msg__MyComplexType{ std_msgs__msg__Header__Sequence multiheaders; rosidl_runtime_c__int32__Sequence values; double duration; int8 coefficients[10]; rosidl_runtime_c__String name; // equal to rosidl_runtime_c__char__Sequence} mypackage__msg__MyComplexType;Notice that multiheaders is a sequence type member, so it should be handled properly, but also it is a compound type member which needs to be handled recursively, initializing its own members. For example: mypackage__msg__MyComplexType mymsg;// Init the multiheaders sequencemymsg. multiheaders. capacity = 10;mymsg. multiheaders. data = (std_msgs__msg__Header*) malloc(mymsg. values. capacity * sizeof(std_msgs__msg__Header));mymsg. multiheaders. size = 0;// Filling some datafor(int32_t i = 0; i &lt; 3; i++){ mymsg. values. data = i; // Add memory to this sequence element frame_id mymsg. multiheaders. data[i]. frame_id. capacity = 100; mymsg. multiheaders. data[i]. frame_id. data = (char*) malloc(mymsg. multiheaders. data[i]. frame_id. capacity * sizeof(char)); mymsg. multiheaders. data[i]. frame_id. size = 0; // Assigning value to the frame_id char sequence strcpy(mymsg. multiheaders. data[i]. frame_id. data,  Hello World ); mymsg. multiheaders. data[i]. frame_id. size = strlen(mymsg. multiheaders. data[i]. frame_id. data); // Assigning value to other members mymsg. multiheaders. data[i]. stamp. sec = 10; mymsg. multiheaders. data[i]. stamp. nanosec = 20; mymsg. multiheaders. size++;}"
        }, {
        "id": 124,
        "url": "https://micro-ros.github.io//docs/tutorials/advanced/microxrcedds_rmw_configuration/",
        "title": "Middleware Configuration",
        "body": " - micro-ROS targets microcontroller, devices with low memory resources. With that in mind, micro-ROS try to address the memory management issue prioritizing the use of static memory instead of dynamic memory and optimizing the memory footprint of the applications. This, of course, has a cost that the users must agree to pay, a precompile tunning. This tutorial explains which are the memory resources managed by micro-ROS and how to tune them for a particular application. It also addresses the RMW run-time configuration API where the user can configure the micro-ROS Agent endpoints or the Micro XRCE-DDS session client_key. Memory resources optimization: micro-ROS deals with two different memory resources related with the Micro XRCE-DDS library and its RMW implementation named rmw-microxrcedds. Micro XRCE-DDS: Micro XRCE-DDS messages flow between Client and Agent through streams. A stream represents an independently ordered flow of information, so it is a sort of messaging queue. There are two kinds of streams, best-effort and reliable. Both best-effort and reliable streams have a raw buffer (uint8_t array) associated with them, but the layout is different. On the one hand, best-effort streams could be interpreted as a single message queue. Therefore, the raw buffer is a single data buffer where only one message is popped/pushed.  On the other hand, reliable streams contain multiple messages which are popped/pushed according to the reliable communication protocol described in the DDS-XRCE specification. It is achieved by splitting the raw buffer into chunks, each of which contains a single message.  The size of the best-effort and reliable stream can be configured by two sets of CMake flags.  UCLIENT_UDP_TRANSPORT_MTU, UCLIENT_TCP_TRANSPORT_MTU and UCLIENT_SERIAL_TRANSPORT_MTU (depending on the transport selected): these flags control the size of the best-effort stream buffer which matches with the size of each chunk of the reliable stream.  RMW_UXRCE_MAX_HISTORY: sets the number of slots for the reliable streams. The size of the stream sets indirectly the maximum message size (MMS) of the micro-ROS application. This MMS is (UCLIENT_&lt;XXX&gt;_TRANSPORT_MTU - 12 B) for best-effort messages and (UCLIENT_&lt;XXX&gt;_TRANSPORT_MTU * (RMW_UXRCE_MAX_HISTORY - 12 B)) in the case of reliable messages. The use of best-effort or reliable stream is handled by the rmw_qos_reliability_policy_t set in the rmw_qos_profile_t for a particular publisher or subscription. In the case of RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT best-effort streams are used and for RMW_QOS_POLICY_RELIABILITY_RELIABLE reliable streams are used instead. rmw-microxrcedds: rmw-microxrcedds uses static memory for allocating the resources associated with the rcl and rclc entities. This static memory is managed thanks to independent memory pools for each kind of entity. The size of these memory pools could be set through CMake flags,for example, the RMW_UXRCE_MAX_PUBLISHERS sets the size of the rcl_publisher_t’s pool memory. It should be noted that the size of these memory pools restricts the maximum number of entities that a micro-ROS application could use. The figure below summarizes the relation between the rcl entities and the CMake flags, which set the size of the memory pool associated with such entities.  Another important memory resource managed by the rmw-microxrcedds is the message history. The rmw-microxrcedds uses a static-memory message queue where to to keep the subscription messages before the user reads them. The size of this message queue could be set by the RMW_UXRCE_MAX_HISTORY. It is worth noting that all the aforementioned CMake flags shall be set in a . meta for each platform supported in micro_ros_setup. For example, in the ping-pong application the host configuration file can be optimized with the following modifications: {  name : {   rmw_microxrcedds :{    cmake-args :[    . . . .      -DRMW_UXRCE_MAX_NODES=1 ,     // 3 --&gt; 1     -DRMW_UXRCE_MAX_PUBLISHERS=2 ,   // 5 --&gt; 2     -DRMW_UXRCE_MAX_SUBSCRIPTIONS=2 , // 5 --&gt; 2     -DRMW_UXRCE_MAX_SERVICES=0 ,    // 5 --&gt; 0     -DRMW_UXRCE_MAX_CLIENTS=0 ,    // 5 --&gt; 0     -DRMW_UXRCE_STREAM_HISTORY=5 ,   // 20 --&gt; 5     -DRMW_UXRCE_MAX_HISTORY=5 ,    // 20 --&gt; 5    . . . .    ]  } }}Run-time configuration: There are some build time parameters related to Client-to-Agent connection (such as CONFIG_RMW_DEFAULT_UDP_PORT, CONFIG_RMW_DEFAULT_UDP_IP and CONFIG_RMW_DEFAULT_SERIAL_DEVICE) that can be configured either at build time or at run-time. This means that you can set them in the configuration file mentioned above and that micro-ROS provides a user configuration API for setting some RMW and middleware parameters at run-time. The following example code shows the API calls needed to set the agent’s IP address, port or serial device: #include &lt;rmw_microros/rmw_microros. h&gt;// Init RCL options and contextrcl_init_options_t init_options = rcl_get_zero_initialized_init_options();rcl_context_t context = rcl_get_zero_initialized_context();rcl_init_options_init(&amp;init_options, rcl_get_default_allocator());// Take RMW options from RCL optionsrmw_init_options_t* rmw_options = rcl_init_options_get_rmw_init_options(&amp;init_options);// TCP/UDP case: Set RMW IP parametersrmw_uros_options_set_udp_address( 127. 0. 0. 1 ,  8888 , rmw_options);// Serial case: Set RMW serial device parametersmw_uros_options_set_serial_device( /dev/ttyAMA0 , rmw_options)// Set RMW client keyrmw_uros_options_set_client_key(0xBA5EBA11, rmw_options);// Init RCLrcl_init(0, NULL, &amp;init_options, &amp;context);// . . . micro-ROS code . . . Notice that it is also possible to set the Micro XRCE-DDS client_key, which would otherwise be set randomly. This feature is useful for reusing DDS entities already created on the agent side. Further information can be found here and here. "
        }, {
        "id": 125,
        "url": "https://micro-ros.github.io//docs/tutorials/advanced/overview/",
        "title": "Overview",
        "body": " - This chapter provides a number of advanced tutorials for those users who already have some previous micro-ROS knowledge. They are useful to interact with micro-ROS at a deeper level compared with the First Step Tutorials. There is no specific order recommended to take these tutorials, as each addresses a different aspect of the micro-ROS stack and toolchain.    Optimizing the Middleware Configuration   In this tutorial, we’ll guide you through the configuration of the middleware between a microcontroller and the micro-ROS agent running on some Linux-based microprocessor, to optimize it for your specific use-case and application.     How to include a custom ROS message in micro-ROS   This tutorial explains how to create or include a custom ROS message type in a micro-ROS application - and in particular how to bring it into the build system.     How to use custom QoS in micro-ROS   This tutorial explains the procedure for creating micro-ROS entities using fully configurable QoS settings by using the ROS 2 (DDS) entities creation mode by references as allowed by the micro-ROS default middleware (Micro XRCE-DDS Client).     Creating custom micro-ROS transports   This tutorial aims at providing step-by-step guidance for those users interested in creating micro-ROS custom transports, instead of using the ones provided by default in the micro-ROS tools set.     Creating custom static micro-ROS library   This tutorial aims at providing step-by-step guidance for those users interested in compiling micro-ROS as a standalone library in order to integrate it in custom development tools.     Benchmarking with the Shadow-Builder   This tutorial aims at describing a specific benchmarking tooling called the Shadow Builder. More specifically, it explains how to create a plugin from A to Z and how to instrument the code.     Getting started with ROS 2 tracing   Tracing is a method for recording run-time data which is already well integrated with operating systems. This tutorial aims to introduce our ongoing effort to instrument ROS 2 and provide trace analysis tools.  "
        }, {
        "id": 126,
        "url": "https://micro-ros.github.io//docs/tutorials/advanced/tracing/",
        "title": "Getting started with ROS 2 tracing",
        "body": " -  Introduction Setup Simple tracing example Callback duration analysis Relevant linksIntroduction: Robotic systems can be hard to analyze and debug, and one big reason is that internal processing is always changing in response to sensory input. Therefore, the ability to continuously monitor and record data about the robotic software is important, to make sure it behaves deterministically, stays within resource limits, and also for later analysis. On modern systems, the operating system and other running software has a big influence on the exact execution of the software. Therefore, we also need information about these aspects. Tracing is a well-established method that allows to record run-time data, which is already well integrated with operating systems. For example, we can trace when a process is being scheduled, or when I/O occurs. Current tracing systems have minimal overhead and are very configurable to reduce overhead (and data size) even further. This post aims to introduce our ongoing effort to instrument ROS 2 and provide trace analysis tools. I’ll show how we can use the instrumentation and the current analysis tools to plot callback durations, like the plot shown below. Setup: We’ll assume you’re using Ubuntu 18. 04 bionic. First, let’s install LTTng. $ sudo apt-add-repository ppa:lttng/stable-2. 10$ sudo apt-get update$ sudo apt-get install lttng-tools lttng-modules-dkms liblttng-ust-devAs part of the installation, a new group tracing is created. Add your user to this group by running $ sudo usermod -aG tracing $USERand log off and on to take the new membership effect. We’ll also need these Python packages to read traces and setup a tracing session through ROS. $ sudo apt-get install python3-babeltrace python3-lttngIf the ROS 2 development tools and dependencies are not installed on your machine, install them by following the System setup section here. Now we’ll download all the necessary packages. First, create your workspace. $ mkdir -p ~/ros2_ws/src$ cd ros2_ws/The rcl and rclcpp instrumentation has been integrated into Eloquent, so we simply need to recompile ros2_tracing &amp; compile tracetools_analysis. $ wget https://gitlab. com/ros-tracing/ros2_tracing/raw/master/tracing. repos$ vcs import src &lt; tracing. reposNow let’s build and source. $ colcon build --symlink-install$ source install/local_setup. bashSimple tracing example: Let’s try tracing with a simple ping-pong example. The tracetools_test package contains two nodes we can use. The first node, test_ping, publishes messages on the ping topic and waits for a message on the pong topic before shutting down. The second node, test_pong, waits for a message on the ping topic, then sends a message on the pong topic and shuts down. To trace these nodes, we can use the example. launch. py launch file in the tracetools_launch package. $ ros2 launch tracetools_launch example. launch. pyAs shown above, you should see a few output lines, and that’s it. By default, traces are written in the ~/. ros/tracing/ directory. You can take a look at the trace’s events using babeltrace. $ cd ~/. ros/tracing/$ babeltrace my-tracing-session/If you only want to see the ROS events, you can instead do: $ babeltrace my-tracing-session/ust/The last part of the babeltrace output is shown above. This is a human-readable version of the raw Common Trace Format (CTF) data, which is a list of events. Each event has a timestamp, an event type, some information on the process that generated the event, and the fields corresponding to the event type. The last events of our trace are pairs of ros2:callback_start and ros2:callback_end events. Each one contains a reference to its corresponding callback. It’s now time to process the trace data! The tracetools_analysis package provides tools to import a trace and process it. Since reading a CTF trace is slow, it first converts it to a file which we can read much faster later on. Then we can process it to get pandas dataframes and use those to run analyses. $ ros2 trace-analysis process ~/. ros/tracing/my-tracing-session/ust/The output of the process command is shown above. In the last dataframe, named “Callback instances,” you should see three rows. The first one is the timer callback that triggered the ping-pong sequence. The second one is the ping callback, and the third one is the pong callback! Callback function symbols are shown in the previous dataframe. This is simple, but it isn’t really nice visually. We can use a Jupyter notebook to analyze the data and display the results. Callback duration analysis: Add the following line to the arguments of each of the two Node objects in your launch file, which should be under ros2_ws/src/ros-tracing/ros2_tracing/tracetools_launch/launch/. It will stop the nodes from shutting down after 1 exchange. arguments=['do_more']Delete the previous trace directory, rebuild the workspace, and execute the launch file again. Let it run for some time (e. g. 10-20 seconds), then kill it with Ctrl+C. To run an analysis that displays durations of callbacks over time, use this Jupyter notebook, which should be under ros2_ws/src/tracetools_analysis/tracetools_analysis/analysis/. The resulting plots for the /ping and /pong subscriptions are shown below. We can see that the durations vary greatly. Relevant links: The tracing packages can be found in the ros2_tracing repo. The analysis tools can be found in the tracetools_analysis repo. "
        }, {
        "id": 127,
        "url": "https://micro-ros.github.io//docs/tutorials/core/first_application_linux/",
        "title": "First micro-ROS Application on Linux",
        "body": " - Target platform: In this tutorial, you’ll learn the use of micro-ROS with Linux by testing a Ping Pong application. In the follow-up tutorial First micro-ROS application on an RTOS,you’ll learn how to build and bring this application on a microcontroller running the RTOS NuttX, FreeRTOS, or Zephyr. Finally, in the tutorial Zephyr Emulator you’ll learn how to testa micro-ROS application on a Zephyr emulator. Installing ROS 2 and the micro-ROS build system: First of all, install ROS 2 Foxy FitzRoy on your Ubuntu 20. 04 LTS computer. To do so from binaries, via Debian packages, follow the instructions detailedhere. TIP: Alternatively, you can use a docker container with a fresh ROS 2 Foxy installation. The one that servesthe purpose is the container run by the command: docker run -it --net=host -v /dev:/dev --privileged ros:foxyOnce you have a ROS 2 installation in the computer, follow these steps to install the micro-ROS build system: # Source the ROS 2 installationsource /opt/ros/$ROS_DISTRO/setup. bash# Create a workspace and download the micro-ROS toolsmkdir microros_wscd microros_wsgit clone -b $ROS_DISTRO https://github. com/micro-ROS/micro_ros_setup. git src/micro_ros_setup# Update dependencies using rosdepsudo apt update &amp;&amp; rosdep updaterosdep install --from-path src --ignore-src -y# Install pipsudo apt-get install python3-pip# Build micro-ROS tools and source themcolcon buildsource install/local_setup. bashThese instructions will setup a workspace with a ready-to-use micro-ROS build system. This build system is in charge of downloading the required cross-compilation tools and building the apps for therequired platforms. The build system’s workflow is a four-step procedure:  Create step: This step is in charge of downloading all the required code repositories and cross-compilationtoolchains for the specific hardware platform. Among these repositories, it will also download a collection of readyto use micro-ROS apps.  Configure step: In this step, the user can select which app is going to be cross-compiled by the toolchain. Some other options, such as transport, agent’s IP address/port (for UDP transport) or device ID (for serial connections) will be also selected in this step.  Build step: Here is where the cross-compilation takes place and the platform-specific binaries are generated.  Flash step: The binaries generated in the previous step are flashed onto the hardware platform memory,in order to allow the execution of the micro-ROS app. Further information about micro-ROS build system can be foundhere. Creating a new firmware workspace: Once the build system is installed, let’s create a firmware workspace that targets all the required code and tools: # Create firmware stepros2 run micro_ros_setup create_firmware_ws. sh hostOnce the command is executed, a folder named firmware must be present in your workspace. This step is in charge, among other things, of downloading a set of micro-ROS apps for Linux, that are located atsrc/uros/micro-ROS-demos/rcl. Each app is represented by a folder containing the following files:  main. c: This file contains the logic of the application.  CMakeLists. txt: This is the CMake file containing the script to compile the application. For the user to create its custom application, a folder &lt;my_app&gt; will need to be registered in this location,containing the two files just described. Also, any such new application folder needs to be registered insrc/uros/micro-ROS-demos/rcl/CMakeLists. txt by adding the following line: export_executable(&lt;my_app&gt;)In this tutorial, we will focus on the out-of-the-box ping_pong application located atsrc/uros/micro-ROS-demos/rcl/ping_pong. You can check the complete content of this apphere. This example showcases a micro-ROS node with two publisher-subscriber pairs associated with a ping and a pongtopics, respectively. The node sends a ping package with a unique identifier, using a ping publisher. If the ping subscriber receives a ping from an external node, the pong publisher responds to the incoming pingwith a pong. To test that this logic is correctly functioning, we implement communication with a ROS 2 node that:  Listens to the topics published by the ping subscriber.  Publishes a fake_ping package, that is received by the micro-ROS ping subscriber. As a consequence, the pong publisher on the micro-ROS application will publish a pong, to signal that it receivedthe fake_ping correctly. The diagram below clarifies the communication flow between these entities: The contents of the host app specific files can be found here:main. c andCMakeLists. txt. A thorough review of these files is illustrative of how to create a micro-ROS app in this RTOS. Building the firmware: Once the app has been created, the build step is in order. Notice that, with respect to the four-steps workflow delined above, we would expect a configuration step to happenbefore building the app. However, given that we are compiling micro-ROS in the host machine rather than in a board,the cross-compilation implemented by the configuration step is not required in this case. We can therefore proceed to build the firmware and source the local installation: # Build stepros2 run micro_ros_setup build_firmware. shsource install/local_setup. bashCreating the micro-ROS agent: The micro-ROS app is now ready to be connected to a micro-ROS agent to start talking with the rest of the ROS 2world. To do that, let’s first of all create a micro-ROS agent: # Download micro-ROS-Agent packagesros2 run micro_ros_setup create_agent_ws. shNow, let’s build the agent packages and, when this is done, source the installation: # Build stepros2 run micro_ros_setup build_agent. shsource install/local_setup. bashRunning the micro-ROS app: At this point, you have both the client and the agent correctly installed in your host machine. To give micro-ROS access to the ROS 2 dataspace, run the agent: # Run a micro-ROS agentros2 run micro_ros_agent micro_ros_agent udp4 --port 8888And then, in another command line, run the micro-ROS node (remember sourcing the ROS 2 and micro-ROS installations, and setting the RMW Micro XRCE-DDS implementation): source /opt/ros/$ROS_DISTRO/setup. bashsource install/local_setup. bash# Use RMW Micro XRCE-DDS implementationexport RMW_IMPLEMENTATION=rmw_microxrcedds# Run a micro-ROS noderos2 run micro_ros_demos_rclc ping_pongTesting the micro-ROS app: Now, we want to check that everything is working. Open a new command line. We are going to listen to the ping topicwith ROS 2 to check whether the micro-ROS Ping Pong node is correctly publishing the expected pings: source /opt/ros/$ROS_DISTRO/setup. bash# Subscribe to micro-ROS ping topicros2 topic echo /microROS/pingYou should see the topic messages published by the Ping Pong node every 5 seconds: user@user:~$ ros2 topic echo /microROS/pingstamp: sec: 20 nanosec: 867000000frame_id: '1344887256_1085377743'---stamp: sec: 25 nanosec: 942000000frame_id: '730417256_1085377743'---At this point, we know that our app is publishing pings. Let’s check if it also answers to someone else’s pings. If this works, it’ll publish a pong. So, first of all, let’s subscribe with ROS 2 to the pong topic from a new shell(notice that initially we don’t expect to receive any pong, since none has been sent yet): source /opt/ros/$ROS_DISTRO/setup. bash# Subscribe to micro-ROS pong topicros2 topic echo /microROS/pongAnd now, let’s publish a fake_ping with ROS 2 from yet another command line: source /opt/ros/$ROS_DISTRO/setup. bash# Send a fake pingros2 topic pub --once /microROS/ping std_msgs/msg/Header '{frame_id:  fake_ping }'Now, we should see this fake_ping in the ping subscriber console,along with the micro-ROS pings: user@user:~$ ros2 topic echo /microROS/pingstamp: sec: 0 nanosec: 0frame_id: fake_ping---stamp: sec: 305 nanosec: 973000000frame_id: '451230256_1085377743'---stamp: sec: 310 nanosec: 957000000frame_id: '2084670932_1085377743'---Also, we expect that, because of having received the fake_ping, the micro-ROS node will answer with a pong: user@user:~$ ros2 run micro_ros_demos_rcl ping_pongPing send seq 1706097268_1085377743Ping send seq 181171802_1085377743Ping send seq 1385567526_1085377743Ping send seq 926583793_1085377743Ping send seq 1831510138_1085377743Ping received with seq fake_ping. Answering. Ping send seq 1508705084_1085377743Ping send seq 1702133625_1085377743Ping send seq 176104820_1085377743As a consequence, in the pong subscriber console,we should see the micro-ROS app answer to our fake_ping: user@user:~$ ros2 topic echo /microROS/pongstamp: sec: 0 nanosec: 0frame_id: fake_ping---Multiple Ping Pong nodes: One of the advantages of having a Linux micro-ROS app is that you don’t need to buy a bunch of hardware in order totest some multi-node micro-ROS apps. So, with the same micro-ROS agent of the last section, let’s open four different command lines and run the following oneach: cd microros_wssource /opt/ros/$ROS_DISTRO/setup. bashsource install/local_setup. bashros2 run micro_ros_demos_rclc ping_pongAs soon as all micro-ROS nodes are up and connected to the micro-ROS agent you will see them interacting: user@user:~$ ros2 run micro_ros_demos_rclc ping_pongPing send seq 1711620172_1742614911             &lt;---- This micro-ROS node sends a ping with ping ID  1711620172  and node ID  1742614911 Pong for seq 1711620172_1742614911 (1)           &lt;---- The first mate pongs my pingPong for seq 1711620172_1742614911 (2)           &lt;---- The second mate pongs my pingPong for seq 1711620172_1742614911 (3)           &lt;---- The third mate pongs my pingPing received with seq 1845948271_546591567. Answering.   &lt;---- A ping is received from a mate identified as  546591567 , let's pong it. Ping received with seq 232977719_1681483056. Answering.   &lt;---- A ping is received from a mate identified as  1681483056 , let's pong it. Ping received with seq 1134264528_1107823050. Answering.   &lt;---- A ping is received from a mate identified as  1107823050 , let's pong it. Ping send seq 324239260_1742614911Pong for seq 324239260_1742614911 (1)Pong for seq 324239260_1742614911 (2)Pong for seq 324239260_1742614911 (3)Ping received with seq 1435780593_546591567. Answering. Ping received with seq 2034268578_1681483056. Answering. "
        }, {
        "id": 128,
        "url": "https://micro-ros.github.io//docs/tutorials/core/first_application_rtos/freertos/",
        "title": "First micro-ROS Application on FreeRTOS",
        "body": " - Target platform: In this tutorial, you’ll learn the use of micro-ROS with FreeRTOS by testing a Ping Pong application. The target hardware for this tutorial is theOlimex STM32-E407 evaluation board. The following hardware will be used:  Olimex STM32-E407 Olimex ARM-USB-TINY-H USB-to-Serial Cable FemaleInstalling ROS 2 and the micro-ROS build system: First of all, install ROS 2 Foxy FitzRoy on your Ubuntu 20. 04 LTS computer. To do so from binaries, via Debian packages, follow the instructions detailedhere. TIP: Alternatively, you can use a docker container with a fresh ROS 2 Foxy installation. The one that servesthe purpose is the container run by the command: docker run -it --net=host -v /dev:/dev --privileged ros:foxyOnce you have a ROS 2 installation in the computer, follow these steps to install the micro-ROS build system: # Source the ROS 2 installationsource /opt/ros/$ROS_DISTRO/setup. bash# Create a workspace and download the micro-ROS toolsmkdir microros_wscd microros_wsgit clone -b $ROS_DISTRO https://github. com/micro-ROS/micro_ros_setup. git src/micro_ros_setup# Update dependencies using rosdepsudo apt update &amp;&amp; rosdep updaterosdep install --from-path src --ignore-src -y# Install pipsudo apt-get install python3-pip# Build micro-ROS tools and source themcolcon buildsource install/local_setup. bashThese instructions will setup a workspace with a ready-to-use micro-ROS build system. This build system is in charge of downloading the required cross-compilation tools and building the apps for therequired platforms. The build system’s workflow is a four-step procedure:  Create step: This step is in charge of downloading all the required code repositories and cross-compilationtoolchains for the specific hardware platform. Among these repositories, it will also download a collection of readyto use micro-ROS apps.  Configure step: In this step, the user can select which app is going to be cross-compiled by the toolchain. Some other options, such as transport, agent’s IP address/port (for UDP transport) or device ID (for serial connections) will be also selected in this step.  Build step: Here is where the cross-compilation takes place and the platform-specific binaries are generated.  Flash step: The binaries generated in the previous step are flashed onto the hardware platform memory,in order to allow the execution of the micro-ROS app. Further information about micro-ROS build system can be foundhere. Creating a new firmware workspace: Once the build system is installed, let’s create a firmware workspace that targets all the required code and tools: # Create stepros2 run micro_ros_setup create_firmware_ws. sh freertos olimex-stm32-e407Once the command is executed, a folder named firmware must be present in your workspace. This step is in charge, among other things, of downloading a set of micro-ROS apps for the specific platform you areaddressing. In the case of FreeRTOS, these are located at firmware/freertos_apps/apps. Each app is represented by a folder containing the following files:  app. c: This file contains the logic of the application.  app-colcon. meta: This file contains the micro-ROS app specific colcon configuration. Detailed info on how toconfigure the RMW via this file can be foundhere. For the user to create its custom application, a folder &lt;my_app&gt; will need to be registered in this location,containing the two files just described. Configuring the firmware: The configuration step will set up the main micro-ROS options and select the desired application. It can be executed with the following command: # Configure stepros2 run micro_ros_setup configure_firmware. sh [APP] [OPTIONS]The options available for this configuration step are:  --transport or -t: udp, serial or any hardware-specific transport label --dev or -d: agent string descriptor in a serial-like transport --ip or -i: agent IP in a network-like transport --port or -p: agent port in a network-like transportIn this tutorial, we will use a Serial transport (labeled as serial) and focus on the out-of-the-box ping_pongapplication located at firmware/freertos_apps/apps/ping_pong. To execute this application with the chosen transport,run the configuration command above by specifying the [APP] and [OPTIONS] parameters as below: # Configure step with ping_pong app and serial transportros2 run micro_ros_setup configure_firmware. sh ping_pong --transport serialYou can check the complete content of the ping_pong apphere. This example showcases a micro-ROS node with two publisher-subscriber pairs associated with a ping and a pongtopics, respectively. The node sends a ping package with a unique identifier, using a ping publisher. If the ping subscriber receives a ping from an external node, the pong publisher responds to the incoming pingwith a pong. To test that this logic is correctly functioning, we implement communication with a ROS 2 node that:  Listens to the topics published by the ping subscriber.  Publishes a fake_ping package, that is received by the micro-ROS ping subscriber. As a consequence, the pong publisher on the micro-ROS application will publish a pong, to signal that it receivedthe fake_ping correctly. The diagram below clarifies the communication flow between these entities: The contents of the FreeRTOS app specific files can be found here:app. c andapp-colcon. meta. A thorough review of these files is illustrative of how to create a micro-ROS app in this RTOS. Building the firmware: When the configuring step ends, just build the firmware: # Build stepros2 run micro_ros_setup build_firmware. shFlashing the firmware: Flashing the firmware into the platform varies across hardware platforms. Regarding this tutorial’s target platform(Olimex STM32-E407),the JTAG interface is going to be used to flash the firmware. Connect the Olimex ARM-USB-TINY-H to the board: Make sure that the board power supply jumper (PWR_SEL) is in the 3-4 position in order to power the board from theJTAG connector: Once you have your computer connected to the Olimex board through the JTAG adapter, run the flash step: # Flash stepros2 run micro_ros_setup flash_firmware. shCreating the micro-ROS agent: The micro-ROS app is now ready to be connected to a micro-ROS agent to start talking with the rest of the ROS 2world. To do that, let’s first of all create a micro-ROS agent: # Download micro-ROS-Agent packagesros2 run micro_ros_setup create_agent_ws. shNow, let’s build the agent packages and, when this is done, source the installation: # Build stepros2 run micro_ros_setup build_agent. shsource install/local_setup. bashThen, depending on the selected transport and RTOS, the board connection to the agent may differ. In this tutorial, we’re using the Olimex STM32-E407 Serial connection, for which the Olimex development board isconnected to the computer using the usb to serial cable.  TIP: Color codes are applicable tothis cable. Make sure to match Olimex Rx with Cable Tx and vice-versa. Remember GND! Running the micro-ROS app: At this point, you have both the client and the agent correctly installed. To give micro-ROS access to the ROS 2 dataspace, you just need to run the agent: # Run a micro-ROS agentros2 run micro_ros_agent micro_ros_agent serial --dev [device]TIP: you can use this command to find your serial device name: ls /dev/serial/by-id/* Testing the micro-ROS app: At this point, the micro-ROS app is built and flashed and the board is connected to a micro-ROS agent. We now want to check that everything is working. Open a new command line. We are going to listen to the ping topicwith ROS 2 to check whether the micro-ROS Ping Pong node is correctly publishing the expected pings: source /opt/ros/$ROS_DISTRO/setup. bash# Subscribe to micro-ROS ping topicros2 topic echo /microROS/pingYou should see the topic messages published by the Ping Pong node every 5 seconds: user@user:~$ ros2 topic echo /microROS/pingstamp: sec: 20 nanosec: 867000000frame_id: '1344887256_1085377743'---stamp: sec: 25 nanosec: 942000000frame_id: '730417256_1085377743'---At this point, we know that our micro-ROS app is publishing pings. Let’s check if it also answers to someone else’s pings. If this works, it’ll publish a pong. So, first of all, let’s subscribe with ROS 2 to the pong topic from a new shell(notice that initially we don’t expect to receive any pong, since none has been sent yet): source /opt/ros/$ROS_DISTRO/setup. bash# Subscribe to micro-ROS pong topicros2 topic echo /microROS/pongAnd now, let’s publish a fake_ping with ROS 2 from yet another command line: source /opt/ros/$ROS_DISTRO/setup. bash# Send a fake pingros2 topic pub --once /microROS/ping std_msgs/msg/Header '{frame_id:  fake_ping }'Now, we should see this fake_ping in the ping subscriber console,along with the board’s pings: user@user:~$ ros2 topic echo /microROS/pingstamp: sec: 0 nanosec: 0frame_id: fake_ping---stamp: sec: 305 nanosec: 973000000frame_id: '451230256_1085377743'---stamp: sec: 310 nanosec: 957000000frame_id: '2084670932_1085377743'---Also, we expect that, because of having received the fake_ping, the micro-ROS pong publisher will answer with apong. As a consequence, in the pong subscriber console,we should see the board’s answer to our fake_ping: user@user:~$ ros2 topic echo /microROS/pongstamp: sec: 0 nanosec: 0frame_id: fake_ping---Multiple Ping Pong nodes: If you have multiple boards, by connecting them to the same ROS 2 space it is possible to see them interacting. In the case you only have one board, it is possible to see your micro-ROS ping pong app running on hardware interactingwith the ping pong app from the Linux tutorial. When multiple ping pong nodes coexists,it is possible to see their output like this micro-ROS for Linux app: Ping send seq 1711620172_1742614911           &lt;---- This micro-ROS node sends a ping with ping ID  1711620172  and node ID  1742614911 Pong for seq 1711620172_1742614911 (1)          &lt;---- The first mate pongs my pingPong for seq 1711620172_1742614911 (2)          &lt;---- The second mate pongs my pingPong for seq 1711620172_1742614911 (3)          &lt;---- The third mate pongs my pingPing received with seq 1845948271_546591567. Answering.  &lt;---- A ping is received from a mate identified as  546591567 , let's pong it. Ping received with seq 232977719_1681483056. Answering.  &lt;---- A ping is received from a mate identified as  1681483056 , let's pong it. Ping received with seq 1134264528_1107823050. Answering. &lt;---- A ping is received from a mate identified as  1107823050 , let's pong it. Ping send seq 324239260_1742614911Pong for seq 324239260_1742614911 (1)Pong for seq 324239260_1742614911 (2)Pong for seq 324239260_1742614911 (3)Ping received with seq 1435780593_546591567. Answering. Ping received with seq 2034268578_1681483056. Answering. This completes the First micro-ROS Application on FreeRTOS tutorial. Do you want to go back and try a different RTOS, i. e. NuttX or Zephyr? "
        }, {
        "id": 129,
        "url": "https://micro-ros.github.io//docs/tutorials/core/first_application_rtos/",
        "title": "First micro-ROS Application on an RTOS",
        "body": " - After you have completed the First micro-ROS application on Linux tutorial, you are now ready to flash a microcontroller with this application based on a Real-Time Operating System (RTOS). Micro-ROS currently supports three different RTOS, namely NuttX, FreeRTOS, and Zephyr. Of course, the micro-ROS-related sections of the application code are independent of the underlying RTOS. Also, the basic tooling is the same as we have integrated the RTOS tools with the ROS 2 meta build system colcon. However, there are subtle differences in the configuration and the definition of the executables between the three RTOS. Therefore, for this tutorial, please decide for one RTOS to use:  NuttX FreeRTOS Zephyr Disclaimer: All logos and product names are property of their respective owners. All company names, logos and product names used in this website are for identification purposes only. Their use does not imply endorsement. "
        }, {
        "id": 130,
        "url": "https://micro-ros.github.io//docs/tutorials/core/first_application_rtos/nuttx/",
        "title": "First micro-ROS Application on NuttX",
        "body": " - Target platform: In this tutorial, you’ll learn the use of micro-ROS with NuttX by testing a Ping Pong application. The target hardware for this tutorial is theOlimex STM32-E407 evaluation board. The following hardware will be used:  Olimex STM32-E407 Olimex ARM-USB-TINY-H USB-to-Serial Cable Female USB-to-mini-USB cableInstalling ROS 2 and the micro-ROS build system: First of all, install ROS 2 Foxy FitzRoy on your Ubuntu 20. 04 LTS computer. To do so from binaries, via Debian packages, follow the instructions detailedhere. TIP: Alternatively, you can use a docker container with a fresh ROS 2 Foxy installation. The one that servesthe purpose is the container run by the command: docker run -it --net=host -v /dev:/dev --privileged ros:foxyOnce you have a ROS 2 installation in the computer, follow these steps to install the micro-ROS build system: # Source the ROS 2 installationsource /opt/ros/$ROS_DISTRO/setup. bash# Create a workspace and download the micro-ROS toolsmkdir microros_wscd microros_wsgit clone -b $ROS_DISTRO https://github. com/micro-ROS/micro_ros_setup. git src/micro_ros_setup# Update dependencies using rosdepsudo apt update &amp;&amp; rosdep updaterosdep install --from-path src --ignore-src -y# Install pipsudo apt-get install python3-pip# Build micro-ROS tools and source themcolcon buildsource install/local_setup. bashThese instructions will setup a workspace with a ready-to-use micro-ROS build system. This build system is in charge of downloading the required cross-compilation tools and building the apps for therequired platforms. The build system’s workflow is a four-step procedure:  Create step: This step is in charge of downloading all the required code repositories and cross-compilationtoolchains for the specific hardware platform. Among these repositories, it will also download a collection of readyto use micro-ROS apps.  Configure step: In this step, the user can select which app is going to be cross-compiled by the toolchain. Some other options, such as transport, agent’s IP address/port (for UDP transport) or device ID (for serial connections) will be also selected in this step.  Build step: Here is where the cross-compilation takes place and the platform-specific binaries are generated.  Flash step: The binaries generated in the previous step are flashed onto the hardware platform memory,in order to allow the execution of the micro-ROS app. Further information about micro-ROS build system can be foundhere. Creating a new firmware workspace: Once the build system is installed, let’s create a firmware workspace that targets all the required code and tools: # Create stepros2 run micro_ros_setup create_firmware_ws. sh nuttx olimex-stm32-e407Once the command is executed, a folder named firmware must be present in your workspace. This step is in charge, among other things, of downloading a set of micro-ROS apps for the specific platform you areaddressing. In the case of NuttX, these are located here. Each app is represented by a folder containing the following files:  app. c: This file contains the logic of the application.  Kconfig: This file contains the NuttX Kconfig configuration.  Make. defs: This file contains the	NuttX build system definitions.  Makefile: This file contains the NuttX specific app build script. Configuring the firmware: The configuration step will set up the main micro-ROS options and select the desired application. It can be executed with the following command: # Configure stepros2 run micro_ros_setup configure_firmware. sh [APP] [OPTIONS]The options available for this configuration step are:  --transport or -t: udp, serial or any hardware-specific transport label --dev or -d: agent string descriptor in a serial-like transport --ip or -i: agent IP in a network-like transport --port or -p: agent port in a network-like transportIn this tutorial, we will use a Serial transport (labeled as serial) and focus on the out-of-the-box uros_pingpongapplication located here. To execute this application with the chosen transport, run the configuration command above by specifying the [APP] parameter as below: # Configure step with ping_pong app and serial-usb transportros2 run micro_ros_setup configure_firmware. sh drive_baseand with no [OPTIONS] parameter. To proceed with the configuration, clone the following NuttX tools repo: # Download the tools necessary to work with NuttXgit clone https://bitbucket. org/nuttx/tools. git firmware/toolsand then install the required kconfig-frontends: pushd firmware/tools/kconfig-frontends. /configuremake# if the make command fails, type: autoreconf -f -i , and then rerun the make command. sudo make installsudo ldconfigpopdWe’ll now open an interactive NuttX menu config, which allows to modify the configuration of the RTOS, including adding a new application. cd firmware/NuttXmake menuconfigTo add the uros_pingpong application, follow the steps listed below:  On the menu, follow the path: Application Configuration ---&gt; Examples A list of the available applications will appear. You need to find: micro-ROS Ping-Pong and press the space bar to add it.  Navigate to the bottom menu with the left and right arrows, and click on the Exit button.  When you’re back to the Application Configuration menu, go to micro-ROS ---&gt; Transport (UDP transport).  A list of the available transports will appear. You need to go to Serial transport and press the space bar to set the Serial port as micro-ROS transport. After that, you’ll be automatically redirected to the previous menu.  Navigate to the bottom menu with the left and right arrows, and click on the Save button.  You will be asked if you want to save your new . config configuration, and you need to click Ok, and then Exit.  Finally, push three times the Esc key to close the menu. When the configuration process is over, go back to the microros_ws: cd . . /. . You can check the complete content of the uros_pingpong apphere. This example showcases a micro-ROS node with two publisher-subscriber pairs associated with a ping and a pongtopics, respectively. The node sends a ping package with a unique identifier, using a ping publisher. If the ping subscriber receives a ping from an external node, the pong publisher responds to the incoming pingwith a pong. To test that this logic is correctly functioning, we implement communication with a ROS 2 node that:  Listens to the topics published by the ping subscriber.  Publishes a fake_ping package, that is received by the micro-ROS ping subscriber. As a consequence, the pong publisher on the micro-ROS application will publish a pong, to signal that it receivedthe fake_ping correctly. The diagram below clarifies the communication flow between these entities: The contents of the FreeRTOS app specific files can be found here:app. c,Kconfig,Make. defs andMakefile. A thorough review of these files is illustrative of how to create a micro-ROS app in this RTOS. Building the firmware: When the configuring step ends, just build the firmware: # Build stepros2 run micro_ros_setup build_firmware. shFlashing the firmware: Flashing the firmware into the platform varies across hardware platforms. Regarding this tutorial’s target platform(Olimex STM32-E407),the JTAG interface is going to be used to flash the firmware. Connect the Olimex ARM-USB-TINY-H to the board: Make sure that the board power supply jumper (PWR_SEL) is in the 3-4 position in order to power the board from theJTAG connector: Once you have your computer connected to the Olimex board through the JTAG adapter, run the flash step: # Flash stepros2 run micro_ros_setup flash_firmware. shCreating the micro-ROS agent: The micro-ROS app is now ready to be connected to a micro-ROS agent to start talking with the rest of the ROS 2world. To do that, let’s first of all create a micro-ROS agent: # Download micro-ROS-Agent packagesros2 run micro_ros_setup create_agent_ws. shNow, let’s build the agent packages and, when this is done, source the installation: # Build stepros2 run micro_ros_setup build_agent. shsource install/local_setup. bashThen, depending on the selected transport and RTOS, the board connection to the agent may differ. In this tutorial, we’re using the Olimex STM32-E407 Serial connection, for which the Olimex development board isconnected to the computer using the usb to serial cable.  Additionally, you’ll need to connect a USB-to-mini-USB cable to the USB OTG 1 connector (the miniUSB connectorthat is closer to the Ethernet port).  TIP: Color codes are applicable tothis cable. Make sure to match Olimex Rx with Cable Tx and vice-versa. Remember GND! Running the micro-ROS app: At this point, you have both the client and the agent correctly installed. To give micro-ROS access to the ROS 2 dataspace, run the agent: # Run a micro-ROS agentros2 run micro_ros_agent micro_ros_agent serial --dev [device]TIP: you can use this command to find your serial device name: ls /dev/serial/by-id/* Then, in order to launch the micro-ROS application, you need to install and open Minicom,a text-based serial port communications program. Open a new shell, and type: sudo minicom -D [device] -b 115200TIP: you can use this command to find your serial device name: ls /dev/serial/by-id/*. Select the one that starts with usb-NuttX. From inside the Minicom application, press three times the Enter key until Nuttx Shell (NSH) appears. Once you enter the NSH command line, type: uros_pingpongTesting the micro-ROS app: At this point, the micro-ROS app is built and flashed and the board is connected to a micro-ROS agent. We now want to check that everything is working. Open a new command line. We are going to listen to the ping topicwith ROS 2 to check whether the micro-ROS Ping Pong node is correctly publishing the expected pings: source /opt/ros/$ROS_DISTRO/setup. bash# Subscribe to micro-ROS ping topicros2 topic echo /microROS/pingYou should see the topic messages published by the Ping Pong node every 5 seconds: user@user:~$ ros2 topic echo /microROS/pingstamp: sec: 20 nanosec: 867000000frame_id: '1344887256_1085377743'---stamp: sec: 25 nanosec: 942000000frame_id: '730417256_1085377743'---At this point, we know that our micro-ROS app is publishing pings. Let’s check if it also answers to someone else’s pings. If this works, it’ll publish a pong. So, first of all, let’s subscribe with ROS 2 to the pong topic from a new shell(notice that initially we don’t expect to receive any pong, since none has been sent yet): source /opt/ros/$ROS_DISTRO/setup. bash# Subscribe to micro-ROS pong topicros2 topic echo /microROS/pongAnd now, let’s publish a fake_ping with ROS 2 from yet another command line: source /opt/ros/$ROS_DISTRO/setup. bash# Send a fake pingros2 topic pub --once /microROS/ping std_msgs/msg/Header '{frame_id:  fake_ping }'Now, we should see this fake_ping in the ping subscriber console,along with the board’s pings: user@user:~$ ros2 topic echo /microROS/pingstamp: sec: 0 nanosec: 0frame_id: fake_ping---stamp: sec: 305 nanosec: 973000000frame_id: '451230256_1085377743'---stamp: sec: 310 nanosec: 957000000frame_id: '2084670932_1085377743'---Also, we expect that, because of having received the fake_ping, the micro-ROS pong publisher will answer with apong. As a consequence, in the pong subscriber console,we should see the board’s answer to our fake_ping: user@user:~$ ros2 topic echo /microROS/pongstamp: sec: 0 nanosec: 0frame_id: fake_ping---Multiple Ping Pong nodes: If you have multiple boards, by connecting them to the same ROS 2 space it is possible to see them interacting. In the case you only have one board, it is possible to see your micro-ROS ping pong app running on hardware interactingwith the ping pong app from the Linux tutorial. When multiple ping pong nodes coexists,it is possible to see their output like this micro-ROS for Linux app: Ping send seq 1711620172_1742614911           &lt;---- This micro-ROS node sends a ping with ping ID  1711620172  and node ID  1742614911 Pong for seq 1711620172_1742614911 (1)          &lt;---- The first mate pongs my pingPong for seq 1711620172_1742614911 (2)          &lt;---- The second mate pongs my pingPong for seq 1711620172_1742614911 (3)          &lt;---- The third mate pongs my pingPing received with seq 1845948271_546591567. Answering.  &lt;---- A ping is received from a mate identified as  546591567 , let's pong it. Ping received with seq 232977719_1681483056. Answering.  &lt;---- A ping is received from a mate identified as  1681483056 , let's pong it. Ping received with seq 1134264528_1107823050. Answering. &lt;---- A ping is received from a mate identified as  1107823050 , let's pong it. Ping send seq 324239260_1742614911Pong for seq 324239260_1742614911 (1)Pong for seq 324239260_1742614911 (2)Pong for seq 324239260_1742614911 (3)Ping received with seq 1435780593_546591567. Answering. Ping received with seq 2034268578_1681483056. Answering. This completes the First micro-ROS Application on NuttX tutorial. Do you want to go back and try a different RTOS, i. e. FreeRTOS or Zephyr? "
        }, {
        "id": 131,
        "url": "https://micro-ros.github.io//docs/tutorials/core/first_application_rtos/zephyr/",
        "title": "First micro-ROS Application on Zephyr",
        "body": " - Target platform: In this tutorial, you’ll learn the use of micro-ROS with Zephyr by testing a Ping Pong application. The target hardware for this tutorial is theOlimex STM32-E407 evaluation board. The following hardware will be used:  Olimex STM32-E407 Olimex ARM-USB-TINY-H USB-to-mini-USB cableInstalling ROS 2 and the micro-ROS build system: First of all, install ROS 2 Foxy FitzRoy on your Ubuntu 20. 04 LTS computer. To do so from binaries, via Debian packages, follow the instructions detailedhere. TIP: Alternatively, you can use a docker container with a fresh ROS 2 Foxy installation. The one that servesthe purpose is the container run by the command: docker run -it --net=host -v /dev:/dev --privileged ros:foxyOnce you have a ROS 2 installation in the computer, follow these steps to install the micro-ROS build system: # Source the ROS 2 installationsource /opt/ros/$ROS_DISTRO/setup. bash# Create a workspace and download the micro-ROS toolsmkdir microros_wscd microros_wsgit clone -b $ROS_DISTRO https://github. com/micro-ROS/micro_ros_setup. git src/micro_ros_setup# Update dependencies using rosdepsudo apt update &amp;&amp; rosdep updaterosdep install --from-path src --ignore-src -y# Install pipsudo apt-get install python3-pip# Build micro-ROS tools and source themcolcon buildsource install/local_setup. bashThese instructions will setup a workspace with a ready-to-use micro-ROS build system. This build system is in charge of downloading the required cross-compilation tools and building the apps for therequired platforms. The build system’s workflow is a four-step procedure:  Create step: This step is in charge of downloading all the required code repositories and cross-compilationtoolchains for the specific hardware platform. Among these repositories, it will also download a collection of readyto use micro-ROS apps.  Configure step: In this step, the user can select which app is going to be cross-compiled by the toolchain. Some other options, such as transport, agent’s IP address/port (for UDP transport) or device ID (for serial connections) will be also selected in this step.  Build step: Here is where the cross-compilation takes place and the platform-specific binaries are generated.  Flash step: The binaries generated in the previous step are flashed onto the hardware platform memory,in order to allow the execution of the micro-ROS app. Further information about micro-ROS build system can be foundhere. Creating a new firmware workspace: Once the build system is installed, let’s create a firmware workspace that targets all the required code and tools: # Create stepros2 run micro_ros_setup create_firmware_ws. sh zephyr olimex-stm32-e407Once the command is executed, a folder named firmware must be present in your workspace. This step is in charge, among other things, of downloading a set of micro-ROS apps for the specific platform you areaddressing. In the case of Zephyr, these are located at firmware/zephyr_apps/apps. Each app is represented by a folder containing the following files:  src/main. c: This file contains the logic of the application.  app-colcon. meta: This file contains the micro-ROS app specific colcon configuration. Detailed info on how toconfigure the RMW via this file can be foundhere.  CMakeLists. txt: This is the CMake file containing the script to compile the application.  &lt;transport&gt;. conf: This is a Zephyr specific and transport-dependent app configuration file. &lt;transport&gt; can be serial, serial-usb and host-udp. For the user to create its custom application, a folder &lt;my_app&gt; will need to be registered in this location,containing the four files just described. Configuring the firmware: The configuration step will set up the main micro-ROS options and select the desired application. It can be executed with the following command: # Configure stepros2 run micro_ros_setup configure_firmware. sh [APP] [OPTIONS]The options available for this configuration step are:  --transport or -t: udp, serial or any hardware-specific transport label --dev or -d: agent string descriptor in a serial-like transport --ip or -i: agent IP in a network-like transport --port or -p: agent port in a network-like transportIn this tutorial, we will use a USB transport (labeled as serial-usb) and focus on the out-of-the-box ping_pongapplication located at firmware/zephyr_apps/apps/ping_pong. To execute this application with the chosen transport,run the configuration command above by specifying the [APP] and [OPTIONS] parameters as below: # Configure step with ping_pong app and serial-usb transportros2 run micro_ros_setup configure_firmware. sh ping_pong --transport serial-usbYou can check the complete content of the ping_pong apphere. This example showcases a micro-ROS node with two publisher-subscriber pairs associated with a ping and a pongtopics, respectively. The node sends a ping package with a unique identifier, using a ping publisher. If the ping subscriber receives a ping from an external node, the pong publisher responds to the incoming pingwith a pong. To test that this logic is correctly functioning, we implement communication with a ROS 2 node that:  Listens to the topics published by the ping subscriber.  Publishes a fake_ping package, that is received by the micro-ROS ping subscriber. As a consequence, the pong publisher on the micro-ROS application will publish a pong, to signal that it receivedthe fake_ping correctly. The diagram below clarifies the communication flow between these entities: The contents of the Zephyr app specific files can be found here:main. c,app-colcon. meta,CMakeLists. txtand serial-usb. conf. A thorough review of these files is illustrative of how to create a micro-ROS app in this RTOS. Building the firmware: When the configuring step ends, just build the firmware: # Build stepros2 run micro_ros_setup build_firmware. shFlashing the firmware: Flashing the firmware into the platform varies across hardware platforms. Regarding this tutorial’s target platform(Olimex STM32-E407),the JTAG interface is going to be used to flash the firmware. Connect the Olimex ARM-USB-TINY-H to the board: Make sure that the board power supply jumper (PWR_SEL) is in the 3-4 position in order to power the board from theJTAG connector: Once you have your computer connected to the Olimex board through the JTAG adapter, run the flash step: # Flash stepros2 run micro_ros_setup flash_firmware. shCreating the micro-ROS agent: The micro-ROS app is now ready to be connected to a micro-ROS agent to start talking with the rest of the ROS 2world. To do that, let’s first of all create a micro-ROS agent: # Download micro-ROS-Agent packagesros2 run micro_ros_setup create_agent_ws. shNow, let’s build the agent packages and, when this is done, source the installation: # Build stepros2 run micro_ros_setup build_agent. shsource install/local_setup. bashThen, depending on the selected transport and RTOS, the board connection to the agent may differ. In this tutorial, we’re using the Olimex STM32-E407 USB connection, for which the Olimex development board is connectedto the computer using the USB OTG 2 connector (the miniUSB connector that is furthest from the Ethernet port).  Running the micro-ROS app: At this point, you have both the client and the agent correctly installed. To give micro-ROS access to the ROS 2 dataspace, you just need to run the agent: # Run a micro-ROS agentros2 run micro_ros_agent micro_ros_agent serial --dev [device]TIP: you can use this command to find your serial device name: ls /dev/serial/by-id/* Testing the micro-ROS app: At this point, the micro-ROS app is built and flashed and the board is connected to a micro-ROS agent. We now want to check that everything is working. Open a new command line. We are going to listen to the ping topicwith ROS 2 to check whether the micro-ROS Ping Pong node is correctly publishing the expected pings: source /opt/ros/$ROS_DISTRO/setup. bash# Subscribe to micro-ROS ping topicros2 topic echo /microROS/pingYou should see the topic messages published by the Ping Pong node every 5 seconds: user@user:~$ ros2 topic echo /microROS/pingstamp: sec: 20 nanosec: 867000000frame_id: '1344887256_1085377743'---stamp: sec: 25 nanosec: 942000000frame_id: '730417256_1085377743'---At this point, we know that our micro-ROS app is publishing pings. Let’s check if it also answers to someone else’s pings. If this works, it’ll publish a pong. So, first of all, let’s subscribe with ROS 2 to the pong topic from a new shell(notice that initially we don’t expect to receive any pong, since none has been sent yet): source /opt/ros/$ROS_DISTRO/setup. bash# Subscribe to micro-ROS pong topicros2 topic echo /microROS/pongAnd now, let’s publish a fake_ping with ROS 2 from yet another command line: source /opt/ros/$ROS_DISTRO/setup. bash# Send a fake pingros2 topic pub --once /microROS/ping std_msgs/msg/Header '{frame_id:  fake_ping }'Now, we should see this fake_ping in the ping subscriber console,along with the board’s pings: user@user:~$ ros2 topic echo /microROS/pingstamp: sec: 0 nanosec: 0frame_id: fake_ping---stamp: sec: 305 nanosec: 973000000frame_id: '451230256_1085377743'---stamp: sec: 310 nanosec: 957000000frame_id: '2084670932_1085377743'---Also, we expect that, because of having received the fake_ping, the micro-ROS pong publisher will answer with apong. As a consequence, in the pong subscriber console,we should see the board’s answer to our fake_ping: user@user:~$ ros2 topic echo /microROS/pongstamp: sec: 0 nanosec: 0frame_id: fake_ping---Multiple Ping Pong nodes: If you have multiple boards, by connecting them to the same ROS 2 space it is possible to see them interacting. In the case you only have one board, it is possible to see your micro-ROS ping pong app running on hardware interactingwith the ping pong app from the Linux tutorial. When multiple ping pong nodes coexists,it is possible to see their output like this micro-ROS for Linux app: Ping send seq 1711620172_1742614911           &lt;---- This micro-ROS node sends a ping with ping ID  1711620172  and node ID  1742614911 Pong for seq 1711620172_1742614911 (1)          &lt;---- The first mate pongs my pingPong for seq 1711620172_1742614911 (2)          &lt;---- The second mate pongs my pingPong for seq 1711620172_1742614911 (3)          &lt;---- The third mate pongs my pingPing received with seq 1845948271_546591567. Answering.  &lt;---- A ping is received from a mate identified as  546591567 , let's pong it. Ping received with seq 232977719_1681483056. Answering.  &lt;---- A ping is received from a mate identified as  1681483056 , let's pong it. Ping received with seq 1134264528_1107823050. Answering. &lt;---- A ping is received from a mate identified as  1107823050 , let's pong it. Ping send seq 324239260_1742614911Pong for seq 324239260_1742614911 (1)Pong for seq 324239260_1742614911 (2)Pong for seq 324239260_1742614911 (3)Ping received with seq 1435780593_546591567. Answering. Ping received with seq 2034268578_1681483056. Answering. This completes the First micro-ROS Application on Zephyr tutorial. Do you want to go back and try a different RTOS, i. e. NuttX or FreeRTOS? "
        }, {
        "id": 132,
        "url": "https://micro-ros.github.io//docs/tutorials/core/overview/",
        "title": "Overview",
        "body": " - This chapter provides the user with a number of tutorials to learn micro-ROS and relevant tools for the different RTOSes supported by micro-ROS. In the Advanced Tutorials section, you’ll find more advanced tutorials to strenghten your micro-ROS knowledge. If you are new to micro-ROS, we strongly suggest that you take the tutorials in the following order:    First micro-ROS application on Linux   This tutorial teaches you how to install the micro-ROS framework and tools. Then it will guide you to developed your own first micro-ROS application under Linux. (If you already know ROS 2, you will see that the tools are well integrated with standard ROS 2. )     First micro-ROS application on an RTOS   In this tutorial, you will learn how to build the application from the previous tutorial for an Real-Time Operating System (RTOS). You will see how to flash a microcontroller board with the application and how to communicate with it from a microprocessor running ROS 2 on Linux. (The tutorial covers all three RTOS supported by micro-ROS, namely NuttX, FreeRTOS, and Zephyr. The choice is up to you!)     Programming with rcl and rclc   You’ll learn the concepts of the micro-ROS C API in this tutorial in depth. If you are already familiar with the ROS 2 C++ API or even the underlying ROS Client Support Library (rcl), you’ll learn this very quickly.     Zephyr Emulator   In this tutorial, you’ll learn the use of micro-ROS with Zephyr emulator by testing a Ping Pong application.     Teensy with Arduino   In this tutorial you will learn how to connect Teensy with micro-ROS and ROS2. You will also learn how to install micro-ROS agent in linux systems to communicate with Teensy based arduino board using Arduino IDE. This tutorial will also cover a simple publisher topic published from teensy and subscribed using ROS2 interface.  "
        }, {
        "id": 133,
        "url": "https://micro-ros.github.io//docs/tutorials/core/programming_rcl_rclc/",
        "title": "Programming with rcl and rclc",
        "body": " - In this tutorial, you’ll learn the basics of the micro-ROS C API. The major concepts (publishers, subscriptions, services,timers, …) are identical with ROS 2. They even rely on the same implementation, as the micro-ROS C API is based on the ROS 2 client support library (rcl), enriched with a set of convenience functions by the package rclc. That is, rclc does not add a new layer of types on top of rcl (like rclcpp and rclpy do) but only provides functions that ease the programming with the rcl types. New types are introduced only for concepts that are missing in rcl, such as the concept of an executor.  Creating a node Publishers and subscriptions Services Timers Lifecycle Rclc ExecutorCreating a Node: To simplify the creation of a node with rcl, rclc provides two functions rclc_support_init(. . ) and rclc_node_init_default(. . ) in rclc/init. h and rclc/node. h, respectively. The first lines of the main function of a micro-ROS programm are: rcl_allocator_t allocator = rcl_get_default_allocator();rclc_support_t support;rcl_ret_t rc;rc = rclc_support_init(&amp;support, argc, argv, &amp;allocator);if (rc != RCL_RET_OK) { . . .  // Some error reporting.  return -1;}rcl_node_t my_node;rc = rclc_node_init_default(&amp;my_node,  my_node_name ,  my_namespace , &amp;support);if (rc != RCL_RET_OK) { . . .  // Some error reporting.  return -1;}Publishers and Subscriptions: Publishers and subscribers are most easily created with the rclc package. Creating a publisher by rclc_publisher_init_default(. . ) from rclc/publisher. h: rcl_publisher_t my_pub;std_msgs__msg__String my_msg;const char * my_topic =  topic_0 ;const rosidl_message_type_support_t * my_type_support = ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);rc = rclc_publisher_init_default(&amp;my_pub, &amp;my_node, &amp;my_type_support, &amp;my_topic_name);if (RCL_RET_OK != rc) { printf( Error in rclc_publisher_init_default. /n ); return -1;}Initializing a message: std_msgs__msg__String__init(&amp;pub_msg);const unsigned int PUB_MSG_SIZE = 20;char pub_string[PUB_MSG_SIZE];snprintf(pub_string, 13,  %s ,  Hello World! );rosidl_generator_c__String__assignn(&amp;pub_msg, pub_string, PUB_MSG_SIZE);Creating a subscription by rclc_subscription_init_default(. . ) from rclc/subscription. h: rcl_subscription_t my_sub = rcl_get_zero_initialized_subscription();rc = rclc_subscription_init_default(&amp;my_sub, &amp;my_node, &amp;my_type_support, &amp;my_topic_name);if (rc != RCL_RET_OK) { printf( Failed to create subscriber. /n ); return -1;}Services: ROS 2 services is another communication mechanism between nodes. Services implement a client-server paradigm based on ROS 2 messages and types. Further information about ROS 2 services can be found here Ready to use code related to this tutorial can be found in micro-ROS-demos/rclc/addtwoints_server and micro-ROS-demos/rclc/addtwoints_client folders. Note: Services are not supported in rclc package yet. Therefore, for the moment, the configuration is described using the RCL layer. However, we are working to port them to the RCLC soon. Starting from a code where RCL is initialized and a micro-ROS node is created, these steps are required in order to generate a service server: // Creating service server and optionsrcl_service_options_t service_options = rcl_service_get_default_options();rcl_service_t server = rcl_get_zero_initialized_service();// Initializing service serverrcl_service_init(&amp;server, &amp;node, ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts),  addtwoints , &amp;service_options);// Init service server wait setrcl_wait_set_t wait_set = rcl_get_zero_initialized_wait_set();rcl_wait_set_init(&amp;wait_set, 0, 0, 0, 0, 1, 0, &amp;context, rcl_get_default_allocator());On the other hand the service client initialization looks like that: // Creating service client and optionsrcl_client_options_t client_options = rcl_client_get_default_options();rcl_client_t client = rcl_get_zero_initialized_client();// Initializing service clientrcl_client_init(&amp;client, &amp;node, ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts),  addtwoints , &amp;client_options)// Init service client wait setrcl_wait_set_t wait_set = rcl_get_zero_initialized_wait_set();rcl_wait_set_init(&amp;wait_set, 0, 0, 0, 1, 0, 0, &amp;context, rcl_get_default_allocator());First of all, by looking at AddTwoInts. srv type definition it is possible to determine request and reply elements of the service. Service client will make a request with two integers and service server should send its sum as a response. int64 aint64 b---int64 sumOnce service client and server are configured, service client can perform a request and wait for reply: // Creating a service requestint64_t seq;example_interfaces__srv__AddTwoInts_Request req;req. a = 24;req. b = 42;// Sending the requestrcl_send_request(&amp;client, &amp;req, &amp;seq)printf( Send service request %d + %d. Seq %ld/n ,(int)req. a, (int)req. b, (int)seq);// Wait for responsebool done = false;do {  rcl_wait_set_clear(&amp;wait_set);  size_t index;  rcl_wait_set_add_client(&amp;wait_set, &amp;client, &amp;index);  rcl_wait(&amp;wait_set, RCL_MS_TO_NS(1));  // If wait set client element is not null, response is ready  if (wait_set. clients[index]) {    rmw_request_id_t req_id;    // Create a service response struct    example_interfaces__srv__AddTwoInts_Response res;    // Take the response    rcl_ret_t rc = rcl_take_response(&amp;client, &amp;req_id, &amp;res);    if (RCL_RET_OK == rc) {      printf( Received service response %d + %d = %d. Seq %d/n ,(int)req. a, (int)req. b, (int)res. sum,req_id. sequence_number);      done = true;    }  }} while ( !done );On service server side, the ROS 2 node should be waiting for service requests and generate service replies: while(1){  rcl_wait_set_clear(&amp;wait_set);  size_t index;  rcl_wait_set_add_service(&amp;wait_set, &amp;service, &amp;index);  rcl_wait(&amp;wait_set, RCL_MS_TO_NS(1));  // If wait set service element is not null, request is ready  if (wait_set. services[index]) {    rmw_request_id_t req_id;    // Create a service request struct    example_interfaces__srv__AddTwoInts_Request req;    // Take the request    rcl_take_request(&amp;service, &amp;req_id, &amp;req);    printf( Service request value: %d + %d. Seq %d/n , (int)req. a, (int)req. b, (int)req_id. sequence_number);    // Create a service response, fill the result and send it    example_interfaces__srv__AddTwoInts_Response res;    res. sum = req. a + req. b;    rcl_send_response(&amp;service, &amp;req_id,&amp;res);  }}Timers: A timer can be created with the rclc-package with the functionrclc_timer_init_default(. . ) in rclc/timer. h: // create a timer, which will call the publisher with period=`timer_timeout` ms in the 'my_timer_callback'rcl_timer_t my_timer;const unsigned int timer_timeout = 1000;rc = rclc_timer_init_default(&amp;my_timer, &amp;support, RCL_MS_TO_NS(timer_timeout), my_timer_callback);if (rc != RCL_RET_OK) { printf( Error in rcl_timer_init_default. /n ); return -1;} else { printf( Created timer with timeout %d ms. /n , timer_timeout);}Lifecycle: The rclc lifecycle package provides convenience functions in C to bundle an rcl node with the ROS 2 Node Lifecycle state machine, similar to the rclcpp Lifecycle Node for C++. This tutorial show-cases how to set up an rclc lifecycle node, transition through its lifecycle states, and assign callbacks to lifecycle transitions. Initialization: Creation of a lifecycle node as a bundle of an rcl node and the rcl lifecycle state machine. #include  rclc_lifecycle/rclc_lifecycle. h rcl_allocator_t allocator = rcl_get_default_allocator();rclc_support_t support;rcl_ret_t rc;// create rcl noderc = rclc_support_init(&amp;support, argc, argv, &amp;allocator);rcl_node_t my_node;rc = rclc_node_init_default(&amp;my_node,  my_lifecycle_node ,  rclc , &amp;support);// rcl state machinercl_lifecycle_state_machine_t state_machine = rcl_lifecycle_get_zero_initialized_state_machine();. . . // create the lifecycle noderclc_lifecycle_node_t my_lifecycle_node;rcl_ret_t rc = rclc_make_node_a_lifecycle_node( &amp;my_lifecycle_node, &amp;my_node, &amp;state_machine, &amp;allocator);Optionally create hooks for lifecycle state changes. // declare callbackrcl_ret_t my_on_configure() { printf(  &gt;&gt;&gt; my_lifecycle_node: on_configure() callback called. /n ); return RCL_RET_OK;}. . . // register callbacksrclc_lifecycle_register_on_configure(&amp;my_lifecycle_node, &amp;my_on_configure);Running: Change states of the lifecycle node, e. g. bool publish_transition = true;rc += rclc_lifecycle_change_state( &amp;my_lifecycle_node, lifecycle_msgs__msg__Transition__TRANSITION_CONFIGURE, publish_transition);rc += rclc_lifecycle_change_state( &amp;my_lifecycle_node, lifecycle_msgs__msg__Transition__TRANSITION_ACTIVATE, publish_transition);. . . Except for error processing transitions, transitions are usually triggered from outside, e. g. , by ROS 2 services. Cleaning Up: To clean everything up, simply do rc += rcl_lifecycle_node_fini(&amp;my_lifecycle_node, &amp;allocator);Example and Limitations: An example of the rclc Lifecycle Node is given in the file lifecycle_node. c in the rclc_examples package. The state machine publishes state changes, however, lifecycle services are not yet exposed via ROS 2 services (ros2/rclc#40). rclc Executor: The rclc Executor provides a C API to manage the execution of subscription and timer callbacks, similar to the rclcpp Executor for C++. The rclc Executor is optimized for resource-constrained devices and provides additional features that allow the manual implementation of deterministic schedules with bounded end-to-end latencies. In this tutorial we provide two examples:  Example 1: Hello-World example consisting of one executor and one publisher, timer and subscription.  Example 2: Triggered execution example, demonstrating the capability of synchronizing the execution of callbacks based on the availability of new messagesFurther examples for using the rclc Executor in mobile robotics scenarios and real-time embedded applications can be found in the rclc repository. Example 1: ‘Hello World’: To start with, we provide a very simple example for an rclc Executor with one timer and one subscription, so to say, a ‘Hello world’ example. It consists of a publisher, sending a ‘hello world’ message to a subscriber, which then prints out the received message on the console. First, you include some header files, in particular the rclc/rclc. h and rclc/executor. h. #include &lt;stdio. h&gt;#include &lt;std_msgs/msg/string. h&gt;#include &lt;rclc/rclc. h&gt;#include &lt;rclc/executor. h&gt;We define a publisher and two strings, which will be used later. rcl_publisher_t my_pub;std_msgs__msg__String pub_msg;std_msgs__msg__String sub_msg;The subscription callback casts the message parameter msgin to an equivalent type of std_msgs::msg::String in C and prints out the received message. void my_subscriber_callback(const void * msgin){ const std_msgs__msg__String * msg = (const std_msgs__msg__String *)msgin; if (msg == NULL) {  printf( Callback: msg NULL/n ); } else {  printf( Callback: I heard: %s/n , msg-&gt;data. data); }}The timer callback publishes the message pub_msg with the publisher my_pub, which is initialized later in main(). void my_timer_callback(rcl_timer_t * timer, int64_t last_call_time){ rcl_ret_t rc; UNUSED(last_call_time); if (timer != NULL) {  rc = rcl_publish(&amp;my_pub, &amp;pub_msg, NULL);  if (rc == RCL_RET_OK) {   printf( Published message %s/n , pub_msg. data. data);  } else {   printf( Error in timer_callback: Message %s could not be published/n , pub_msg. data. data);  } } else {  printf( Error in timer_callback: timer parameter is NULL/n ); }}After defining the callback functions, we present now the main() function. First, some initialization is necessary to create later rcl objects. That is an allocator for dynamic memory allocation, and a support object, which contains some rcl-objects simplifying the initialization of an rcl-node, an rcl-subscription, an rcl-timer and an rclc-executor. int main(int argc, const char * argv[]){ rcl_allocator_t allocator = rcl_get_default_allocator(); rclc_support_t support; rcl_ret_t rc; // create init_options rc = rclc_support_init(&amp;support, argc, argv, &amp;allocator); if (rc != RCL_RET_OK) {  printf( Error rclc_support_init. /n );  return -1; }Next, you define a ROS 2 node my_node and initialize it with rclc_executor_init_default():  // create rcl_node rcl_node_t my_node; rc = rclc_node_init_default(&amp;my_node,  node_0 ,  executor_examples , &amp;support); if (rc != RCL_RET_OK) {  printf( Error in rclc_node_init_default/n );  return -1; }You can create a publisher to publish topic ‘topic_0’ with type std_msg::msg::String with the following code: const char * topic_name =  topic_0 ;const rosidl_message_type_support_t * my_type_support = ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);rc = rclc_publisher_init_default(&amp;my_pub, &amp;my_node, my_type_support, topic_name);if (RCL_RET_OK != rc) { printf( Error in rclc_publisher_init_default %s. /n , topic_name); return -1;}Note, that variable my_pub was defined globally, so it can be used by the timer callback. You can create a timer my_timer with a period of one second, which executes the callback my_timer_callback like this:  rcl_timer_t my_timer; const unsigned int timer_timeout = 1000; // in ms rc = rclc_timer_init_default(&amp;my_timer, &amp;support, RCL_MS_TO_NS(timer_timeout), my_timer_callback); if (rc != RCL_RET_OK) {  printf( Error in rcl_timer_init_default. /n );  return -1; } else {  printf( Created timer with timeout %d ms. /n , timer_timeout); }The string Hello World! can be assigned directly to the message of the publisher pub_msg. data. First the publisher message is initialized with std_msgs__msg__String__init. Then you need to allocate memory for pub_msg. data. data, set the maximum capacity pub_msg. data. capacity and set the length of the message pub_msg. data. size accordingly. You can assign the content of the message with snprintf of pub_msg. data. data.  // assign message to publisher std_msgs__msg__String__init(&amp;pub_msg); const unsigned int PUB_MSG_CAPACITY = 20; pub_msg. data. data = malloc(PUB_MSG_CAPACITY); pub_msg. data. capacity = PUB_MSG_CAPACITY; snprintf(pub_msg. data. data, pub_msg. data. capacity,  Hello World! ); pub_msg. data. size = strlen(pub_msg. data. data);A subscription my_subcan be defined like this:  rcl_subscription_t my_sub = rcl_get_zero_initialized_subscription(); rc = rclc_subscription_init_default(&amp;my_sub, &amp;my_node, my_type_support, topic_name); if (rc != RCL_RET_OK) {  printf( Failed to create subscriber %s. /n , topic_name);  return -1; } else {  printf( Created subscriber %s:/n , topic_name); }The global message for this subscription sub_msg needs to be initialized with:  std_msgs__msg__String__init(&amp;sub_msg);Now, all preliminary steps are done, and you can define and initialized the rclc executor with:  rclc_executor_t executor; executor = rclc_executor_get_zero_initialized_executor();In the next step, executor is initialized with the ROS 2 context, the number of communication objects num_handles and an allocator. The number of communication objects defines the total number of timers and subscriptions, the executor shall manage. In this example, the executor will be setup with one timer and one subscription.  // total number of handles = #subscriptions + #timers unsigned int num_handles = 1 + 1; rclc_executor_init(&amp;executor, &amp;support. context, num_handles, &amp;allocator);Now, you can add a subscription with the function rclc_c_executor_add_subscription with the previously defined subscription my_sub, its message sub_msgand its callback my_subscriber_callback: rc = rclc_executor_add_subscription(&amp;executor, &amp;my_sub, &amp;sub_msg, &amp;my_subscriber_callback, ON_NEW_DATA);if (rc != RCL_RET_OK) { printf( Error in rclc_executor_add_subscription. /n );}The option ON_NEW_DATA selects the execution semantics of the spin-method. In this example, the callback of the subscription my_subis only called if new data is available. Note: Another execution semantics is ALWAYS, which means, that the subscription callback is always executed when the spin-method of the executor is called. This option might be useful in cases in which the callback shall be executed at a fixed rate irrespective of new data is available or not. If you choose this option, then the callback will be executed with message argument NULL if no new data is available. Therefore you need to make sure, that your callback also accepts NULL as message argument. Likewise, you can add the timer my_timer with the function rclc_c_executor_add_timer: rclc_executor_add_timer(&amp;executor, &amp;my_timer);if (rc != RCL_RET_OK) { printf( Error in rclc_executor_add_timer. /n );}A key feature of the rclc Executor is that the order of these rclc-executor-add-*-functions matters. The order in which these functions are called defines the static processing order of the callbacks when the spin-function of the executor is running. In this example, the timer was added to the executor before the subscription. Therefore, if the timer is ready and also a new message for the subscription is available, then the timer is executed first and after it the subscription. Such a behavior cannot be defined currently with the rclcpp Executor and is useful to implement a deterministic execution semantics. Finally, you can run the executor with rclc_executor_spin():  rclc_executor_spin(&amp;executor);This function runs forever without coming back. In this example, however, we want to publish the message only ten times. Therefore we are using the spin-method rclc_executor_spin_some, which spins only once and returns. The wait timeout for checking for new messages at the DDS-queue or waiting timers to get ready is configured to be one second. for (unsigned int i = 0; i &lt; 10; i++) { // timeout specified in nanoseconds (here 1s) rclc_executor_spin_some(&amp;executor, 1000 * (1000 * 1000));}At the end, you need to free dynamically allocated memory:  // clean up rc = rclc_executor_fini(&amp;executor); rc += rcl_publisher_fini(&amp;my_pub, &amp;my_node); rc += rcl_timer_fini(&amp;my_timer); rc += rcl_subscription_fini(&amp;my_sub, &amp;my_node); rc += rcl_node_fini(&amp;my_node); rc += rclc_support_fini(&amp;support); std_msgs__msg__String__fini(&amp;pub_msg); std_msgs__msg__String__fini(&amp;sub_msg); if (rc != RCL_RET_OK) {  printf( Error while cleaning up!/n );  return -1; }return 0;} // mainThis completes the example. The source code can be found in the package rclc-examples rclc-examples/example_executor_convenience. c. Example 2: Triggered execution: In robotic applications often multiple sensors are used to improve localization precision. These sensors can have different frequencies, for example, a high frequency IMU sensor and a low frequency laser scanner. One way is to trigger execution upon arrival of a laser scan and only then evaluate the most recent data from the aggregated IMU data. This example demonstrates the additional feature of the rclc executor to trigger the execution of callbacks based on the availability of input data. We setup one executor with two publishers, one with 100ms and one with 1000ms period. Then we setup one executor for two subscriptions. Their callbacks shall both be executed if the message of the publisher with the lower frequency arrives. The output of this code example will look like this: Created timer 'my_string_timer' with timeout 100 ms. Created 'my_int_timer' with timeout 1000 ms. Created subscriber topic_0:Created subscriber topic_1:Executor_pub: number of DDS handles: 2Executor_sub: number of DDS handles: 2Published: Hello World! 0Published: Hello World! 1Published: Hello World! 2Published: Hello World! 3Published: Hello World! 4Published: Hello World! 5Published: Hello World! 6Published: Hello World! 7Published: Hello World! 8Published: Hello World! 9Published: 0Callback 1: Hello World! 9 &lt;---Callback 2: 0        &lt;---Published: Hello World! 10Published: Hello World! 11Published: Hello World! 12Published: Hello World! 13Published: Hello World! 14Published: Hello World! 15Published: Hello World! 16Published: Hello World! 17Published: Hello World! 18Published: Hello World! 19Published: 1Callback 1: Hello World! 19 &lt;---Callback 2: 1        &lt;---This output shows, that the callbacks are executed, only if both message have received new data. In that case, the latest data of high-frequency topic is used. You learn in this tutorial  how to use pre-defined trigger conditions how to write custom-defined trigger conditions how to run multiple executors how to setup quality-of-service parameters for a subscriptionWe start with the necessary includes for string and int messages, &lt;std_msgs/msg/string. h&gt; and std_msgs/msg/int32. h respectivly. Then the necessary includes follow for the rclc convenience functions rclc. h and the the rclc executor executor. h: #include &lt;stdio. h&gt;#include &lt;unistd. h&gt;#include &lt;std_msgs/msg/string. h&gt;#include &lt;std_msgs/msg/int32. h&gt;#include &lt;rclc/executor. h&gt;#include &lt;rclc/rclc. h&gt;Then, global variables for the publishers and subscriptions as well as their messages are defined, which are initialized in the main() function and used in the corresponding callbacks: rcl_publisher_t my_pub;rcl_publisher_t my_int_pub;std_msgs__msg__String sub_msg;std_msgs__msg__Int32 pub_int_msg;int pub_int_value;std_msgs__msg__Int32 sub_int_msg;int pub_string_value;For the custom-defined trigger conditions, the type pub_trigger_object_t and the type sub_trigger_object_t are defined. typedef struct{ rcl_timer_t * timer1; rcl_timer_t * timer2;} pub_trigger_object_t;typedef struct{ rcl_subscription_t * sub1; rcl_subscription_t * sub2;} sub_trigger_object_t;The executor for the publishers shall publish when any of corresponding timers for the publishers is ready. That is the or-logic. You could also use the predefined rclc_executor_trigger_any trigger condition, but this example shows how you can write your own trigger conditions. In principle, the condition gets a list of handles, the length of this list, and the pre-defined condition type. In this case, we expect pub_trigger_object_t. First, the parameter obj is cased to this type (comm_obj). Then, each element of the handle list is checked for new data (or a timer is ready) by evaluating the field handles[i]. data_available and its handle pointer is compared to the pointer of the communicatoin object. If at least one timer is ready, then the trigger condition returns true. bool pub_trigger(rclc_executor_handle_t * handles, unsigned int size, void * obj){ if (handles == NULL) {  printf( Error in pub_trigger: 'handles' is a NULL pointer/n );  return false; } if (obj == NULL) {  printf( Error in pub_trigger: 'obj' is a NULL pointer/n );  return false; } pub_trigger_object_t * comm_obj = (pub_trigger_object_t *) obj; bool timer1 = false; bool timer2 = false; //printf( pub_trigger ready set:  ); for (unsigned int i = 0; i &lt; size; i++) {  if (handles[i]. data_available) {   void * handle_ptr = rclc_executor_handle_get_ptr(&amp;handles[i]);   if (handle_ptr == comm_obj-&gt;timer1) {    timer1 = true;   }   if (handle_ptr == comm_obj-&gt;timer2) {    timer2 = true;   }  } } return (timer1 || timer2);}The trigger condition for the subscription sub_triggershall implement an AND-logic. That is, only if both subscriptions have received a new message, then the executor shall start processing the callbacks. The implementation is analogous to pub_trigger. The only difference is, that this trigger returns true, if both subscriptions have been found in the handle list. This is implemented in the condition sub1 &amp;&amp; sub2 of the last if-statement. bool sub_trigger(rclc_executor_handle_t * handles, unsigned int size, void * obj){ if (handles == NULL) {  printf( Error in sub_trigger: 'handles' is a NULL pointer/n );  return false; } if (obj == NULL) {  printf( Error in sub_trigger: 'obj' is a NULL pointer/n );  return false; } sub_trigger_object_t * comm_obj = (sub_trigger_object_t *) obj; bool sub1 = false; bool sub2 = false; //printf( sub_trigger ready set:  ); for (unsigned int i = 0; i &lt; size; i++) {  if (handles[i]. data_available == true) {   void * handle_ptr = rclc_executor_handle_get_ptr(&amp;handles[i]);   if (handle_ptr == comm_obj-&gt;sub1) {    sub1 = true;   }   if (handle_ptr == comm_obj-&gt;sub2) {    sub2 = true;   }  } } return (sub1 &amp;&amp; sub2);}Like in the Hello-World example, the subscription callbacks just prints out the received message. The my_string_subscriber callback prints out the string of the message msg-&gt;data. data: void my_string_subscriber_callback(const void * msgin){ const std_msgs__msg__String * msg = (const std_msgs__msg__String *)msgin; if (msg == NULL) {  printf( my_string_subscriber_callback: msgin is NULL/n ); } else {  printf( Callback 1: %s/n , msg-&gt;data. data); }}The integer callback prints out the received integer msg-&gt;data: void my_int_subscriber_callback(const void * msgin){ const std_msgs__msg__Int32 * msg = (const std_msgs__msg__Int32 *)msgin; if (msg == NULL) {  printf( my_int_subscriber_callback: msgin is NULL/n ); } else {  printf( Callback 2: %d/n , msg-&gt;data); }}To publish messages with different frequencies, we setup two timers. One timer to publish a string message, the my_timer_string_callback and one timer to publish the integer, the my_timer_int_callback. In the my_timer_string_callback, the message pub_msg is created and filled with the string Hello World plus an integer, which is incremented by one, each time the timer callback is called. The the message is published with rcl_publish() The macro UNUSED is a workaround for the linter warning, that the second parameter last_call_time is not used. #define UNUSED(x) (void)x;void my_timer_string_callback(rcl_timer_t * timer, int64_t last_call_time){ rcl_ret_t rc; UNUSED(last_call_time); if (timer != NULL) {  //printf( Timer: time since last call %d/n , (int) last_call_time);  std_msgs__msg__String pub_msg;  std_msgs__msg__String__init(&amp;pub_msg);  const unsigned int PUB_MSG_CAPACITY = 20;  pub_msg. data. data = malloc(PUB_MSG_CAPACITY);  pub_msg. data. capacity = PUB_MSG_CAPACITY;  snprintf(pub_msg. data. data, pub_msg. data. capacity,  Hello World!%d , pub_string_value++);  pub_msg. data. size = strlen(pub_msg. data. data);  rc = rcl_publish(&amp;my_pub, &amp;pub_msg, NULL);  if (rc == RCL_RET_OK) {   printf( Published: %s/n , pub_msg. data. data);  } else {   printf( Error in my_timer_string_callback: publishing message %s/n , pub_msg. data. data);  }  std_msgs__msg__String__fini(&amp;pub_msg); } else {  printf( Error in my_timer_string_callback: timer parameter is NULL/n ); }}Likewise, the my_timer_int_callback increments the integer value pub_int_value in every call and assigns it to the message field pub_int_msg. data. Then the message is published with rcl_publish() void my_timer_int_callback(rcl_timer_t * timer, int64_t last_call_time){ rcl_ret_t rc; UNUSED(last_call_time); if (timer != NULL) {  //printf( Timer: time since last call %d/n , (int) last_call_time);  pub_int_msg. data = pub_int_value++;  rc = rcl_publish(&amp;my_int_pub, &amp;pub_int_msg, NULL);  if (rc == RCL_RET_OK) {   printf( Published: %d/n , pub_int_msg. data);  } else {   printf( Error in my_timer_int_callback: publishing message %d/n , pub_int_msg. data);  } } else {  printf( Error in my_timer_int_callback: timer parameter is NULL/n ); }}Now were are all set for the main() function: int main(int argc, const char * argv[]){ rcl_allocator_t allocator = rcl_get_default_allocator(); rclc_support_t support; rcl_ret_t rc; // create init_options rc = rclc_support_init(&amp;support, argc, argv, &amp;allocator); if (rc != RCL_RET_OK) {  printf( Error rclc_support_init. /n );  return -1; }First rcl is initialized with the rclc_support_init using the default allocator. The rclc-support objects are saved in support. Next, a node my_node with the name node_0 and namespace executor_examples is created with: // create rcl_node rcl_node_t my_node; rc = rclc_node_init_default(&amp;my_node,  node_0 ,  executor_examples , &amp;support); if (rc != RCL_RET_OK) {  printf( Error in rclc_node_init_default/n );  return -1; }A publisher my_string_pub, which publishes a string message and its corresponding timer my_string_timer with a 100ms period is created like this: // create a publisher 1// - topic name: 'topic_0'// - message type: std_msg::msg::Stringconst char * topic_name =  topic_0 ;const rosidl_message_type_support_t * my_type_support = ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);rc = rclc_publisher_init_default(&amp;my_string_pub, &amp;my_node, my_type_support, topic_name);if (RCL_RET_OK != rc) { printf( Error in rclc_publisher_init_default %s. /n , topic_name); return -1;}// create timer 1// - publishes 'my_string_pub' every 'timer_timeout' msrcl_timer_t my_string_timer;const unsigned int timer_timeout = 100;rc = rclc_timer_init_default(&amp;my_string_timer, &amp;support, RCL_MS_TO_NS(timer_timeout), my_timer_string_callback);if (rc != RCL_RET_OK) { printf( Error in rclc_timer_init_default. /n ); return -1;} else { printf( Created timer 'my_string_timer' with timeout %d ms. /n , timer_timeout);}Note that the previously defined my_timer_string_callback is connected to this timer. Likewise, a second publisher my_int_pub, which publishes an int message and its corresponding timer my_int_timer` with 1000ms period, is created like this: // create publisher 2 // - topic name: 'topic_1' // - message type: std_msg::msg::Int const char * topic_name_1 =  topic_1 ; const rosidl_message_type_support_t * my_int_type_support =  ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Int32); rc = rclc_publisher_init_default(&amp;my_int_pub, &amp;my_node, my_int_type_support, topic_name_1); if (RCL_RET_OK != rc) {  printf( Error in rclc_publisher_init_default %s. /n , topic_name_1);  return -1; } // create timer 2 // - publishes 'my_int_pub' every 'timer_int_timeout' ms rcl_timer_t my_int_timer; const unsigned int timer_int_timeout = 10 * timer_timeout; rc = rclc_timer_init_default(&amp;my_int_timer, &amp;support, RCL_MS_TO_NS(timer_int_timeout), my_timer_int_callback); if (rc != RCL_RET_OK) {  printf( Error in rclc_timer_init_default. /n );  return -1; } else {  printf( Created timer with timeout %d ms. /n , timer_int_timeout); }Note that the my_timer_int_callback is connected to the my_int_timer. The data variables used for the publisher messages in the timer callbacks need to be initialized first: std_msgs__msg__Int32__init(&amp;int_pub_msg);int_pub_value = 0;string_pub_value = 0;The first subscription my_string_sub is created with the function rcl_subscription_init because we change the quality-of-service parameter to ‘last-is-best’. That is, a new message will overwrite the older message if it has not been processed by the subscription. Also the message string_sub_msg needs to be initialized. // create subscription 1 rcl_subscription_t my_string_sub = rcl_get_zero_initialized_subscription(); rcl_subscription_options_t my_subscription_options = rcl_subscription_get_default_options(); my_subscription_options. qos. depth = 0; // qos: last is best = register semantics rc = rcl_subscription_init(&amp;my_string_sub, &amp;my_node, my_type_support, topic_name, &amp;my_subscription_options); if (rc != RCL_RET_OK) {  printf( Failed to create subscriber %s. /n , topic_name);  return -1; } else {  printf( Created subscriber %s:/n , topic_name); } // initialize subscription message std_msgs__msg__String__init(&amp;string_sub_msg);The second subscription my_int_sub is created with the rclc convenience function rclc_subscription_default and the message int_sub_msg is properly initialized. // create subscription 2 rcl_subscription_t my_int_sub = rcl_get_zero_initialized_subscription(); rc = rclc_subscription_init_default(&amp;my_int_sub, &amp;my_node, my_int_type_support, topic_name_1); if (rc != RCL_RET_OK) {  printf( Failed to create subscriber %s. /n , topic_name_1);  return -1; } else {  printf( Created subscriber %s:/n , topic_name_1); } // initialize subscription message std_msgs__msg__Int32__init(&amp;int_sub_msg);In this example, we are using two executors, one to schedule the publishers, and one to schedule the subscriptions: rclc_executor_t executor_pub;rclc_executor_t executor_sub;The executor executor_pub is first created with rclc_executor_get_zero_initialized_executor() and has two handles (aka 2 timers). // Executor for publishing messages unsigned int num_handles_pub = 2; printf( Executor_pub: number of DDS handles: %u/n , num_handles_pub); executor_pub = rclc_executor_get_zero_initialized_executor(); rclc_executor_init(&amp;executor_pub, &amp;support. context, num_handles_pub, &amp;allocator); rc = rclc_executor_add_timer(&amp;executor_pub, &amp;my_string_timer); if (rc != RCL_RET_OK) {  printf( Error in rclc_executor_add_timer 'my_string_timer'. /n ); } rc = rclc_executor_add_timer(&amp;executor_pub, &amp;my_int_timer); if (rc != RCL_RET_OK) {  printf( Error in rclc_executor_add_timer 'my_int_timer'. /n ); }Both timers are added to the exececutor with the function rclc_executor_add_timer: rc = rclc_executor_add_timer(&amp;executor_pub, &amp;my_string_timer);if (rc != RCL_RET_OK) { printf( Error in rclc_executor_add_timer 'my_string_timer'. /n );}rc = rclc_executor_add_timer(&amp;executor_pub, &amp;my_int_timer);if (rc != RCL_RET_OK) { printf( Error in rclc_executor_add_timer 'my_int_timer'. /n );}Also the second publisher has two handles, the two subscriptions: unsigned int num_handles_sub = 2;printf( Executor_sub: number of DDS handles: %u/n , num_handles_sub);executor_sub = rclc_executor_get_zero_initialized_executor();rclc_executor_init(&amp;executor_sub, &amp;support. context, num_handles_sub, &amp;allocator);Which are added with the function rclc_executor_add_subscription: // add subscription to executorrc = rclc_executor_add_subscription( &amp;executor_sub, &amp;my_string_sub, &amp;string_sub_msg, &amp;my_string_subscriber_callback, ON_NEW_DATA);if (rc != RCL_RET_OK) { printf( Error in rclc_executor_add_subscription 'my_string_sub'. /n );}// add int subscription to executorrc = rclc_executor_add_subscription( &amp;executor_sub, &amp;my_int_sub, &amp;int_sub_msg, &amp;my_int_subscriber_callback, ON_NEW_DATA);if (rc != RCL_RET_OK) { printf( Error in rclc_executor_add_subscription 'my_int_sub'. /n );}The trigger condition of the executor, which publishes messages, shall execute when any timer is ready. This can be configured with the function rclc_executor_set_trigger and the parameter rclc_executor_trigger_any. While the executor for the subscriptions shall only execute if both messages have arrived. Therefore the trigger parameter rclc_executor_trigger_any can be used: rc = rclc_executor_set_trigger(&amp;executor_pub, rclc_executor_trigger_any, NULL);rc = rclc_executor_set_trigger(&amp;executor_sub, rclc_executor_trigger_all, NULL);Finally, the executors spin-some functions can be started. The sleep-time between the executors is intended for communication time for DDS. for (unsigned int i = 0; i &lt; 100; i++) { // timeout specified in ns         (here: 1s) rclc_executor_spin_some(&amp;executor_pub, 1000 * (1000 * 1000)); usleep(1000); // 1ms rclc_executor_spin_some(&amp;executor_sub, 1000 * (1000 * 1000));}This example is concluded with the clean-up code: // clean uprc = rclc_executor_fini(&amp;executor_pub);rc += rclc_executor_fini(&amp;executor_sub);rc += rcl_publisher_fini(&amp;my_string_pub, &amp;my_node);rc += rcl_publisher_fini(&amp;my_int_pub, &amp;my_node);rc += rcl_timer_fini(&amp;my_string_timer);rc += rcl_timer_fini(&amp;my_int_timer);rc += rcl_subscription_fini(&amp;my_string_sub, &amp;my_node);rc += rcl_subscription_fini(&amp;my_int_sub, &amp;my_node);rc += rcl_node_fini(&amp;my_node);rc += rclc_support_fini(&amp;support);std_msgs__msg__Int32__fini(&amp;int_pub_msg);std_msgs__msg__String__fini(&amp;string_sub_msg);std_msgs__msg__Int32__fini(&amp;int_sub_msg);if (rc != RCL_RET_OK) { printf( Error while cleaning up!/n ); return -1;}return 0;}In case the default trigger conditions are not sufficient, then the user can define custom logic conditions. The source code of the custom-programmed trigger condition has already been presented. The following code will setup the executor accordingly: pub_trigger_object_t comm_obj_pub; comm_obj_pub. timer1 = &amp;my_string_timer; comm_obj_pub. timer2 = &amp;my_int_timer; sub_trigger_object_t comm_obj_sub; comm_obj_sub. sub1 = &amp;my_string_sub; comm_obj_sub. sub2 = &amp;my_int_sub; rc = rclc_executor_set_trigger(&amp;executor_pub, pub_trigger, &amp;comm_obj_pub); rc = rclc_executor_set_trigger(&amp;executor_sub, sub_trigger, &amp;comm_obj_sub);The custom structs pub_trigger_object_t are used to save the pointer of the handles. The timers my_string_timer and my_int_timer for the publishing executor; and, likewise, the subscriptions my_string_sub and my_int_sub for the subscribing executor. The configuration is done also with the rclc_executor_set_trigger by passing the trigger function and the trigger object, e. g. pub_trigger and comm_obj_pub for the executor_pub, respectivly. The complete source code of this example can be found in the file rclc-examples/example_executor_trigger. c. "
        }, {
        "id": 134,
        "url": "https://micro-ros.github.io//docs/tutorials/core/teensy_with_arduino/",
        "title": "Teensy with Arduino",
        "body": " - Target platform: In this tutorial you will learn how to connect Teensy with micro-ROS and ROS 2. You will also learn how to install micro-ROS agent in Linux systems to communicate with Teensy-based Arduino board using Arduino IDE. This tutorial will also cover a simple publisher topic published from teensy and subscribed using ROS 2 interface. To start with, we will need a host computer with either having a native Ubuntu 20. 04 installed ROS 2 Foxy or using a docker version of the freshly build ROS 2 Foxy from this link. Now let us also look at the connection diagram which will help us understand the full picture better.  Installing ROS 2 and micro-ROS in the host computer:: Note: These first few steps are the same as in the micro-ROS installation page as in this link For this tutorial you have to install ROS 2 Foxy Fitzroy on your Ubuntu 20. 04 LTS computer. You can do this from binaries, via Ubuntu packages, which are detailed here. Note: Otherwise it is possible to use fresh docker build of ROS 2 Foxy installation by running these commands: sudo apt install docker. io sudo docker run -it --net=host -v /dev:/dev --privileged ros:foxyAfter running the docker, follow the command to verify if the ROS2 is running and shows the topic list: Docker builds ROS 2 Foxy version can also be used where it is not possible to install native ROS 2 Foxy from binaries, e. g. , Jetson Nano running Jetpack 4. 5 with Ubuntu 18. 04. Now Once you have a ROS 2 installation in the computer or docker, follow these steps to install the micro-ROS build system: # Source the ROS 2 installationsource /opt/ros/foxy/setup. bash# Create a workspace and download the micro-ROS toolsmkdir microros_wscd microros_wsgit clone -b $ROS_DISTRO https://github. com/micro-ROS/micro_ros_setup. git src/micro_ros_setup# Update dependencies using rosdepsudo apt update &amp;&amp; rosdep updaterosdep install --from-path src --ignore-src -y# Install pipsudo apt-get install python3-pip# Build micro-ROS tools and source themcolcon buildsource install/local_setup. bashOnce the micro-ROS installation is complete, we can then proceed to install the micro-ROS agent in the host computer or the docker version. Since we are going to use Teensy 3. 2 and precompiled micro-ROS client library for our demonstration we will not be going to build the firmware and thus we will skip the firmware build steps from the first micro-ROS Application on an RTOS tutorials. To install the micro-ros Agent follow the steps below: # Download micro-ROS agent packagesros2 run micro_ros_setup create_agent_ws. shWe will now build the agent packages and, when this is done, source the installation: # Build stepros2 run micro_ros_setup build_agent. shsource install/local_setup. bashNow, let’s give a dry run by running the micro-ROS agent by following the command: ros2 run micro_ros_agent micro_ros_agent serial --dev /dev/ttyACM0The result should show something like this: This means the installation of the agent is successful. Now we can proceed to the next step which is the installation of Arduino IDE and Teensyduino and patching the Arduino-based Teensy board for using the pre-compiled libraries as described in the micro_ros_arduino repository. Installation of Arduino IDE, Teensyduino and setting up the patch for using the Teensy with micro-ROS and ROS2 foxy:: Please follow the link for downloading the latest version of Arduino 1. 8. 15 and install by following this link for the Linux version here. After installing Arduino IDE download Teensyduino from this link here and follow the instruction as shown on this page. To summarize the instructions which are as follow: 1. Download the Linux udev rules and copy the file to /etc/udev/rules. d. https://www. pjrc. com/teensy/00-teensy. rules2. type the following command in a terminal $ sudo cp 00-teensy. rules /etc/udev/rules. d/3. Download and extract one of Arduino's Linux packages. Note: Arduino from Linux distro packages is not supported. 4. Download the corresponding Teensyduino installer. 5. Run the installer in a termincal by adding execute permission and then execute it. $ chmod 755 TeensyduinoInstall. linux64$ . /TeensyduinoInstall. linux64Now let’s set up the patch for the teensy Arduino to use the pre-compiled micro-ros-client libraries, Open a terminal window and follow the commands below: For more information follow the GitHub link from micro_ros_arduino # for me it was $ export ARDUINO_PATH=/home/manzur/arduino-1. 8. 13/export ARDUINO_PATH=[Your Arduino + Teensiduino path]cd $ARDUINO_PATH/hardware/teensy/avr/curl https://raw. githubusercontent. com/micro-ROS/micro_ros_arduino/foxy/extras/patching_boards/platform_teensy. txt &gt; platform. txtOnce the above instruction is complete, we will now be able to use the Teensy 3. 2 and program it with the pre-compiled micro-ros-client libraries using Arduino IDE. Program the Teensy: Now that we have patched the teensy Arduino IDE, we will be able to use the pre-compiled library by following these instructions:  Go to link to release section and download the last release of micro-ROS library for Arduino. Place the file inside /home/$USERNAME/Arduino/libraries/ as shown below. Once this process is complete, now let us look at the example folder below: For this tutorial and test, we will be using mico-ros-publisher example as shown above since this program will only publish integer data which will increase in every cycle. Once we selected the example program, we will then upload the code in the Teensy 3. 2 connected to our host computer which should show the result as follow.  Running micro-ROS agent in ROS 2 Foxy: Now, let’s disconnect the Teensy for now from the host computer. We will then open a terminal or in the docker run the agent program once again as shown at the end of step 2. Make sure to source the ROS path as below: source /opt/ros/foxy/setup. bashand then run the agent program: ros2 run micro_ros_agent micro_ros_agent serial --dev /dev/ttyACM0Once the program is running it will show this message: We will then reconnect the Teensy with the host computer and then we will see that the connection is complete and it shows like this: This means the connection is complete with teensy containing micro-ros-client and micro-ros-agent in the host computer. Now for the big moment and test the ROS topic published from the teensy. This time we will open another terminal or docker window and type as follow: ros2 topic listWhich should list as shown below: See, we have now /micro_ros_arduino_node_publisher topic publishing in the host computer. If we listen to the topic we will see something like this: The integer msg data increasing in each cycle. "
        }, {
        "id": 135,
        "url": "https://micro-ros.github.io//docs/tutorials/core/zephyr_emulator/",
        "title": "Zephyr Emulator",
        "body": " - Target platform: In this tutorial, you’ll learn the use of micro-ROS with a Zephyr RTOSemulator (also known as Native POSIX)by testing a Ping Pong application. Installing ROS 2 and the micro-ROS build system: First of all, install ROS 2 Foxy FitzRoy on your Ubuntu 20. 04 LTS computer. To do so from binaries, via Debian packages, follow the instructions detailedhere. TIP: Alternatively, you can use a docker container with a fresh ROS 2 Foxy installation. The one that servesthe purpose is the container run by the command: docker run -it --net=host -v /dev:/dev --privileged ros:foxyOnce you have a ROS 2 installation in the computer, follow these steps to install the micro-ROS build system: # Source the ROS 2 installationsource /opt/ros/$ROS_DISTRO/setup. bash# Create a workspace and download the micro-ROS toolsmkdir microros_wscd microros_wsgit clone -b $ROS_DISTRO https://github. com/micro-ROS/micro_ros_setup. git src/micro_ros_setup# Update dependencies using rosdepsudo apt update &amp;&amp; rosdep updaterosdep install --from-path src --ignore-src -y# Install pipsudo apt-get install python3-pip# Build micro-ROS tools and source themcolcon buildsource install/local_setup. bashThese instructions will setup a workspace with a ready-to-use micro-ROS build system. This build system is in charge of downloading the required cross-compilation tools and building the apps for therequired platforms. The build system’s workflow is a four-step procedure:  Create step: This step is in charge of downloading all the required code repositories and cross-compilationtoolchains for the specific hardware platform. Among these repositories, it will also download a collection of readyto use micro-ROS apps.  Configure step: In this step, the user can select which app is going to be cross-compiled by the toolchain. Some other options, such as transport, agent’s IP address/port (for UDP transport) or device ID (for serial connections) will be also selected in this step.  Build step: Here is where the cross-compilation takes place and the platform-specific binaries are generated.  Flash step: The binaries generated in the previous step are flashed onto the hardware platform memory,in order to allow the execution of the micro-ROS app. Further information about micro-ROS build system can be foundhere. Creating a new firmware workspace: Once the build system is installed, let’s create a firmware workspace that targets all the required code and tools: # Create stepros2 run micro_ros_setup create_firmware_ws. sh zephyr hostOnce the command is executed, a folder named firmware must be present in your workspace. This step is in charge, among other things, of downloading a set of micro-ROS apps for the specific platform you areaddressing. In the case of Zephyr, these are located at firmware/zephyr_apps/apps. Each app is represented by a folder containing the following files:  src/main. c: This file contains the logic of the application.  app-colcon. meta: This file contains the micro-ROS app specific colcon configuration. Detailed info on how toconfigure the RMW via this file can be foundhere.  CMakeLists. txt: This is the CMake file containing the script to compile the application.  &lt;transport&gt;. conf: This is a Zephyr specific and transport-dependent app configuration file. &lt;transport&gt; can be serial, serial-usb and host-udp. For the user to create its custom application, a folder &lt;my_app&gt; will need to be registered in this location,containing the four files just described. Configuring the firmware: The configuration step will set up the main micro-ROS options and select the desired application. It can be executed with the following command: # Configure stepros2 run micro_ros_setup configure_firmware. sh [APP] [OPTIONS]The options available for this configuration step are:  --transport or -t: udp, serial or any hardware-specific transport label --dev or -d: agent string descriptor in a serial-like transport --ip or -i: agent IP in a network-like transport --port or -p: agent port in a network-like transportIn this tutorial, we will use a UDP transport that looks for the agent on the port UDP/8888 at localhost, and focus onthe out-of-the-box ping_pong application located at firmware/zephyr_apps/apps/ping_pong. To execute this application with the chosen transport, run the configuration command above by specifying the [APP]and [OPTIONS] parameters as below: # Configure stepros2 run micro_ros_setup configure_firmware. sh ping_pong --transport udp --ip 127. 0. 0. 1 --port 8888You can check the complete content of the ping_pong apphere. This example showcases a micro-ROS node with two publisher-subscriber pairs associated with a ping and a pongtopics, respectively. The node sends a ping package with a unique identifier, using a ping publisher. If the ping subscriber receives a ping from an external node, the pong publisher responds to the incoming pingwith a pong. To test that this logic is correctly functioning, we implement communication with a ROS 2 node that:  Listens to the topics published by the ping subscriber.  Publishes a fake_ping package, that is received by the micro-ROS ping subscriber. As a consequence, the pong publisher on the micro-ROS application will publish a pong, to signal that it receivedthe fake_ping correctly. The diagram below clarifies the communication flow between these entities: The contents of the Zephyr app specific files can be found here:main. c,app-colcon. meta,CMakeLists. txtand host-udp. conf. A thorough review of these files is illustrative of how to create a micro-ROS app in this RTOS. Building the firmware: When the configuring step ends, just build the firmware: # Build stepros2 run micro_ros_setup build_firmware. shNow you have a Zephyr + micro-ROS app ready to run on your own computer. Notice that in this case, the steps of flashing the firmware and running the micro-ROS app go together. Creating the micro-ROS agent: The micro-ROS app is now ready to be connected to a micro-ROS agent to start talking with the rest of the ROS 2world. To do that, let’s first of all create a micro-ROS agent: # Download micro-ROS-Agent packagesros2 run micro_ros_setup create_agent_ws. shNow, let’s build the agent packages and, when this is done, source the installation: # Build stepros2 run micro_ros_setup build_agent. shsource install/local_setup. bashRunning the micro-ROS app: At this point, you have both the client and the agent correctly installed in your host machine. To give micro-ROS access to the ROS 2 dataspace, run the agent: # Run a micro-ROS agentros2 run micro_ros_agent micro_ros_agent udp4 --port 8888Flashing the firmware: Finally, in order to run the micro-ROS node inside of the Zephyr RTOS emulator,open a new command shell and execute the flash step by means of the flashing command: source /opt/ros/$ROS_DISTRO/setup. bashsource install/local_setup. bash# Flash/run stepros2 run micro_ros_setup flash_firmware. shTesting the micro-ROS app: Now, we want to check that everything is working. Open a new command line. We are going to listen to the ping topicwith ROS 2 to check whether the micro-ROS Ping Pong node is correctly publishing the expected pings: source /opt/ros/$ROS_DISTRO/setup. bash# Subscribe to micro-ROS ping topicros2 topic echo /microROS/pingYou should see the topic messages published by the Ping Pong node every 5 seconds: user@user:~$ ros2 topic echo /microROS/pingstamp: sec: 20 nanosec: 867000000frame_id: '1344887256_1085377743'---stamp: sec: 25 nanosec: 942000000frame_id: '730417256_1085377743'---At this point, we know that our app is publishing pings. Let’s check if it also answers to someone else’s pings. If this works, it’ll publish a pong. So, first of all, let’s subscribe with ROS 2 to the pong topic from a new shell(notice that initially we don’t expect to receive any pong, since none has been sent yet): source /opt/ros/$ROS_DISTRO/setup. bash# Subscribe to micro-ROS pong topicros2 topic echo /microROS/pongAnd now, let’s publish a fake_ping with ROS 2 from yet another command line: source /opt/ros/$ROS_DISTRO/setup. bash# Send a fake pingros2 topic pub --once /microROS/ping std_msgs/msg/Header '{frame_id:  fake_ping }'Now, we should see this fake_ping in the ping subscriber console,along with the micro-ROS pings: user@user:~$ ros2 topic echo /microROS/pingstamp: sec: 0 nanosec: 0frame_id: fake_ping---stamp: sec: 305 nanosec: 973000000frame_id: '451230256_1085377743'---stamp: sec: 310 nanosec: 957000000frame_id: '2084670932_1085377743'---Also, we expect that, because of having received the fake_ping, the micro-ROS node will answer with a pong: user@user:~$ ros2 run micro_ros_demos_rcl ping_pongPing send seq 1706097268_1085377743Ping send seq 181171802_1085377743Ping send seq 1385567526_1085377743Ping send seq 926583793_1085377743Ping send seq 1831510138_1085377743Ping received with seq fake_ping. Answering. Ping send seq 1508705084_1085377743Ping send seq 1702133625_1085377743Ping send seq 176104820_1085377743As a consequence, in the pong subscriber console,we should see the micro-ROS app answer to our fake_ping: user@user:~$ ros2 topic echo /microROS/pongstamp: sec: 0 nanosec: 0frame_id: fake_ping---Multiple Ping Pong nodes: One of the advantages of having an emulator is that you don’t need to buy a bunch of hardware in order to test somemulti-node micro-ROS apps. So, with the same micro-ROS agent of the last section, let’s open four different commandlines and run the following on each: cd microros_ws# This is an alternative way of executing the Zephyr emulator. /firmware/build/zephyr/zephyr. exeAs soon as all micro-ROS node are up and connected to the micro-ROS agent you will see them interacting: user@user:~$ . /firmware/build/zephyr/zephyr. exe*** Booting Zephyr OS build zephyr-v2. 2. 0-492-gc73cb85b4ae9 ***Ping send seq 1711620172_1742614911             &lt;---- This micro-ROS node sends a ping with ping ID  1711620172  and node ID  1742614911 Pong for seq 1711620172_1742614911 (1)           &lt;---- The first mate pongs my pingPong for seq 1711620172_1742614911 (2)           &lt;---- The second mate pongs my pingPong for seq 1711620172_1742614911 (3)           &lt;---- The third mate pongs my pingPing received with seq 1845948271_546591567. Answering.   &lt;---- A ping is received from a mate identified as  546591567 , let's pong it. Ping received with seq 232977719_1681483056. Answering.   &lt;---- A ping is received from a mate identified as  1681483056 , let's pong it. Ping received with seq 1134264528_1107823050. Answering.   &lt;---- A ping is received from a mate identified as  1107823050 , let's pong it. Ping send seq 324239260_1742614911Pong for seq 324239260_1742614911 (1)Pong for seq 324239260_1742614911 (2)Pong for seq 324239260_1742614911 (3)Ping received with seq 1435780593_546591567. Answering. Ping received with seq 2034268578_1681483056. Answering. TIP: use the help flag to discover some Zephyr emulation features . /firmware/build/zephyr/zephyr. exe -h "
        }, {
        "id": 136,
        "url": "https://micro-ros.github.io//docs/tutorials/demos/combined_demos/",
        "title": "Combined Demos",
        "body": " - You may combine the different demos for even more functionality. In detail, the following combinations are supported by launch files:       Combination   Description   Launch Files          +    ToF sensor serves as a invisible barrier. If the Kobuki drives into the ToF sensor’s light beam, any further forward motion will be prevented until the Kobuki has been driven out of the beam. This is signalled from the ToF sensor to the Kobuki via a topic /emergency_stop.             +    Roll and pitch of the Crazyflie are used as controls for the Kobuki. Thus, if the remote-controlled Crazyflie is positioned above and aligned with the Kobuki, they will move synchronously. Alternatively, the Crazyflie may be taken into the hand and used as high-end remote control for the Kobuki.             + +    The Kobuki may be controlled using the Crazyflie or synchronous with it, as described above. Any forward movement will be prevented if the Kobuki drives into the ToF sensor’s beam.        "
        }, {
        "id": 137,
        "url": "https://micro-ros.github.io//docs/tutorials/demos/crazyflie_demo/",
        "title": "Crazyflie Demo",
        "body": " - micro-ROS Crazyflie demoThis demos aims to show the benefits of micro-ROS regarding its low resource consumption and its extensible and modular communication system. In particular, it is focused on the micro-ROS’s middleware layer where eProsima Micro XRCE-DDS is the default implementation. This software, base on the DDS-XRCE wire protocol, offers to micro-ROS client-server communication with the following characteristics:  Multi-transport protocol support (UDP, TCP and Serial).  Peer-to-peer communication.  Server discovery.  Best-effort and reliable communication.  Message fragmentation. Each one of the aforementioned characteristics will be used around this demo. Scenario: An MAV (Micro Aerial Vehicle) overflies a given area commanded by a Flight Operator through a GCS (Ground Control Station). Remote Sensors, distributed over the area, takes environmental measures (temperature, pressure and humidity). The Flight Operator shall command the MAV toward the Remote Sensors and once positioned over them, the MAV shall establish a connection with the Remote Sensors in order to gather its data. Finally, the Fligh Operator shall command the MAV toward the home position.  Actors &amp; Topics: In this demo there are three different micro-ROS actors (MAV, GCS and Remote Sensors) which publish/subscribe to/from six topics:  /drone/odometry: MAV’s odometry.  /drone/attitude: MAV’s attitude.  /flight/cmd: flight commands.  /sensor/temperature: Remote Sensors’ temperature.  /sensor/pressure: Remote Sensors’ pressure.  /sensor/humidity: Remote Sensors’ humidity. MAV: A Crazyflie 2. 1 running a micro-ROS-Client application which is in charge of publishing its attitude and odometry, and subscribing to flight commands and Remote Sensor’ data. GCS: A general-purpose computer running a micro-ROS-Agent application which is in charge of publishing flight commands, and subscribing to MAV’s attitude and odometry data. Remote Sensors: A SparkFun Wheather Station connecting to a Raspberry Pi 3A+ which is running a micro-ROS-Agent and a micro-ROS-Client application in charge of publishing the Remote Sensors’ data. The figure below shows the current status of this demo.  Communications: In this demo there are two different kind of communication between its actors. On the one hand, the link between the GCS and the MAV follows a client-server communication pattern. The GCS works as a server using a micro-ROS-Agent application, while the MAV works as a client through a micro-ROS-Client application. On the other hand, the link between the MAV and the Remote Sensors follows a peer-to-peer pattern. Both actors works as clients communicating through a micro-ROS-Agent application running on the Remote Sensors side. In that case, the micro-ROS-Agent application works as a centralized broker where the MAV and the Remote Sensors exchange its topics without ROS 2 output. This application also allows the MAV to discover the Remote Sensors dynamically. Hardware: The following is a list of the hardware needed to reproduce this demo:  1 x Crazyflie 2. 1, 1 x Crazyradio PA, 1 x Flow deck v2, 1 x Crazyflie-compatible remote controller. How to build and flash the firmware?:  Run the builder Docker:  docker-compose run cf_builder    Build the micro-ROS firmware inside the Docker:  ros2 run micro_ros_setup configure_firmware. sh crazyflie_position_publisherros2 run micro_ros_setup build_firmware. sh      Put the Crazyflie in DFU mode following the official instructions.   Flash the micro-ROS firmware:  ros2 run micro_ros_setup flash_firmware. sh   How to use?: To start the application just three steps are needed:    Install and connect the Crazyradio PA (it require setting udev permissions).     Up the Docker Compose:  docker-compose up -d Connect to the Crazyflie. To stop the application just down the Docker Compose: docker-compose downPurpose of the project: The software is not ready for a production use. It has neither been developed nor tested for a specific use case. However, the license conditions of the applicable Open Source licenses allow you to adapt the software to your needs. Before using it in a safety relevant setting, make sure that the software fulfills your requirements and adjust ot according to any applicable safety standards (e. g. ISO 26262). "
        }, {
        "id": 138,
        "url": "https://micro-ros.github.io//docs/tutorials/demos/demobox_demo/",
        "title": "DemoBox Power and Boot Time",
        "body": " - Micro-ROS Power and Distance Sensors DemoThis demo illustrates the micro-ROS capabilities and showcases the integration of micro-ROS with ROS 2 tools. Besides, it enables the comparison of micro-ROS and ROS 2 outcomes. The use-case consists in a ROS2-controlled Raspberry Pi 4 with a TFMini sensor that measures the distance to a target object and a micro-ROS-controlled Olimex STM32-E407 board with the similar TFMini sensor, which measures the distance to the same object. The demo explores another micro-ROS-controlled Olimex STM32-E407 board, which measures the power consumption of both Raspberry Pi 4 and Olimex STM32-E407 boards for distance measurements, using INA219 sensors. The last component, a tablet display, visualizes measurement results using standard ROS 2 tools (rqt). Raspberry Pi 4 is running Linux and a ROS 2 application, while Olimex STM32-E407 boards are running NuttX and micro-ROS applications. Both of them are publishing sensor messages via UDP over Ethernet LAN sending distance and power data to the display. The tablet is running Linux, ROS 2 and a micro-ROS agent to receive these messages. Contens:  Demo Box diagram Topics Hardware Sensor wiring Ethernet connection How to build the micro-ROS demo system on Olimex STM32-E407 How to build the ROS 2 demo system on a tablet How to build the ROS 2 demo system on Raspberry Pi 4 Running the demoDemo Box diagram: Topics: In this demo there are two different micro-ROS nodes and the ROS 2 node which publish the following topics:  /distance_oli: distance measured by a sensor on the Olimex-E407 board, /power_oli: power consumtion of the distance Olimex board, /power_rpi: power consumtion of the Raspberry Pi, /distance_rpi: distance measured by a sensor on the Raspberry Pi. From these topics subscribes a ROS 2 node on the tablet. Hardware: The following is a list of the demo hardware:  1 x Raspberry Pi 4 + Power Supply + SD Card, 2 x Olimex STM32-E407 + Power Supply + Ethernet cable, 2 x TFMini Micro LiDAR Module, 2 x INA219 DC Current Sensor + shunt resistor, 1 x NETGEAR proSafe Gigabit Switch GS105 + Power Supply, 1 x Getac 2 Tablet + Power Supply + Ethernet cable, 1 x PC + ST-LINK/V2 to flash firmware to Olimex boards. Sensor wiring:       TFMini       Olimex STM-E407         red   &lt;—–&gt;   5V       black   &lt;—–&gt;   GND       white   &lt;—–&gt;   Tx3       green   &lt;—–&gt;   Rx3          TFMini       RPI / Pin Number         red   &lt;—–&gt;   5V/2       black   &lt;—–&gt;   GNGND/6       white   &lt;—–&gt;   Tx/8       green   &lt;—–&gt;   Rx/10          INA219       Olimex STM-E407         SCL   &lt;—–&gt;   I2C1_SCL (UEXT pin 5)       SDA   &lt;—–&gt;   I2C1_SDA (UEXT pin 6)          Load   INA219 Address   Shunt Resistor [ohm]         RPI   A0=GND, A1=GND   0. 5       Olimex   A0=GND, A1=Vs   1    Ethernet connection: IP addresses: - Tablet: 192. 168. 10. 2- RPI: 192. 168. 10. 4- Distance Olimex: 192. 168. 10. 17- Power Olimex: 192. 168. 10. 18How to build the micro-ROS demo system on Olimex STM32-E407: The environment for setting up the Demo Box applications will be perform within a docker:  Download the micro-ROS base Foxy image from the Docker Hub, then run a docker containersudo docker pull microros/base:foxysudo docker run -it --net=host --privileged -v /dev/bus/usb:/dev/bus/usb   microros/base:foxy Create a ROS 2 workspace in the uros_ws folder of the docker container and build the packagesource /opt/ros/$ROS_DISTRO/setup. bashgit clone -b $ROS_DISTRO https://github. com/micro-ROS/micro_ros_setup. git src/micro_ros_setupapt update &amp;&amp; rosdep updaterosdep install --from-path src --ignore-src -yapt-get install python3-pipapt-get -y install python3-pipcolcon buildsource install/local_setup. bas Create the Nuttx firmware on Olimex-E407 with the Demo Box sensor applications  ros2 run micro_ros_setup create_firmware_ws. sh nuttx olimex-stm32-e407cd firmware/NuttXgit checkout -t origin/foxycd . . /appsgit checkout -t origin/mastercd . .     Build an flash the firmware:   Set the configuration profile variable to select the demo distance or demo power applicationCFG_PROFILE=demo_distance_romfs Build the applicationros2 run micro_ros_setup configure_firmware. sh $CFG_PROFILEcp firmware/NuttX/configs/olimex-stm32-e407/$CFG_PROFILE/rcS. template firmware/apps/nshlib/rcS. templatecd firmware/apps/nshlib/. . /. . /NuttX/tools/mkromfsimg. sh -nofat . . /. . /NuttX/cd /uros_ws/ros2 run micro_ros_setup build_firmware. sh Connect ST-Link/V2 to Olimex STM32-E407 JTAG interface and flash the firmwareros2 run micro_ros_setup flash_firmware. sh Repeat the procedure Build the application with the Olimex used for monitoring the current consumption but before, the configuration needs to be changed as follow:CFG_PROFILE=demo_power_romfsHow to build the ROS 2 demo system on a tablet: Use a tablet with Ubuntu 20. 04 LTS (Focal Fossa) installation:  Install the ROS 2 Desktop systemsudo apt update &amp;&amp; sudo apt install localessudo locale-gen en_US en_US. UTF-8sudo update-locale LC_ALL=en_US. UTF-8 LANG=en_US. UTF-8export LANG=en_US. UTF-8sudo apt update &amp;&amp; sudo apt install curl gnupg2 lsb-releasecurl -s https://raw. githubusercontent. com/ros/rosdistro/master/ros. asc | sudo apt-key add -sudo sh -c 'echo  deb [arch=$(dpkg --print-architecture)] http://packages. ros. org/ros2/ubuntu $(lsb_release -cs) main  &gt; /etc/apt/sources. list. d/ros2-latest. list'sudo apt update &amp;&amp; sudo apt install ros-foxy-desktopsource /opt/ros/foxy/setup. bashsudo apt install -y python3-pippip3 install -U argcompletesudo apt install python3-colcon-common-extensions Install a micro_ROS agentmkdir ~/microros_ws &amp;&amp; cd ~/microros_wsgit clone -b $ROS_DISTRO https://github. com/micro-ROS/micro_ros_setup. git src/micro_ros_setupsudo apt update &amp;&amp; rosdep updaterosdep install --from-path src --ignore-src -ycolcon buildsource install/local_setup. bashros2 run micro_ros_setup create_agent_ws. shros2 run micro_ros_setup build_agent. sh Install ROS 2 Demo Box packegescd ~/git clone ssh://git@10. 0. 9. 18:6822/amalki/demo_suitcase. gitcd ~/demo_suitcase/colcon build Configure the static Ethernet addressIPv4 address: 192. 168. 10. 2netmask 255. 255. 255. 0How to build the ROS 2 demo system on Raspberry Pi 4:    Install the Ubuntu Server 20. 04 on Raspberry Pi 4     Power on Raspberry Pi, obtain a console using ssh and install the ROS 2 Foxy system as following  sudo locale-gen en_US en_US. UTF-8sudo update-locale LC_ALL=en_US. UTF-8 LANG=en_US. UTF-8export LANG=en_US. UTF-8sudo apt update &amp;&amp; sudo apt install curl gnupg2 lsb-releasecurl -s https://raw. githubusercontent. com/ros/rosdistro/master/ros. asc | sudo apt-key add -sudo sh -c 'echo  deb [arch=$(dpkg --print-architecture)] http://packages. ros. org/ros2/ubuntu $(lsb_release -cs) main  &gt; /etc/apt/sources. list. d/ros2-latest. list'sudo apt updatesudo apt install ros-foxy-ros-basesudo apt install python3-colcon-common-extensions Install ROS 2 Demo Box packagescd ~/git clone ssh://git@10. 0. 9. 18:6822/amalki/demo_suitcase. gitcd ~/demo_suitcase/colcon build Configure the static eth0 address assingment in the /etc/netplan/50-cloud-init. yaml filenetwork:  ethernets:    eth0:      dhcp4: no       dhcp6: no       addresses: [192. 168. 10. 4/24]      gateway4: 192. 168. 10. 1  version: 2 Switch off the serial console by adjusting the /boot/firmware/cmdline. txt filenet. ifnames=0 dwc_otg. lpm_enable=0 root=LABEL=writable rootfstype=ext4 elevator=deadline rootwait fixrtc Boot the Raspberry Pi and abort the boot process through pressing a key on a serial terminal and set the bootdelay variable to -2U-Boot&gt; setenv bootdelay -2U-Boot&gt; saveenv Put the startup_rpi. sh script into a boot up sequence to run the demo application on a Rasberry Pi start upRunning the demo: Connect the devices via an Ethernet switch and power them on, then run the command on the tablet ~/demo_suitcase/startup. shAfter some time two rqt windows should appear with sensors data histograms.  License: This repository is open-sourced under the Apache-2. 0 license. See the LICENSE file for details. For a list of other open-source components included in this repository, see thefile 3rd-party-licenses. txt Known Issues/Limitations: There are no known limitations. "
        }, {
        "id": 139,
        "url": "https://micro-ros.github.io//docs/tutorials/demos/fiware_demo/",
        "title": "Interfacing with FIWARE Context Broker",
        "body": " - Work-in-progress. "
        }, {
        "id": 140,
        "url": "https://micro-ros.github.io//docs/tutorials/demos/kobuki_demo/",
        "title": "Kobuki Demo",
        "body": " - The micro-ROS Kobuki Demo illustrates the use of micro-ROS on the Kobuki platform, which is the mobile base of the well-known Turtlebot 2 research robot. The basic idea and working principle of this demo is as follows: Instead of a laptop running ROS, the Kobuki is equipped with a STM32F4 microcontroller only. This STM32F4 runs the micro-ROS stack and a port of the thin_kobuki driver, which interacts with the robot’s firmware (which runs on a built-in microcontroller). The STM32F4 communicates the sensor data via DDS-XRCE to a remote laptop running a standard ROS 2 stack, the micro-ROS agent and rviz. At the same time, using the other direction of communication, the Kobuki can be remote-controlled.  To run this demo yourself, follow the instructions given in https://github. com/micro-ROS/micro-ROS_kobuki_demo "
        }, {
        "id": 141,
        "url": "https://micro-ros.github.io//docs/tutorials/demos/moveit2_demo/",
        "title": "MoveIt 2 Demo",
        "body": " - MoveIt 2 + micro-ROS demoThis demo shows the integration between micro-ROS and MoveIt 2, a manipulation framework for robotics applications created and maintained by PickNik. By running this demo code, you can see how the MoveIt 2 manipulation and planification algorithms are fed by the position (attitude) calculated in a pose estimator that runs in micro-ROS. This pose is calculated by using data from inertial sensors. The final result is displayed with the ROS visualization tool RViz. micro-ROS runs in a a STM32L4 Development IoT kit board in combination with Zephyr. The board offers several general-purpose I/O pins and peripherals to communicate its 32-bits microcontroller with the external world. It also includes a lot of sensors. For this demo, we make use of a 6-DoF Inertial Measurement Unit (LSM6DSL), composed of an accelerometer and a gyroscope, and a 3-DoF magnetometer (LIS3MDL). The fusion of the measurements fetched by these sensors outputs the pose, or relative orientation of the board with respect to a fixed reference frame. The pose data is then forwarded to the ROS 2 world, where it is consumed by both RViz and MoveIt 2. RViz uses it directly to represent the position and orientation of the board in its graphical interface, and MoveIt 2 uses it to calculate the movement that the virtual arm has to perform to ‘touch’ it, according to its kinematic algorithms. The resulting movement is then integrated into RViz and represented by means of its virtual panda robotic arm, a standard tool used by MoveIt in tutorials and graphic interfaces.  Usage: micro-ROS: Install and run micro-ROS attitude_estimator demo for ST Discovery board and Zephyr RTOS. For detailed info about the micro-ROS build system visit micro-ROS tutorials # Create a micro-ROS Agent ros2 run micro_ros_setup create_agent_ws. shros2 run micro_ros_setup build_agent. sh# Build and flash the micro-ROS appros2 run micro_ros_setup create_firmware_ws. sh zephyr discovery_l475_iot1# Check https://github. com/micro-ROS/zephyr_apps/tree/foxy/apps/attitude_estimator for instructions for tf2_msgsros2 run micro_ros_setup configure_firmware. sh attitude_estimator -t serial -d 1ros2 run micro_ros_setup build_firmware. sh# Connect the ST Discovery board with the ST-Link USB port and switch the power selector to the correct positionros2 run micro_ros_setup flash_firmware. sh# Run the micro-ROS Agentsource install/local_setup. bashros2 run micro_ros_agent micro_ros_agent serial --dev [ST Disco serial device] -v6MoveIt2: Using a ROS 2 Foxy installation install MoveIt2 as explained in their webpage. Now in the same workspace: git clone https://github. com/micro-ROS/micro-ROS_moveit2_democolcon build --event-handlers desktop_notification- status- --packages-select microros_moveit2_demo --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Releasesource install/local_setup. bashros2 launch microros_moveit2_demo microros_moveit2_demo. launch. py"
        }, {
        "id": 142,
        "url": "https://micro-ros.github.io//docs/tutorials/demos/openmanipulator_demo/",
        "title": "OpenManipulator-X Demo",
        "body": " - {% capture my_include %}{% include openmanipulator_demo/README. md %}{% endcapture %}{{ my_include | markdownify }} "
        }, {
        "id": 143,
        "url": "https://micro-ros.github.io//docs/tutorials/demos/overview/",
        "title": "Overview",
        "body": " - In addition to the above entry-level tutorials, we created a collection of demos that showcase micro-ROS in real applications which are easy to reproduce by the community — and thus you. Unlike tutorials, we do not explain the demo code step by step, but provide ready-to-use Docker files to get you started as quickly as possible. Below, you can find a tableChoose yourself:       Demo       RTOS   Hardware*         Kobuki Demo      NuttX   Kobuki Turtlebot2, Olimex LTD STM32-E407       Crazyflie Demo      FreeRTOS   Crazyflie 2. 1 Drone       ToF Sensor Demo      Zephyr   STM32L4 Discovery kit IoT       OpenManipulator-X Demo      Zephyr   Robotis OpenMANIPULATOR-X, Olimex LTD STM32-E407, Raspberry Pi 4       Interfacing with FIWARE Context Broker   –   –           DemoBox Power and Boot Time      NuttX   Olimex LTD STM32-E407, Raspberry Pi 4       Thumper, a six-wheeled robot      NuttX   Wild Thumper 6WD, Olimex LTD STM32-E407       MoveIt 2 Demo      Zephyr   STM32L4 Discovery kit IoT       Combined Demos   –   –       *As a matter of course, in addition to the hardware detailed above, you'll need a computer/laptop, various cables, and further auxiliary equipment. WIP: The demos may also interface with the FIWARE Context Broker, which is the core of the FIWARE open source initiative for context data management. Learn more at Interfacing with FIWARE Context Broker. WIP: The demos can be combined in several ways to demonstrate further functionalities. Go to Combined Demos to learn more about these combinations and how to launch them. "
        }, {
        "id": 144,
        "url": "https://micro-ros.github.io//docs/tutorials/demos/thumper_demo/",
        "title": "Thumper, a six-wheeled robot",
        "body": " - {% capture my_include %}{% include thumper_demo/README. md %}{% endcapture %}{{ my_include | markdownify }} "
        }, {
        "id": 145,
        "url": "https://micro-ros.github.io//docs/tutorials/demos/tof_demo/",
        "title": "Time of Flight Sensor Demo",
        "body": " - {% capture my_include %}{% include sensors_demo/README. md %}{% endcapture %}{{ my_include | markdownify }} "
        }, {
        "id": 146,
        "url": "https://micro-ros.github.io//docs/tutorials/old/6lowpan/",
        "title": "6LoWPAN Guide",
        "body": " - Disclaimer: this tutorial is currently unmantained In this guide, we will show how to use micro-ROS over 6LoWPAN communication. What is 6LoWPAN?6LoWPAN is an acronym o IPv6 over Low-Power Wireless Personal Area Networks. This communication protocol allows wireless communication over IEEE 802. 15. 4 based networks using IPv6. Some of the main advantages are:  Easy to route from radio devices to the Internet, thanks to the usage of the IP packets.  Easy to use on UDP and TCP server/clients.  A protocol designed for low power and constrained devices, perfect or micro-ROS remote sensors. Needed hardwareAt present, 6LoWPAN is only available for the NuttX RTOS. In order to implement the steps highlighted in this guide, you need the following devices:  Raspberry Pi.  Olimex-STM32-E407 board.  PmodRF2 Radio.  micro-ROS-bridge-RPI. Important!You can find a guide of how to setup the micro-ROS-bridge_RPI at its repository. In the micro-ROS-bridge-RPI guide, you can find everything that you need to set-up this device base. Configure the boardThe configuration of the board is divided into two parts: hardware and software set-up. Hardware set-up: First we are going to connect the PmodRF2 radio.           RPi   Olimex   PmodRF2         VIN   1   D13   12       GND   20   GND   11       RESET   17   -   8       INT   16   D8   7       SDI   19   D12   2       SDO   21   D11   3       SCK   23   D13   4       CS   26   D10   1   To ease the set-up process, you can use the RPi pinout and PmodRF2 pinout. The last step is to connect a mini-USB cable to the OTG2 USB port (this USB port next to the Ethernet port). Software set-up: To create and flash the firmware, we are going to use the micro-ROS build system. You can find the instructions at the micro_ros_setup’s README. For this particular guide, it is necessary to use the branch dashing and the configuration profile uros_6lowpan. Once you follow all the instructions in the build system and flash the board, everything is ready. How to use it? Turn on the Olimex board and open the NSH console on a terminal.  Check if all the applications are ready by typing ? on the console. It should return the following:help usage: help [-v] [&lt;cmd&gt;] [     cd    df    help   ls    mw    set    true    ?     cp    echo   hexdump  mb    ps    sh    uname    addroute cmp    exec   ifconfig mkdir   pwd    sleep   umount   basename dirname  exit   ifdown  mh    rm    test   unset    break   dd    false   ifup   mount   rmdir   telnetd  usleep   cat    delroute free   kill   mv    route   time   xd    Builtin Apps: ping6     i8sak     uros_6lowpan  Now turn-on the RPi and execute the micro-ROS-bridge-RPI tool by typing the next command:. / ~/micro-ROS-HB. sh Once everything is configured, it will return the connection data of the 6LoWPAN network:lowpan0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1280    inet6 fe80::b482:ca65:743b:b6bd prefixlen 64 scopeid 0x20&lt;link&gt;    unspec B6-82-CA-65-74-3B-B6-BD-00-00-00-00-00-00-00-00 txqueuelen 1000 (UNSPEC)    RX packets 0 bytes 0 (0. 0 B)    RX errors 0 dropped 0 overruns 0 frame 0    TX packets 21 bytes 2242 (2. 1 KiB)    TX errors 0 dropped 0 overruns 0 carrier 0 collisions 01) Add new 6LoWPAN micro-ROS device	 3) Create UDP micro-ROS Agent		 5) Create Serial micro-ROS Agent server2) Create UDP 6LoWPAN micro-ROS Agent	 4) Create TCP micro-ROS Agent		 6) Quit#?  The value inet6 is the IPv6 direction of the RPi over the 6LoWPAN interface. Copy it because is necessary for the subsequent steps.  Execute the micro-ROS 6LoWPAN application on the Olimex typing the next command:uros_6lowpan &lt;Agent_IP&gt; &lt;Agent_Port&gt; &lt;pub/sub&gt;where Agent_IP is the IPv6 copied previously, Agent_PORT is the port selected for the Agent and pub/sub controls the application behavior: in case of pub it will act as publisher and as in case of sub, it will act as a subscriber.  Once you execute the app, ti will ask you if you want to configure the 6LoWPAN network.      This will return connection data, you should save the inet_6_addr and HWaddr.    Note: if you want to change the ID of the radio, you can do it on the menuconfig of NuttX on the example configuration.    nsh&gt; uros_6lowpan fe80::bc81:c3b9:5c14:1ab 8888 pubDo you want to configure the 6lowpan network? (Y/N)ifdown wpan0. . . OKi8sak: resetting MAC layeri8sak: starting PANIntroduce your 6LowPan ID (It must between 00 and FF (Hex))i8sak: accepting all assoc requestsi8sak: daemon startedifup wpan0. . . OKConnection datawpan0  Link encap:6LoWPAN HWaddr 00:be:ad:de:00:de:fa:00 at UP    inet6 addr: fe80::2be:adde:de:fa00/64    inet6 DRaddr: ::/64    RX: Received Fragment Errors       00000000 00000000 00000000      IPv6   Dropped       00000000 00000000    TX: Queued  Sent   Errors  Timeouts      00000000 00000000 00000000 00000000    Total Errors: 00000000   After this step, the application on the Olimex board will be blocked waiting for a user input confirming that the Agent on the bridge is ready to receive data.   Go back to the bridge, now we are going to add a new 6LoWPAN device. Push 1 + enter. (Note: this step is only necessary if you are attaching for the first time a new device).      First, introduce the IPv6 of the Olimex board (inet6_addr).    Introduce the hardware address of the Olimex board (HWaddr).    Now the device is registered and ready to establish communication.     The final step on the bridge is to execute the micro-ROS-Agent, to do so, push 2 + enter and introduce the port to use. "
        }, {
        "id": 147,
        "url": "https://micro-ros.github.io//docs/tutorials/old/add_microros_config/",
        "title": "Micro-ROS configuration for NuttX",
        "body": " - Disclaimer: this tutorial is currently unmantained       RTOS   ROS2 Version         NuttX   Dashing   In this tutorial, we will see how to set a basic Micro-ROS configuration for NuttX over serial communication. Since this guide is only focused on setting the configuration, you should check the tutorial linked here before: First micro-ROS Application on an RTOS Disclamer This guide is not guarantee to work on every NuttX supported board, because each one has a different level of peripheral implementation and memory available. Required hardware:  Any NuttX supported board with at least these characteristics:     STM32 MCU.    RAM: 125 Kb.    Flash: 512 kb.    Serial communication peripheral.     USB-TTY serial cable. Workspace set-up: As a first thing, we’re going to create a Micro-ROS workspace. To do so, we will execute the following commands on a console: source /opt/ros/$ROS_DISTRO/setup. bashmkdir uros_ws &amp;&amp; cd uros_wsgit clone -b $ROS_DISTRO https://github. com/micro-ROS/micro_ros_setup. git src/micro_ros_setuprosdep update &amp;&amp; rosdep install --from-path src --ignore-src -ycolcon buildsource install/local_setup. bashSet the base configuration: In this guide we will give Micro-ROS support for the Olimex-STM32-H407 board as an example. This board is a simplified version of our supported Olimex-STM32-E407 board. In the previous console, execute the following commands to set the basic configuration: ros2 run micro_ros_setup create_firmware_ws. sh nuttx olimex-stm32-h407ros2 run micro_ros_setup configure_firmware. sh nshIf everything goes fine, it should output the message: Copy filesRefreshing. . . Now the basic NSH configuration is set. With the steps that follow, we will set the required configuration to run Micro-ROS on this board. Micro-ROS configuration. : In the same console as before, run the commands: cd firmware/NuttXmake menuconfigThe menu below should appear: Note: Remember that you should follow this previous tutorial before starting it. First micro-ROS Application on an RTOS In the menu, you need to set the following configuration.  System Type &gt; STM32 Peripheral Support &gt; USART3 RTOS Features &gt; Clocks and Timers &gt; Support CLOCK_MONOTONIC Device Drivers &gt; Serial Driver Support &gt; Serial TERMIOS support Library Routines &gt; Standard Math Library Library Routines &gt; sizeof(_Bool) is a 8-bits Library Routines &gt; Build uClibc++ (must be installed) Application Configuration &gt; micro-ROS Application Configuration &gt; micro-ROS &gt; Transport &gt; Serial Transport Application Configuration &gt; Examples &gt; microROS PublisherPush two times the key “ESC” and set yes, when it asks you if you want to save it. Now the configuration is properly set, the only thing left is to compile it. To do so, continue in the same console and execute the commands: cd . . /. . ros2 run micro_ros_setup build_firmware. shIf everything goes fine, it should return the following output: CP: nuttx. hexCP: nuttx. bin"
        }, {
        "id": 148,
        "url": "https://micro-ros.github.io//docs/tutorials/old/debugging/",
        "title": "Debugging a NuttX Application",
        "body": " - Disclaimer: this tutorial is currently unmantained This tutorial consists of two parts: First, debugging a NuttX target with GDB and OpenOCD. This part covers tool installation and debugging via command line. Second, debugging with Visual Studio Code, i. e. using a modern IDE. Debugging a NuttX target with GDB and OpenOCD: Rare is the program that works on the first try – so you will usually need a debugger. This is even more true on an embedded device, where “printf”-style debugging is very cumbersome. There are many tools for embedded debugging. This tutorial will show you how to debug on the command line, using the GNU Debugger gdb and the Open On-Chip Debugger, OpenOCD. These two open source tools are readily available on Linux, and they form the basis for many more advanced tools, including graphical debuggers. NuttX integration for OpenOCD is relatively new as of the time of writing (early 2019), so this tutorial also includes instructions on how to get and configure it. Pre-Requisites: Hardware:  a supported embedded board a support debugger probeSoftware:  a NuttX development setup, including gdb OpenOCD-Nuttx (but we will show to install that)Install OpenOCD-Nuttx: Sony has added NuttX support to OpenOCD, and most importantly, this includes thread info. Since NuttX is a real RTOS with support multiple tasks/threads, you need thread support to look at anything other than the currently active task. Get the code: The repository is on GitHub at https://github. com/sony/openocd-nuttx. Check it out like this: git clone --depth 1 https://github. com/sony/openocd-nuttx(the ‘–depth 1’ is not required, but it saves you from downloading unnecessary data) Do not compile openocd just yet! Determine your NuttX configuration: NuttX sometimes switches around the memory location of the necessary information, so we need to configure OpenOCD for the currently used NuttX version. Put the following into your . gdbinit: define print-offset printf  #define PID %p/n ,&amp;((struct tcb_s *)(0))-&gt;pid printf  #define XCPREG %p/n ,&amp;((struct tcb_s *)(0))-&gt;xcp. regs printf  #define STATE %p/n ,&amp;((struct tcb_s *)(0))-&gt;task_state printf  #define NAME %p/n ,&amp;((struct tcb_s *)(0))-&gt;name printf  #define NAME_SIZE %d/n ,sizeof(((struct tcb_s *)(0))-&gt;name)endThen run gdb on your nuttx binary and run this function: arm-none-eabi-gdb nuttx(gdb) print-offsetOn Nuttx 7. 27, the result should look something like this:The interesting bits are the #define statements at the end, Now open openocd-nuttx/src/nuttx_header. h in your favor editor, locate the existing #define linesand replace them with what you got. The result should be like this: Configure OpenOCD for NuttX support: OpenOCD has a set of target configurations for the various boards. Since the boards could run one of many RTOS’s, the default configuration doesn’t specify any particular one – so we have to add it. When using the Olimex STM32-E407 board, one of our standard boards, the target configuration file is stm32f4x. cfg and it is normally located in tcl/target/. For your hardware, it might be a different file, so be sure to use the right one. Open the target configuration and locate a line starting with $_TARGETNAME configure. Then add -rtos nuttx to this line. Compile OpenOCD: NOTE The Sony OpenOCD branch has some compile issues on Ubuntu 18. 04 right now, because it uses a newer compiler. The easiest “solution” is to remove the -Werror from your compile. We’ll submit a patch soon. To compile and install OpenOCD, after you made your changes, run . /bootstrap. /configuremakesudo make installTest OpenOCD: To test OpenOCD, try the following command line: /usr/local/bin/openocd -f /usr/share/openocd/scripts/interface/ftdi/olimex-arm-usb-ocd-h. cfg -f stm32f4x. cfg -c init -c  reset halt The output should look as in the following image: OpenOCD will then block, waiting for a debugger to attach, so lets do that in the next section. Running GDB with OpenOCD: Run gdb in your NuttX directory as follows: arm-none-eabi-gdb nuttx(gdb) target extended-remote :3333(gdb) contThis connected to the gdb server running on port 3333 (OpenOCD default) of the same machine. It will sit on the NuttX _start function, which isn’t very interesting, so we let it continue. At this moment we have not defined any breakpoints, yet, so you can just press Ctrl-C to interrupt the running program again. This will interrupt it after NuttX had a chance to do initialization, so we will actually get to see some data. Inspect the program: Now, if everything worked correctly, we should get some information from the RTOS, such as thread info. To test, type info threads at the gdb prompt to get a thread info table. Your output will very depending on the NuttX configuration. On my bare-bones NSH-only configuration, it looks as follows:So we see four threads, two of which are the OS work queues, one is the init thread, and one is the idle thread. Most likely, NuttX has stopped in the idle thread, which isn’t very interesting. To inspect the others, we can use the thread command to switch a thread and then maybe display a backtrace and some variables. Try the following: thread 2info localsprint rtcbprint *rtcbThis switches to thread 2 and then inspects the local variables, of which there are two, one being called rtcb. We print it, see its a pointer to a structure, so we dereference and print again to display all the structure fields. This should look something like the following:In my case, this is the NSH thread which is waiting for some input. Debugging with Visual Studio Code: This is a follow-up to the tutorial above, because the set up done in that tutorial is a pre-requisite to debugging with Visual Studio Code. Motivation: Visual Studio Code is a modern IDE that is very easy to extend and popular with both the Web/Cloud and IoT communities. It is also one of the easiest IDEs to get working with embedded systems. That said, it is not the most powerful or featureful IDEs for this purpose, but it is easy and will do. Prerequisites:  All the prerequisites of Debugging a NuttX target with GDB and OpenOCD Cortex-M hardware (all of our standard boards are ARM based) Visual Studio CodeInstalling Cortex-Debug: In the extensions marketplace, enter “cortex”, then install “Cortex-Debug”. Depending on your version of Visual Studio Code, you may need to restart after installing the extension. Set up your project for debugging: Open your project folder in Visual Studio Code – this is usually the NuttX folder, or a subdirectory of apps. Create a Visual Studio Code launch configuration for NuttX: From the Debug menu, select Open Configurations. This will open a `launch. json’ file. See Cortex-Debug Launch configurations for documentation. To get started, I have prepared a working launch configuration for using our STM32-E407 board with the ARM-USB-OCD-H jtag probe. If you use a different board or probe, you only need to replace the configFiles section. Each entry in the section is an argument that you would normally pass as a -f option to OpenOCD. {   version :  0. 2. 0 ,   configurations : [    {       name :  Debug (OpenOCD/NuttX) ,       cwd :  ${workspaceRoot} ,       executable :  nuttx ,       request :  launch ,       type :  cortex-debug ,       servertype :  openocd ,       device :  stm32f4x ,       configFiles : [         interface/ftdi/olimex-arm-usb-ocd-h. cfg ,         target/stm32f4x. cfg       ]    }  ]}The name is what will appear in the status bar for running it. Running the debugger: Either press F5 or select Debug/Start Debugging from the menu to get started. This will take a moment, and then you should get a red status bar and the debug window, like in the following image: As in the gdb tutorial, initially you won’t see much because the program is stopped during OS initialization. Press F5 again or click the “play” button from the debug menu at the top of the window, wait a few seconds, then press F6 or click the pause button. The window should change to give you thread, variable, and register information, like in the following. Note that “Call Stack” window displays multiple threads.  Adding an SVD File: You may have noticed that on the left-hand side, there is a sub-window called “Cortex Peripherals” which simply states “No SVD File loaded”. SVD means “System View Description” and is a standard format which microcontroller vendors use to describe the available features of their MCUs. For example, in the case of our STM32-E407 board, which features an STM32F407ZGT6 MCU, we can download the SVD description from STM’s web-page for the STM32F407ZG series. In the “HW Model, CAD Libraries &amp; SVD”, you will find a link to the STM32F4 series SVD. Extract the SVD and then add an svdFile attribute to the launch configuration. The full configuration will look like this: {   version :  0. 2. 0 ,   configurations : [    {       name :  Debug (OpenOCD/SVD) ,       cwd :  ${workspaceRoot} ,       executable :  nuttx ,       request :  launch ,       type :  cortex-debug ,       servertype :  openocd ,       device :  stm32f4x ,       svdFile :  STM32F407. svd ,       configFiles : [         interface/ftdi/olimex-arm-usb-ocd-h. cfg ,         target/stm32f4x. cfg       ]    }  ]}Run the debugger again, and your window should look as follows: Voilà! The Cortex Peripherals is populated with everything that the STM32F407 MCU has to offer. Please note that not all of these peripherals might actually be connected on the board. However, those that are, and that are used in your application, can easily be investigated like this. "
        }, {
        "id": 149,
        "url": "https://micro-ros.github.io//docs/tutorials/old/microros_nuttx_bsp/",
        "title": "Adding Micro-ROS to a NuttX board configuration",
        "body": " - IntroductionIf you want to use Micro-ROS on a board that is not yet supported, this tutorial is for you. However, we can only explain what you have to do on a board which is supported by NuttX already, that is, a board that has a board configuration. Writing a completely new board support package and configuration is beyond the scope of what the Micro-ROS project can teach. Caveats:  The instructions in this tutorial have been tested on Linux only and since they use Linux shell commands, they will probably not work on Windows.  We have only ever used ARM-based boards. Boards using different microcontrollers might needs a different approach.  Our approach to adding C++ atomic swap instructions is problematic and needs further work, but it’ll get you started. Basics: Compiling Micro-ROS for NuttX requires that the Board Configuration has a few C++ settings enabled. This tutorial explains what has to be added to an existing NuttX board configuration. Background: NuttX Board Configurations: Note This section is just for background, you don’t need to create a board configuration yourself! Microcontrollers are very diverse, and very versatile. The type and number of peripherals included differs a lot, and moreover, each specific board offers uses just a subset of them. Therefore, the RTOS needs to be told which peripherals are used on a given board, and which pins the board has connected them to. In some cases, the board also requires custom initialization. This is what we call the “board configuration”. It differs from the so-called “Board Support Package (BSP)” which would contain the drivers for the micro-controller and its peripherals. Directory Structure: In NuttX up to version 7. x (which Micro-ROS currently uses), the configurations are stored in the configs/ subdirectory. In there are subdirectories for each board. The naming scheme differs, but often starts with the vendor, and then the name of the board. For example, the Olimex STM32-E407 reference board has its configuration in configs/olimex-stm32e407. We call this the board base directory. Within the board base directory, there are two things: 1) Board configuration directories, specifically include, scripts, and src. 2) Predefined NuttX build configurations. These directories only have a defconfig file in them, and they are the directories you can pass to scripts/configure. sh. Adding Micro-ROS supportTo add Micro-ROS build support, have two to 2 things: 1) Enable the right C++ settings 1) Add C++ atomics builtins A good example of the necessary modifications can be found in commit 26917196. ## Enabling the right C++ settings All the compiler configuration is found in scripts/Make. defs. Important: Since this is a . defs file, it will only be evaluated by NuttX during configuration. Therefore, if you make changes, you have to do a make distclean and then a tools/configure. sh invocation! 1) Add C++ standard library includes This basically means you have to addARCHXXINCLUDES+=-isystem $(TOPDIR)/include/uClibc++after the block in which that variable is first defined. 2) Enable exceptions and RTTI By default, the board configurations disable exceptions. What we do is that we check whether UCLIBCXX_EXCEPTION is set, and if yes, we enable exceptions and RTTI. See line 80 to 84 of commit 26917196 for an example. ifeq ($(CONFIG_UCLIBCXX_EXCEPTION),y) ARCHCXXFLAGS = -fno-builtin -fcheck-new else ARCHCXXFLAGS = -fno-builtin -fno-exceptions -fcheck-new -fno-rttiendif3) Add libsupc++ to the build. This library is part of the toolchain, but there are multiple versions and you need the right one. The following snippet of Make code does that: LIBSUPXX = ${shell $(CC) $(CXXFLAGS) --print-file-name=libsupc++. a}EXTRA_LIBPATHS = -L  ${shell dirname  $(LIBSUPXX) } EXTRA_LIBS = -lsupc++Add C++ atomics builtins: C++11 and up requires that the toolchain provides atomic swap operations. These are hardware specific and in the toolchain version we currently use, they are not yet available for ARM. Therefore, we add a compatibility file called libatomic. c    Copy libatomic. c from configs/olimex-stm32e407/src/libatomic. c to your board configuration src directory. -     Add libatomic. c to the CSRCS line of src/Makefile.  "
        }, {
        "id": 150,
        "url": "https://micro-ros.github.io//docs/tutorials/old/nsh/",
        "title": "NSH console over UART & USB",
        "body": " - Disclaimer: this tutorial is currently unmantained       RTOS   Board compatible         NuttX   Olimex-STM32-E407   NSH is a system console that can be used through different interfaces. In this tutorial, we will show how to use it over the UART and USB peripherals. Hardware requirements::  Olimex-STM32-E407 board JTAG Flasher device USB-TTL232 cable.  Mini USB cable. Create the firmware: For this tutorial we are going to execute the following configuration in micro_ros_setup: ros2 run micro_ros_setup create_firmware_ws. sh nuttx olimex-stm32-e407# For UARTros2 run micro_ros_setup configure_firmware. sh nsh_uart# For USBros2 run micro_ros_setup configure_firmware. sh nshOnce the board is configured, we need to build it by typing the command: ros2 run micro_ros_setup build_firmware. shIf the compilation succeeds, it should return this output: CP: nuttx. hexCP: nuttx. binFlash the firmwareThe firmware is ready, it is just necessary to upload it. Now you need to do the following connections:  Connect the JTAG flasher device.  Connect the USB TTL-232 to the USART3 in case of UART communication:     USART3 TX -&gt; TTL232 RX   USART3 RX -&gt; TTL232 TX   GND Board -&gt; TTL232 GND     Connect the mini USB to the OTG2 for USB communication. Now flash the board by typing the next command: ros2 run micro_ros_setup flash_firmware. shThis should return this output once the process is finished: wrote 49152 bytes from file nuttx. bin in 6. 279262s (7. 644 KiB/s)Info : Listening on port 6666 for tcl connectionsInfo : Listening on port 4444 for telnet connectionsConnect to the console: Finally, to use the NSH console you need to follow the steps listed below:  Push the reset button. The green LED will turn on to say that it is working properly.  Look for the device by typing dmesg on the console, this should return something like this:# For UART[17154. 225244] usb 1-2: new full-speed USB device number 6 using xhci_hcd[17154. 380060] usb 1-2: New USB device found, idVendor=0403, idProduct=6001, bcdDevice= 6. 00[17154. 380066] usb 1-2: New USB device strings: Mfr=1, Product=2, SerialNumber=3[17154. 380069] usb 1-2: Product: USB &lt;-&gt; Serial Cable[17154. 380072] usb 1-2: Manufacturer: FTDI[17154. 380075] usb 1-2: SerialNumber: 12TBZ31[17154. 400389] usbcore: registered new interface driver usbserial_generic[17154. 400395] usbserial: USB Serial support registered for generic[17154. 402690] usbcore: registered new interface driver ftdi_sio[17154. 402699] usbserial: USB Serial support registered for FTDI USB Serial Device[17154. 402745] ftdi_sio 1-2:1. 0: FTDI USB Serial Device converter detected[17154. 402762] usb 1-2: Detected FT232RL[17154. 403058] usb 1-2: FTDI USB Serial Device converter now attached to ttyUSB0# For USB[20614. 570781] usb 1-2: new full-speed USB device number 7 using xhci_hcd[20614. 724366] usb 1-2: New USB device found, idVendor=0525, idProduct=a4a7, bcdDevice= 1. 01[20614. 724372] usb 1-2: New USB device strings: Mfr=1, Product=2, SerialNumber=3[20614. 724375] usb 1-2: Product: CDC/ACM Serial[20614. 724378] usb 1-2: Manufacturer: NuttX[20614. 724381] usb 1-2: SerialNumber: 0[20614. 745693] cdc_acm 1-2:1. 0: ttyACM0: USB ACM device[20614. 746274] usbcore: registered new interface driver cdc_acm[20614. 746277] cdc_acm: USB Abstract Control Model driver for USB modems and ISDN adaptersIn this specific situation, the device is assigned to dev/ttyUSB0 and dev/ttyACM0 for UART and USB communication respectively. Note that the last number could be different. Finally, execute the next command to open the NSH console: # For UARTsudo minicom -D /dev/ttyUSB0# For USBsudo minicom -D /dev/ttyACM0Once the port is opened, you need to push two times the Enter key and it should show the next menu: nsh&gt; ?help usage: help [-v] [&lt;cmd&gt;] ?      exec    hexdump   mb     sleep     cat     exit    kill    mh     usleep    echo    help    ls     mw     xd     Builtin Apps:nsh&gt;"
        }];

    var idx = lunr(function () {
        this.ref('id')
        this.field('title')
        this.field('body')

        documents.forEach(function (doc) {
            this.add(doc)
        }, this)
    });
    function lunr_search(term) {
        document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
        if(term) {
            document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
            //put results on the screen.
            var results = idx.search(term);
            if(results.length>0){
                //console.log(idx.search(term));
                //if results
                for (var i = 0; i < results.length; i++) {
                    // more statements
                    var ref = results[i]['ref'];
                    var url = documents[ref]['url'];
                    var title = documents[ref]['title'];
                    var body = documents[ref]['body'].substring(0,160)+'...';
                    document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
                }
            } else {
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
            }
        }
        return false;
    }
</script>
<style>
    .lunrsearchresult .title {color: #d9230f;}
    .lunrsearchresult .url {color: silver;}
    .lunrsearchresult a {display: block; color: #777;}
    .lunrsearchresult a:hover, .lunrsearchresult a:focus {text-decoration: none;}
    .lunrsearchresult a:hover .title {text-decoration: underline;}
</style>

<form class="navbar-form navbar-right" onsubmit="return lunr_search(document.getElementById('lunrsearch').value);">
    <div class="form-group">
        <label for="lunrsearch" class="fa fa-search"></label>
        <input type="text" class="form-control fa fa-search" id="lunrsearch" name="q" maxlength="255" placeholder="Search via Lunr.js">
    </div>
</form>
</li>
                <li><a href="https://github.com/micro-ROS/micro-ros.github.io"><span class="fa fa-github" aria-hidden="true"></span></a></li>
            </ul>
       </div>

    </div>
</nav>

    <div class="container" id="lunrsearchresults">
        <ul></ul>
    </div>
 
    <div class="page-content">
        <div class="wrapper">
            <div class="container">
    <div class="row">
        <div class="col-md-4">
          <div class="panel-group" id="accordion" role="tablist" aria-multiselectable="true">

  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  <div class="panel panel-default">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a role="button" data-toggle="collapse" data-parent="#accordion" href="#collapse-8" aria-expanded="false" aria-controls="collapse-8">
          First Steps Tutorials
        </a>
      </h4>
    </div>
    <div id="collapse-8" class="panel-collapse collapse" role="tabpanel" aria-label="Side Navigation">
      <div class="list-group">
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/core/overview/">Overview</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/core/first_application_linux/">First micro-ROS Application on Linux</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/core/first_application_rtos/">First micro-ROS Application on an RTOS</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/core/programming_rcl_rclc/">Programming with rcl and rclc</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/core/zephyr_emulator/">Zephyr Emulator</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/core/teensy_with_arduino/">Teensy with Arduino</a>
        
      </div>
    </div>
  </div>
  

  
  
  
  
  
  
  
  
  
  
  
  
  <div class="panel panel-default">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a role="button" data-toggle="collapse" data-parent="#accordion" href="#collapse-9" aria-expanded="false" aria-controls="collapse-9">
          Advanced Tutorials
        </a>
      </h4>
    </div>
    <div id="collapse-9" class="panel-collapse collapse" role="tabpanel" aria-label="Side Navigation">
      <div class="list-group">
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/advanced/overview/">Overview</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/advanced/microxrcedds_rmw_configuration/">Middleware Configuration</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/advanced/create_new_type/">How to include a custom ROS message in micro-ROS</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/advanced/handling_type_memory/">Handling messages memory in micro-ROS</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/advanced/create_dds_entities_by_ref/">How to use custom QoS in micro-ROS</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/advanced/create_custom_transports/">Creating custom micro-ROS transports</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/advanced/create_custom_static_library/">Creating custom static micro-ROS library</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/advanced/benchmarking/">Benchmarking with the Shadow-Builder</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/advanced/tracing/">Getting started with ROS 2 tracing</a>
        
      </div>
    </div>
  </div>
  

  
  
  
  
  
  
  
  
  
  
  
  
  <div class="panel panel-default">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a role="button" data-toggle="collapse" data-parent="#accordion" href="#collapse-10" aria-expanded="false" aria-controls="collapse-10">
          Unmaintained Tutorials
        </a>
      </h4>
    </div>
    <div id="collapse-10" class="panel-collapse collapse" role="tabpanel" aria-label="Side Navigation">
      <div class="list-group">
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/old/microros_nuttx_bsp/">Adding Micro-ROS to a NuttX board configuration</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/old/nsh/">NSH console over UART &amp; USB</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/old/6lowpan/">6LoWPAN Guide</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/old/debugging/">Debugging a NuttX Application</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/old/add_microros_config/">Micro-ROS configuration for NuttX</a>
        
      </div>
    </div>
  </div>
  

  
  
  
  
  
  
  
  
  
  
  
  
  <div class="panel panel-default">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a role="button" data-toggle="collapse" data-parent="#accordion" href="#collapse-11" aria-expanded="true" aria-controls="collapse-11" class="">
          Demos
        </a>
      </h4>
    </div>
    <div id="collapse-11" class="panel-collapse collapse in" role="tabpanel" aria-label="Side Navigation" aria-expanded="true" style="">
      <div class="list-group">
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/demos/overview/">Overview</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/demos/kobuki_demo/">Kobuki Demo</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/demos/crazyflie_demo/">Crazyflie Demo</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/demos/tof_demo/">Time of Flight Sensor Demo</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/demos/openmanipulator_demo/">OpenManipulator-X Demo</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/demos/fiware_demo/">Interfacing with FIWARE Context Broker</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/demos/demobox_demo/">DemoBox Power and Boot Time</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/demos/thumper_demo/">Thumper, a six-wheeled robot</a>
        
          
          
          <a class="list-group-item " href="https://micro.ros.org/docs/tutorials/demos/combined_demos/">Combined Demos</a>
        
          
          
          <a class="list-group-item active" href="https://micro.ros.org/docs/tutorials/demos/moveit2_demo/">MoveIt 2 Demo</a>
        
      </div>
    </div>
  </div>
</div>

        </div>

        <div class="col-md-8">
            <div id="markdown-content-container">
<h1 id="moveit-2--micro-ros-demo">MoveIt 2 + micro-ROS demo</h1>

<p>このデモではmicro-ROSと<a href="https://moveit.ros.org/">MoveIt 2</a>の統合を示す、（MoveIt 2）は<a href="https://picknik.ai/">PickNik</a>によって作成、メンテーされるマニピュレーションフレームワークである。</p>
<p>このデモコードを実行することでmicro-ROS内でいかにMoveIt 2のマニピュレーションと計画アルゴリズムで与えられた姿勢で推定位置を計算することを確認できる。
  位置は慣性センサーのデータで計算される。最終の結果がROSの視覚ツールRViz上に表示される。</p>

<p>micro-ROSは<a href="https://zephyrproject.org/">Zephyr</a>入りの<a href="https://www.st.com/en/evaluation-tools/b-l475e-iot01a.html">TM32L4開発キット</a>S上で実行される。
  このボードは複数汎用のI/Oピンおよび周辺機器を通じて32ビットのマイコンを外部世界と連結する。
  また多くのセンサーも含まれている。このデモでは6自由度慣性計測ユニット（LSM6DSL）、加速度計やジャイロスコープ、そして3自由度
  磁気センサーにより構成されている (LIS3MDL)。
  これらセンサーにより構成される計測器は位置、あるいはボードの相対座標を出力する（固定参照フレームに対して）。</p>

<p>位置データはROS 2へフォーワードされ、RVizやMoveIt 2で使用される。
  RVizは直接それを使ってボードの姿勢と回転をグラフィックインタフェースに表示する、
  MoveIt 2はそれを使って動きを計算し、バーチャルのアームが運動学によりそれを'ターチ'するように動く。
  結果の動きはRViz上でバーチャルのパンターロボットアームにより再現される、彼はMoveItチュートリアルとグラフィックインタフェースで
  使用されるスタンドツールである。</p>

<p><img src="MoveIt%202%20Demo%20|%20micro-ROS_files/demo.png" alt="Demo setup" class="img-responsive"></p>

<h2 id="usage">Usage</h2>

<h3 id="micro-ros">micro-ROS</h3>

<p>インストールを済ませたらST Discovery boardとZephyr RTOS用の姿勢推論デモを実行してください。
  micro-ROSビルドシステムの詳細を<a href="https://micro-ros.github.io/docs/tutorials/core/first_application_linux/">micro-ROSチュートリアル</a>を参照してください。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Create a micro-ROS Agent </span>
ros2 run micro_ros_setup create_agent_ws.sh
ros2 run micro_ros_setup build_agent.sh

<span class="c"># Build and flash the micro-ROS app</span>
ros2 run micro_ros_setup create_firmware_ws.sh zephyr discovery_l475_iot1

<span class="caution">#1 コメントの手順をスールするとコンパイルエラーになる</span>
<span class="c"># Check https://github.com/micro-ROS/zephyr_apps/tree/foxy/apps/attitude_estimator for instructions for tf2_msgs</span>
ros2 run micro_ros_setup configure_firmware.sh attitude_estimator <span class="nt">-t</span> serial <span class="nt">-d</span> 1
ros2 run micro_ros_setup build_firmware.sh

<span class="caution">#2 switch the power selector to the correct positionの意味？</span>
<span class="c"># Connect the ST Discovery board with the ST-Link USB port and switch the power selector to the correct position</span>
ros2 run micro_ros_setup flash_firmware.sh

<span class="c"># Run the micro-ROS Agent</span>
<span class="nb">source install</span>/local_setup.bash
<span class="caution">#3 [ST Disco serial device]の部分を、マイコンに振られるportネームで置き換える </span>
ros2 run micro_ros_agent micro_ros_agent serial <span class="nt">--dev</span> <span class="o">[</span>ST Disco serial device] <span class="nt">-v6</span>

</code></pre></div></div>

<h3 id="moveit2">MoveIt2</h3>

<p><a href="https://moveit.ros.org/install-moveit2/source/">公式ページ</a>の説明に従ってROS 2 FoxyバージョンにMoveIt2をインストールする。</p>

<p>同じワークスペースで：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/micro-ROS/micro-ROS_moveit2_demo
colcon build <span class="nt">--event-handlers</span> desktop_notification- status- <span class="nt">--packages-select</span> microros_moveit2_demo <span class="nt">--symlink-install</span> <span class="nt">--cmake-args</span> <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span>Release
<span class="nb">source install</span>/local_setup.bash

ros2 launch microros_moveit2_demo microros_moveit2_demo.launch.py
</code></pre></div></div>
</div>
            <div style="clear:both;">
              <p class="text-center">
                <br>
                <a target="_blank" href="https://github.com/micro-ROS/micro-ros.github.io/blob/master/_docs/tutorials/demos/moveit2_demo/index.md" class="btn btn-default githubEditButton" role="button">
                  <i class="fa fa-pencil fa-lg"></i> Improve this page
                </a>
              </p>
            </div>
            <hr>
            





  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  
    <ul class="pager">
      
        
        
        <li class="previous">
          <a href="https://micro.ros.org/docs/tutorials/demos/combined_demos/">
            <span aria-hidden="true">←</span> Previous
          </a>
        </li>
      

      
        
        
        <li class="next">
          <a href="https://micro.ros.org/docs/api/overview/">
            Next <span aria-hidden="true">→</span>
          </a>
        </li>
      
      </ul>
    <div class="clear"></div>
    

        </div>

    </div>
</div>

        </div>
    </div>

    <footer class="footer">
    <div class="container">
        <p class="text-center">
            micro-ROS 2021 | <a rel="license" href="http://creativecommons.org/licenses/by-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="MoveIt%202%20Demo%20|%20micro-ROS_files/80x15.png"></a> |
            Powered by <a href="https://github.com/aksakalli/jekyll-doc-theme">Jekyll Doc Theme</a>
            | <a href="https://micro.ros.org/privacy">privacy</a> | <a href="https://micro.ros.org/docs/imprint">imprint</a>
        </p>
    </div>
</footer>

    <script>
  var baseurl = ''
</script>
<script src="MoveIt%202%20Demo%20|%20micro-ROS_files/jquery-1.js"></script>
<script src="MoveIt%202%20Demo%20|%20micro-ROS_files/bootstrap.js"></script>
<script src="MoveIt%202%20Demo%20|%20micro-ROS_files/typeahead.js"></script>

<script src="MoveIt%202%20Demo%20|%20micro-ROS_files/main.js"></script>


    <style>
    #cookie-notice {padding: 7px 15px; display: none; text-align: center; position: fixed; bottom: 0; width: 100%; background: #222; color: rgba(255,255,255,0.8);}
    #cookie-notice a {cursor: pointer; margin-left: 10px;}
    @media (max-width: 767px) {
        #cookie-notice span {display: block; padding-top: 3px; margin-bottom: 13px;}
        #cookie-notice a {position: relative; bottom: 4px;}
    }
</style>
<div id="cookie-notice"><span>We would like to use third party cookies and scripts to improve the functionality of this website.</span><a id="cookie-notice-accept" class="btn btn-primary btn-sm">Approve</a><a href="https://micro.ros.org/privacy" class="btn btn-primary btn-sm">More info</a></div>
<script>
    function createCookie(name,value,days) {
        var expires = "";
        if (days) {
            var date = new Date();
            date.setTime(date.getTime() + (days*24*60*60*1000));
            expires = "; expires=" + date.toUTCString();
        }
        document.cookie = name + "=" + value + expires + "; path=/";
    }
    function readCookie(name) {
        var nameEQ = name + "=";
        var ca = document.cookie.split(';');
        for(var i=0;i < ca.length;i++) {
            var c = ca[i];
            while (c.charAt(0)==' ') c = c.substring(1,c.length);
            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
        }
        return null;
    }
    function eraseCookie(name) {
        createCookie(name,"",-1);
    }
    function include_gtag() {
        
             
                window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', "UA-139926223-1");
 
             
        
    }

    if(readCookie('cookie-notice-dismissed')=='true') {
            include_gtag();
        } else {
        $('#cookie-notice').show();
    }
    $('#cookie-notice-accept').click(function() {
        createCookie('cookie-notice-dismissed','true',31);
        include_gtag();
        $('#cookie-notice').hide();
    });

</script>




</body></html>